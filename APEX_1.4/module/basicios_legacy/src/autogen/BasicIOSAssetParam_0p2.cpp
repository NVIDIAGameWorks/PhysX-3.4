// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2015 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "BasicIOSAssetParam_0p2.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace BasicIOSAssetParam_0p2NS;

const char* const BasicIOSAssetParam_0p2Factory::vptr =
    NvParameterized::getVptr<BasicIOSAssetParam_0p2, BasicIOSAssetParam_0p2::ClassAlignment>();

const uint32_t NumParamDefs = 10;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 2, 3, 4, 5, 6, 7, 8, 9,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 9 },
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->restDensity), NULL, 0 }, // restDensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->particleRadius), NULL, 0 }, // particleRadius
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxParticleCount), NULL, 0 }, // maxParticleCount
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->maxInjectedParticleCount), NULL, 0 }, // maxInjectedParticleCount
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->sceneGravityScale), NULL, 0 }, // sceneGravityScale
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->externalAcceleration), NULL, 0 }, // externalAcceleration
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionGroupName), NULL, 0 }, // collisionGroupName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionGroupMaskName), NULL, 0 }, // collisionGroupMaskName
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->particleMass), NULL, 0 }, // particleMass
};


bool BasicIOSAssetParam_0p2::mBuiltFlag = false;
NvParameterized::MutexType BasicIOSAssetParam_0p2::mBuiltFlagMutex;

BasicIOSAssetParam_0p2::BasicIOSAssetParam_0p2(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &BasicIOSAssetParam_0p2FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

BasicIOSAssetParam_0p2::~BasicIOSAssetParam_0p2()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void BasicIOSAssetParam_0p2::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~BasicIOSAssetParam_0p2();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* BasicIOSAssetParam_0p2::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* BasicIOSAssetParam_0p2::getParameterDefinitionTree(void) const
{
	BasicIOSAssetParam_0p2* tmpParam = const_cast<BasicIOSAssetParam_0p2*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType BasicIOSAssetParam_0p2::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType BasicIOSAssetParam_0p2::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void BasicIOSAssetParam_0p2::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<BasicIOSAssetParam_0p2::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void BasicIOSAssetParam_0p2::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void BasicIOSAssetParam_0p2::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="restDensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("restDensity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("longDescription", "\nAuthored density of the instanced objects simulated by this IOS.  Emitters need this\nvalue for constant density emitter effects.\n", true);
		HintTable[2].init("min", uint64_t(0), true);
		HintTable[3].init("shortDescription", "Rest density of particles", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="particleRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("particleRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("longDescription", "\nRadius of a particle.\n", true);
		HintTable[2].init("min", uint64_t(0), true);
		HintTable[3].init("shortDescription", "Radius of a particle", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 4);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="maxParticleCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("maxParticleCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("min", uint64_t(0), true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("min", uint64_t(0), true);
		HintTable[1].init("shortDescription", "Maximum particle count", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="maxInjectedParticleCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("maxInjectedParticleCount", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("min", uint64_t(0), true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("longDescription", "\nThe maximum number of new particles to be spawned on each frame. Use values >1 to provide the absolute value,\nor 0 <= x <= 1 to provide the percentage rate to overall number of particles. \n", true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Maximum number of newly created objects on each frame", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="sceneGravityScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("sceneGravityScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("min", uint64_t(0), true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("min", uint64_t(0), true);
		HintTable[1].init("shortDescription", "Used to scale, or even disable the basic IOS's gravity", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="externalAcceleration"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("externalAcceleration", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("gameScale", "true", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("shortDescription", "Acceleration (m/s^2) applied to all particles at all time steps (added to the scaled scene gravity).", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="collisionGroupName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("collisionGroupName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("longDescription", "Defines the name that specifies the collision group for this IOS.\nAny actor that this IOS will interact with must have the same collision group name.\n", true);
		HintTable[1].init("programmersDescription", "There can be upto 32 collision groups numbered 0-31.  APEX allocates collision group numbers sequentially\nstarting at 0 and incrementing.  Consequently if games want to use their own collision groups they should\nstart at 31 and allocate them sequentially downward to avoid conflicting with the APEX collision groups.\n", true);
		HintTable[2].init("shortDescription", "The collision group name for this IOS.", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="collisionGroupMaskName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("collisionGroupMaskName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("longDescription", "Defines the name that specifies the name of the collision group mask (128 bit) for this IOS.\nThis is the four 32 bit unsigned int version of collision detection.\nAny actor that this IOS will interact with must have a mask and a filter equation that returns true.\n", true);
		HintTable[1].init("programmersDescription", "See the PhsyX SDK documentation 'NxGroupsMask Class Reference' for further details.\n", true);
		HintTable[2].init("shortDescription", "The collision group Mask name for this IOS.", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="particleMass"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("particleMass", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mass of a particle", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[9];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(2);
		Children[2] = PDEF_PTR(3);
		Children[3] = PDEF_PTR(4);
		Children[4] = PDEF_PTR(5);
		Children[5] = PDEF_PTR(6);
		Children[6] = PDEF_PTR(7);
		Children[7] = PDEF_PTR(8);
		Children[8] = PDEF_PTR(9);

		ParamDefTable[0].setChildren(Children, 9);
	}

	mBuiltFlag = true;

}
void BasicIOSAssetParam_0p2::initStrings(void)
{
	collisionGroupName.isAllocated = true;
	collisionGroupName.buf = NULL;
	collisionGroupMaskName.isAllocated = true;
	collisionGroupMaskName.buf = NULL;
}

void BasicIOSAssetParam_0p2::initDynamicArrays(void)
{
}

void BasicIOSAssetParam_0p2::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	restDensity = float(0);
	particleRadius = float(1);
	maxParticleCount = uint32_t(16384);
	maxInjectedParticleCount = float(0.1);
	sceneGravityScale = float(1);
	externalAcceleration = physx::PxVec3(init(0, 0, 0));
	particleMass = float(1);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void BasicIOSAssetParam_0p2::initReferences(void)
{
}

void BasicIOSAssetParam_0p2::freeDynamicArrays(void)
{
}

void BasicIOSAssetParam_0p2::freeStrings(void)
{

	if (collisionGroupName.isAllocated && collisionGroupName.buf)
	{
		mParameterizedTraits->strfree((char*)collisionGroupName.buf);
	}

	if (collisionGroupMaskName.isAllocated && collisionGroupMaskName.buf)
	{
		mParameterizedTraits->strfree((char*)collisionGroupMaskName.buf);
	}
}

void BasicIOSAssetParam_0p2::freeReferences(void)
{
}

} // namespace parameterized
} // namespace nvidia
