// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2015 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "TurbulenceFSAssetParams_1p3.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace TurbulenceFSAssetParams_1p3NS;

const char* const TurbulenceFSAssetParams_1p3Factory::vptr =
    NvParameterized::getVptr<TurbulenceFSAssetParams_1p3, TurbulenceFSAssetParams_1p3::ClassAlignment>();

const uint32_t NumParamDefs = 61;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 4, 7, 10, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
	30, 31, 32, 33, 34, 35, 40, 41, 45, 46, 47, 53, 58, 59, 60, 2, 3, 5, 6, 8, 9, 12,
	13, 36, 37, 38, 39, 42, 43, 44, 48, 49, 50, 51, 52, 54, 55, 56, 57,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 36 },
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->gridXRange), CHILDREN(36), 2 }, // gridXRange
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->min), NULL, 0 }, // gridXRange.min
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->max), NULL, 0 }, // gridXRange.max
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->gridYRange), CHILDREN(38), 2 }, // gridYRange
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->min), NULL, 0 }, // gridYRange.min
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->max), NULL, 0 }, // gridYRange.max
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->gridZRange), CHILDREN(40), 2 }, // gridZRange
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->min), NULL, 0 }, // gridZRange.min
	{ TYPE_ENUM, false, (size_t)(&((turbulenceRangeStructEnum_Type*)0)->max), NULL, 0 }, // gridZRange.max
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->gridSizeWorld), NULL, 0 }, // gridSizeWorld
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->updatesPerFrameRange), CHILDREN(42), 2 }, // updatesPerFrameRange
	{ TYPE_F32, false, (size_t)(&((rangeStructF32_Type*)0)->min), NULL, 0 }, // updatesPerFrameRange.min
	{ TYPE_F32, false, (size_t)(&((rangeStructF32_Type*)0)->max), NULL, 0 }, // updatesPerFrameRange.max
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->angularVelocityMultiplier), NULL, 0 }, // angularVelocityMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->angularVelocityClamp), NULL, 0 }, // angularVelocityClamp
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->linearVelocityMultiplier), NULL, 0 }, // linearVelocityMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->linearVelocityClamp), NULL, 0 }, // linearVelocityClamp
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->velocityFieldFadeTime), NULL, 0 }, // velocityFieldFadeTime
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->velocityFieldFadeDelay), NULL, 0 }, // velocityFieldFadeDelay
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->velocityFieldFadeIntensity), NULL, 0 }, // velocityFieldFadeIntensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->boundaryFadePercentage), NULL, 0 }, // boundaryFadePercentage
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->boundarySizePercentage), NULL, 0 }, // boundarySizePercentage
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionFilterDataName), NULL, 0 }, // collisionFilterDataName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->fieldBoundaryFilterDataName), NULL, 0 }, // fieldBoundaryFilterDataName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->fieldSamplerFilterDataName), NULL, 0 }, // fieldSamplerFilterDataName
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxCollidingObjects), NULL, 0 }, // maxCollidingObjects
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxVelocitySources), NULL, 0 }, // maxVelocitySources
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxHeatSources), NULL, 0 }, // maxHeatSources
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxSubstanceSources), NULL, 0 }, // maxSubstanceSources
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dragCoeff), NULL, 0 }, // dragCoeff
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->externalVelocity), NULL, 0 }, // externalVelocity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fieldVelocityMultiplier), NULL, 0 }, // fieldVelocityMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fieldVelocityWeight), NULL, 0 }, // fieldVelocityWeight
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useHeat), NULL, 0 }, // useHeat
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->heatParams), CHILDREN(44), 4 }, // heatParams
	{ TYPE_F32, false, (size_t)(&((HeatParams_Type*)0)->temperatureBasedForceMultiplier), NULL, 0 }, // heatParams.temperatureBasedForceMultiplier
	{ TYPE_F32, false, (size_t)(&((HeatParams_Type*)0)->ambientTemperature), NULL, 0 }, // heatParams.ambientTemperature
	{ TYPE_VEC3, false, (size_t)(&((HeatParams_Type*)0)->heatForceDirection), NULL, 0 }, // heatParams.heatForceDirection
	{ TYPE_F32, false, (size_t)(&((HeatParams_Type*)0)->thermalConductivity), NULL, 0 }, // heatParams.thermalConductivity
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useDensity), NULL, 0 }, // useDensity
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->densityParams), CHILDREN(48), 3 }, // densityParams
	{ TYPE_F32, false, (size_t)(&((DensityParams_Type*)0)->diffusionCoef), NULL, 0 }, // densityParams.diffusionCoef
	{ TYPE_F32, false, (size_t)(&((DensityParams_Type*)0)->densityFieldFade), NULL, 0 }, // densityParams.densityFieldFade
	{ TYPE_U32, false, (size_t)(&((DensityParams_Type*)0)->densityGridMultiplier), NULL, 0 }, // densityParams.densityGridMultiplier
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->isEnabledOptimizedLOD), NULL, 0 }, // isEnabledOptimizedLOD
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->customLOD), NULL, 0 }, // customLOD
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->lodWeights), CHILDREN(51), 5 }, // lodWeights
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->maxDistance), NULL, 0 }, // lodWeights.maxDistance
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->distanceWeight), NULL, 0 }, // lodWeights.distanceWeight
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->bias), NULL, 0 }, // lodWeights.bias
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->benefitBias), NULL, 0 }, // lodWeights.benefitBias
	{ TYPE_F32, false, (size_t)(&((LODWeights_Type*)0)->benefitWeight), NULL, 0 }, // lodWeights.benefitWeight
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->noiseParams), CHILDREN(56), 4 }, // noiseParams
	{ TYPE_F32, false, (size_t)(&((NoiseParams_Type*)0)->noiseStrength), NULL, 0 }, // noiseParams.noiseStrength
	{ TYPE_VEC3, false, (size_t)(&((NoiseParams_Type*)0)->noiseSpacePeriod), NULL, 0 }, // noiseParams.noiseSpacePeriod
	{ TYPE_F32, false, (size_t)(&((NoiseParams_Type*)0)->noiseTimePeriod), NULL, 0 }, // noiseParams.noiseTimePeriod
	{ TYPE_U32, false, (size_t)(&((NoiseParams_Type*)0)->noiseOctaves), NULL, 0 }, // noiseParams.noiseOctaves
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dragCoeffForRigidBody), NULL, 0 }, // dragCoeffForRigidBody
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fluidViscosity), NULL, 0 }, // fluidViscosity
	{ TYPE_REF, false, (size_t)(&((ParametersStruct*)0)->volumeRenderMaterialName), NULL, 0 }, // volumeRenderMaterialName
};


bool TurbulenceFSAssetParams_1p3::mBuiltFlag = false;
NvParameterized::MutexType TurbulenceFSAssetParams_1p3::mBuiltFlagMutex;

TurbulenceFSAssetParams_1p3::TurbulenceFSAssetParams_1p3(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &TurbulenceFSAssetParams_1p3FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

TurbulenceFSAssetParams_1p3::~TurbulenceFSAssetParams_1p3()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void TurbulenceFSAssetParams_1p3::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~TurbulenceFSAssetParams_1p3();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* TurbulenceFSAssetParams_1p3::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* TurbulenceFSAssetParams_1p3::getParameterDefinitionTree(void) const
{
	TurbulenceFSAssetParams_1p3* tmpParam = const_cast<TurbulenceFSAssetParams_1p3*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType TurbulenceFSAssetParams_1p3::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType TurbulenceFSAssetParams_1p3::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void TurbulenceFSAssetParams_1p3::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<TurbulenceFSAssetParams_1p3::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void TurbulenceFSAssetParams_1p3::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void TurbulenceFSAssetParams_1p3::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Contains the asset properties for this Turbulence field sampler.", true);
		ParamDefTable[0].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="gridXRange"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("gridXRange", TYPE_STRUCT, "turbulenceRangeStructEnum", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of grid cells in X dimension.", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="gridXRange.min"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("min", TYPE_ENUM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the lower bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[2].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="gridXRange.max"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("max", TYPE_ENUM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the higher bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[3].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="gridYRange"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("gridYRange", TYPE_STRUCT, "turbulenceRangeStructEnum", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of grid cells in Y dimension.", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="gridYRange.min"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("min", TYPE_ENUM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the lower bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[5].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="gridYRange.max"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("max", TYPE_ENUM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the higher bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[6].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="gridZRange"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("gridZRange", TYPE_STRUCT, "turbulenceRangeStructEnum", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of grid cells in Z dimension.", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="gridZRange.min"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("min", TYPE_ENUM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the lower bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[8].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="gridZRange.max"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("max", TYPE_ENUM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Turbulence resolution. The higher resolution, the higher precision, but the simulation time is also longer. This is the higher bound of possible turbulence grid resolution, depending on the LOD settings", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "EGR_12", "EGR_16", "EGR_24", "EGR_32", "EGR_48", "EGR_64", "EGR_96", "EGR_128" };
		ParamDefTable[9].setEnumVals((const char**)EnumVals, 8);




	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="gridSizeWorld"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("gridSizeWorld", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Size of the grid in world space.", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="updatesPerFrameRange"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("updatesPerFrameRange", TYPE_STRUCT, "rangeStructF32", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The number of updates per frame. See APEX documentation for limitations.", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="updatesPerFrameRange.min"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("min", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Minimum value", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="updatesPerFrameRange.max"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("max", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Maximum value", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="angularVelocityMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("angularVelocityMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a multiplier for the angular velocity set by the user.", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="angularVelocityClamp"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("angularVelocityClamp", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a clamp for the angular velocity set by the user.", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="linearVelocityMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("linearVelocityMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a multiplier for the linear velocity set by the user.", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="linearVelocityClamp"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("linearVelocityClamp", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "a clamp for the linear velocity set by the user.", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="velocityFieldFadeTime"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("velocityFieldFadeTime", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1000), true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1000), true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Time of velocity field cleaning process [sec]. Cleaning disabled by default.", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="velocityFieldFadeDelay"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("velocityFieldFadeDelay", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1000), true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1000), true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Time without activity before velocity field cleaning process starts [sec]. ", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="velocityFieldFadeIntensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("velocityFieldFadeIntensity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", double(0.01), true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", double(0.01), true);
		HintTable[2].init("shortDescription", "This parameter sets how much each velocity vector should be damped, so (1 - velocityFieldFadeIntensity) of original velocity vector magnitude will be left after the fade process finishes.", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="boundaryFadePercentage"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("boundaryFadePercentage", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Percentage of distance from boundary to center where fade out starts.", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="boundarySizePercentage"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("boundarySizePercentage", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Boundary size as the percentage of grid size.", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="collisionFilterDataName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("collisionFilterDataName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("HIDDEN", uint64_t(1), true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("HIDDEN", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The filter data (group/groupsMask) name for TurbulenceFS vs PhysX interaction.", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="fieldBoundaryFilterDataName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("fieldBoundaryFilterDataName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("HIDDEN", uint64_t(1), true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("HIDDEN", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The filter data name for TurbulenceFS vs Field Boundaries interaction.", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="fieldSamplerFilterDataName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("fieldSamplerFilterDataName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The filter data name for TurbulenceFS vs other Field Samplers interaction.", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="maxCollidingObjects"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("maxCollidingObjects", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of colliding objects.", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="maxVelocitySources"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("maxVelocitySources", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of velocity source.", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="maxHeatSources"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("maxHeatSources", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of heat source.", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="maxSubstanceSources"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("maxSubstanceSources", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum number of substance source (computed if density enabled).", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="dragCoeff"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("dragCoeff", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Coefficient for deriving drag force from velocity (if equals to zero, direct grid velocity is used).", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="externalVelocity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("externalVelocity", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Adds a single directional velocity to the grid.", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="fieldVelocityMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("fieldVelocityMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "A multiplier for the field velocity.", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="fieldVelocityWeight"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("fieldVelocityWeight", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "The effect of the field velocity on objects. A value of 1 causes objects to only be affected by the grid, a value of 0 allows objects to be controlled by other field samplers.", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="useHeat"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("useHeat", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable whether or not to use heat in the simulation.", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="heatParams"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("heatParams", TYPE_STRUCT, "HeatParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="heatParams.temperatureBasedForceMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("temperatureBasedForceMultiplier", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Multiplier for force induced by heat source.", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="heatParams.ambientTemperature"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("ambientTemperature", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Environment temperature.", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="heatParams.heatForceDirection"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("heatForceDirection", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Direction of the force induced by heat source.", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="heatParams.thermalConductivity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("thermalConductivity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Thermal conductivity. Default value is set for air.", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="useDensity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("useDensity", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable whether or not to use density in the simulation.", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="densityParams"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("densityParams", TYPE_STRUCT, "DensityParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="densityParams.diffusionCoef"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("diffusionCoef", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Diffusion coefficient for density (analog for viscosity in velocity equation.", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="densityParams.densityFieldFade"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("densityFieldFade", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("max", uint64_t(1), true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Each cell in density field are multiplied by (1 - densityFieldFade) every frame.", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="densityParams.densityGridMultiplier"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("densityGridMultiplier", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("min", uint64_t(1), true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("min", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Density grid resolution multiplier.", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="isEnabledOptimizedLOD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("isEnabledOptimizedLOD", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Enable more aggressive LOD.", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="customLOD"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("customLOD", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Force the current LOD to a particular value, range is 0-1:	1.0f is maximum, 0.0f is minimum simulation quality.", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="lodWeights"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("lodWeights", TYPE_STRUCT, "LODWeights", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="lodWeights.maxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("maxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Objects greater than this distance from the player will be culled more aggressively", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="lodWeights.distanceWeight"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("distanceWeight", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Weight given to distance parameter in LOD function", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="lodWeights.bias"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("bias", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "benefit = ((distanceWeight * distanceFactor + bias) * SimulationCost + benefitBias) * benefitWeight", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="lodWeights.benefitBias"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("benefitBias", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "benefit = ((distanceWeight * distanceFactor + bias) * SimulationCost + benefitBias) * benefitWeight", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="lodWeights.benefitWeight"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("benefitWeight", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "benefit = ((distanceWeight * distanceFactor + bias) * SimulationCost + benefitBias) * benefitWeight", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="noiseParams"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("noiseParams", TYPE_STRUCT, "NoiseParams", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="noiseParams.noiseStrength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("noiseStrength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The strength of the noise added to the simulation.", true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="noiseParams.noiseSpacePeriod"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("noiseSpacePeriod", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Noise period in space.", true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="noiseParams.noiseTimePeriod"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("noiseTimePeriod", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Noise time period.", true);
		ParamDefTable[56].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="noiseParams.noiseOctaves"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("noiseOctaves", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of the noise octaves (more octaves give more turbulent noise, but increase computational time).", true);
		ParamDefTable[57].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="dragCoeffForRigidBody"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("dragCoeffForRigidBody", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "It is not true drag coef just mixing coefficient for slip and no-slip boundary condition. If set to zero supposed slip boundary condition on rigid bodies. If set to 1 supposed no-slip boundary condition else mixed (partly slip)", true);
		ParamDefTable[58].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="fluidViscosity"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("fluidViscosity", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Viscosity is the coefficient for velocity diffusion. If 0. there is no diffusion.", true);
		ParamDefTable[59].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="volumeRenderMaterialName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("volumeRenderMaterialName", TYPE_REF, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The optional volume render material name", true);
		ParamDefTable[60].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */


		static const char* const RefVariantVals[] = { "ApexVolumeRenderMaterials" };
		ParamDefTable[60].setRefVariantVals((const char**)RefVariantVals, 1);



	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[36];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(4);
		Children[2] = PDEF_PTR(7);
		Children[3] = PDEF_PTR(10);
		Children[4] = PDEF_PTR(11);
		Children[5] = PDEF_PTR(14);
		Children[6] = PDEF_PTR(15);
		Children[7] = PDEF_PTR(16);
		Children[8] = PDEF_PTR(17);
		Children[9] = PDEF_PTR(18);
		Children[10] = PDEF_PTR(19);
		Children[11] = PDEF_PTR(20);
		Children[12] = PDEF_PTR(21);
		Children[13] = PDEF_PTR(22);
		Children[14] = PDEF_PTR(23);
		Children[15] = PDEF_PTR(24);
		Children[16] = PDEF_PTR(25);
		Children[17] = PDEF_PTR(26);
		Children[18] = PDEF_PTR(27);
		Children[19] = PDEF_PTR(28);
		Children[20] = PDEF_PTR(29);
		Children[21] = PDEF_PTR(30);
		Children[22] = PDEF_PTR(31);
		Children[23] = PDEF_PTR(32);
		Children[24] = PDEF_PTR(33);
		Children[25] = PDEF_PTR(34);
		Children[26] = PDEF_PTR(35);
		Children[27] = PDEF_PTR(40);
		Children[28] = PDEF_PTR(41);
		Children[29] = PDEF_PTR(45);
		Children[30] = PDEF_PTR(46);
		Children[31] = PDEF_PTR(47);
		Children[32] = PDEF_PTR(53);
		Children[33] = PDEF_PTR(58);
		Children[34] = PDEF_PTR(59);
		Children[35] = PDEF_PTR(60);

		ParamDefTable[0].setChildren(Children, 36);
	}

	// SetChildren for: nodeIndex=1, longName="gridXRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(2);
		Children[1] = PDEF_PTR(3);

		ParamDefTable[1].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=4, longName="gridYRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(5);
		Children[1] = PDEF_PTR(6);

		ParamDefTable[4].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=7, longName="gridZRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(8);
		Children[1] = PDEF_PTR(9);

		ParamDefTable[7].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=11, longName="updatesPerFrameRange"
	{
		static Definition* Children[2];
		Children[0] = PDEF_PTR(12);
		Children[1] = PDEF_PTR(13);

		ParamDefTable[11].setChildren(Children, 2);
	}

	// SetChildren for: nodeIndex=35, longName="heatParams"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(36);
		Children[1] = PDEF_PTR(37);
		Children[2] = PDEF_PTR(38);
		Children[3] = PDEF_PTR(39);

		ParamDefTable[35].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=41, longName="densityParams"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(42);
		Children[1] = PDEF_PTR(43);
		Children[2] = PDEF_PTR(44);

		ParamDefTable[41].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=47, longName="lodWeights"
	{
		static Definition* Children[5];
		Children[0] = PDEF_PTR(48);
		Children[1] = PDEF_PTR(49);
		Children[2] = PDEF_PTR(50);
		Children[3] = PDEF_PTR(51);
		Children[4] = PDEF_PTR(52);

		ParamDefTable[47].setChildren(Children, 5);
	}

	// SetChildren for: nodeIndex=53, longName="noiseParams"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(54);
		Children[1] = PDEF_PTR(55);
		Children[2] = PDEF_PTR(56);
		Children[3] = PDEF_PTR(57);

		ParamDefTable[53].setChildren(Children, 4);
	}

	mBuiltFlag = true;

}
void TurbulenceFSAssetParams_1p3::initStrings(void)
{
	collisionFilterDataName.isAllocated = true;
	collisionFilterDataName.buf = NULL;
	fieldBoundaryFilterDataName.isAllocated = true;
	fieldBoundaryFilterDataName.buf = NULL;
	fieldSamplerFilterDataName.isAllocated = true;
	fieldSamplerFilterDataName.buf = NULL;
}

void TurbulenceFSAssetParams_1p3::initDynamicArrays(void)
{
}

void TurbulenceFSAssetParams_1p3::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	gridXRange.min = (const char*)"EGR_16";
	gridXRange.max = (const char*)"EGR_16";
	gridYRange.min = (const char*)"EGR_16";
	gridYRange.max = (const char*)"EGR_16";
	gridZRange.min = (const char*)"EGR_16";
	gridZRange.max = (const char*)"EGR_16";
	gridSizeWorld = physx::PxVec3(init(12, 12, 12));

	updatesPerFrameRange.min = 0.0f;
	updatesPerFrameRange.max = 1.0f;

	angularVelocityMultiplier = float(1);
	angularVelocityClamp = float(1000000);
	linearVelocityMultiplier = float(1);
	linearVelocityClamp = float(1000000);
	velocityFieldFadeTime = float(0);
	velocityFieldFadeDelay = float(2);
	velocityFieldFadeIntensity = float(0.995);
	boundaryFadePercentage = float(0.1);
	boundarySizePercentage = float(1);
	maxCollidingObjects = uint32_t(32);
	maxVelocitySources = uint32_t(8);
	maxHeatSources = uint32_t(8);
	maxSubstanceSources = uint32_t(8);
	dragCoeff = float(0);
	externalVelocity = physx::PxVec3(init(0.0, 0.0, 0.0));
	fieldVelocityMultiplier = float(1);
	fieldVelocityWeight = float(1);
	useHeat = bool(false);
	heatParams.temperatureBasedForceMultiplier = float(0.02);
	heatParams.ambientTemperature = float(0);
	heatParams.heatForceDirection = physx::PxVec3(init(0.0, 1.0, 0.0));
	heatParams.thermalConductivity = float(0.025);
	useDensity = bool(false);
	densityParams.diffusionCoef = float(0);
	densityParams.densityFieldFade = float(0);
	densityParams.densityGridMultiplier = uint32_t(1);
	isEnabledOptimizedLOD = bool(false);
	customLOD = float(1);
	lodWeights.maxDistance = float(100);
	lodWeights.distanceWeight = float(1);
	lodWeights.bias = float(0);
	lodWeights.benefitBias = float(0);
	lodWeights.benefitWeight = float(1);
	noiseParams.noiseStrength = float(0);
	noiseParams.noiseSpacePeriod = physx::PxVec3(init(1.0, 1.0, 1.0));
	noiseParams.noiseTimePeriod = float(1);
	noiseParams.noiseOctaves = uint32_t(1);
	dragCoeffForRigidBody = float(0);
	fluidViscosity = float(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void TurbulenceFSAssetParams_1p3::initReferences(void)
{
	volumeRenderMaterialName = NULL;

}

void TurbulenceFSAssetParams_1p3::freeDynamicArrays(void)
{
}

void TurbulenceFSAssetParams_1p3::freeStrings(void)
{

	if (collisionFilterDataName.isAllocated && collisionFilterDataName.buf)
	{
		mParameterizedTraits->strfree((char*)collisionFilterDataName.buf);
	}

	if (fieldBoundaryFilterDataName.isAllocated && fieldBoundaryFilterDataName.buf)
	{
		mParameterizedTraits->strfree((char*)fieldBoundaryFilterDataName.buf);
	}

	if (fieldSamplerFilterDataName.isAllocated && fieldSamplerFilterDataName.buf)
	{
		mParameterizedTraits->strfree((char*)fieldSamplerFilterDataName.buf);
	}
}

void TurbulenceFSAssetParams_1p3::freeReferences(void)
{
	if (volumeRenderMaterialName)
	{
		volumeRenderMaterialName->destroy();
	}

}

} // namespace parameterized
} // namespace nvidia
