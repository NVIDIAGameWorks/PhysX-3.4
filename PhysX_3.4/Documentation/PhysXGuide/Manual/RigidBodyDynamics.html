<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Rigid Body Dynamics &mdash; NVIDIA PhysX SDK 3.4.2 Documentation</title>
    
    <link rel="stylesheet" href="../_static/nvidia.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NVIDIA PhysX SDK 3.4.2 Documentation" href="../index.html" />
    <link rel="up" title="User&#39;s Guide" href="Index.html" />
    <link rel="next" title="Simulation" href="Simulation.html" />
    <link rel="prev" title="Rigid Body Collision" href="RigidBodyCollision.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Simulation.html" title="Simulation"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="RigidBodyCollision.html" title="Rigid Body Collision"
             accesskey="P">previous</a> |</li>
        <li><a href="../Index.html">NVIDIA PhysX SDK 3.4.2 Documentation</a> &raquo;</li>
          <li><a href="Index.html" accesskey="U">User's Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="rigid-body-dynamics">
<span id="rigidbodydynamics"></span><h1>Rigid Body Dynamics<a class="headerlink" href="#rigid-body-dynamics" title="Permalink to this headline">¶</a></h1>
<p>In this chapter we cover a number of topics that are also important to understand once you are comfortable with setting up a basic rigid body simulation world.</p>
<div class="section" id="velocity">
<h2>Velocity<a class="headerlink" href="#velocity" title="Permalink to this headline">¶</a></h2>
<p>A rigid body's motion is separated into linear and angular velocity components. During simulation, PhysX will modify the velocity of an object in accordance with gravity, other applied forces and torques and as a result of various constraints, such as collisions or joints.</p>
<p>A body's linear and angular velocities can be read using the following methods:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxVec3</span> <span class="n">PxRigidBody</span><span class="o">::</span><span class="n">getLinearVelocity</span><span class="p">();</span>
<span class="n">PxVec3</span> <span class="n">PxRigidBody</span><span class="o">::</span><span class="n">getAngularVelocity</span><span class="p">();</span>
</pre></div>
</div>
<p>A body's linear and angular velocities can be set using the following methods:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxRigidBody</span><span class="o">::</span><span class="n">setLinearVelocity</span><span class="p">(</span><span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">linVel</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">autowake</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">PxRigidBody</span><span class="o">::</span><span class="n">setAngularVelocity</span><span class="p">(</span><span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">angVel</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">autowake</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="mass-properties">
<h2>Mass Properties<a class="headerlink" href="#mass-properties" title="Permalink to this headline">¶</a></h2>
<p>A dynamic actor needs mass properties: the mass, moment of inertia, and the center of mass frame which specifies the position of the actor's center of mass and its principal inertia axes. The easiest way to calculate mass properties is to use the PxRigidBodyExt::updateMassAndInertia() helper function, which will set all three properties based on the actor's shapes and a uniform density value. Variants of this function allow combinations of per-shape densities and manual specification of some mass properties. See the reference for PxRigidBodyExt for more details.</p>
<p>The Wobbly Snowmen in the North Pole Sample illustrate the use of different mass properties.  The snowmen act like roly-poly toys, which are usually just an empty shell with the bottom filled with some heavy material. The low centers of mass cause them to move back to an upright position after they have been tilted. They come in different flavors, depending on how the mass properties are set:</p>
<p>The first is basically massless. There is just a little sphere with a relatively high mass at the bottom of the Actor. This results in a quite rapid movement due to the small resulting moments of inertia. The snowman feels light.</p>
<p>The second uses the mass of the bottom snowball only, resulting in a bigger inertia. Later on, the center of mass is moved to the bottom of the actor. This approximation is by no means physically correct, but the resulting snowman feels a bit more filled.</p>
<p>The third and fourth snowman use shapes to calculate the mass. The difference is that one calculates the moments of inertia first (from the real center of mass) and then the center of mass is moved to the bottom. The other calculates the moments of inertia about the low center of mass that we pass to the calculation routine. Note how much slower the wobbling is for the second case although both have the same mass. This is because the head accounts for much more in the moment of inertia (the distance from the center of mass squared).</p>
<p>The last snowman's mass properties are set up manually. The sample uses rough values for the moment of inertia to create a specific desired behavior. The diagonal tensor has a low value in X, and high values in Y and Z, producing a low resistance to rotation around the X-axis and high resistance around Y and Z. As a consequence, the snowman will wobble back and forth only around the X axis.</p>
<p>If you have a 3x3 inertia matrix (for example, you have real-life inertia tensors for your objects) use the PxDiagonalize() function to obtain principal axes and diagonal inertia tensors to initialize PxRigidDynamic actors.</p>
<p>When manually setting the mass/inertia tensor of bodies, PhysX requires positive values for the mass and each principal axis of inertia. However, it is legal to provide 0s in these values. When provided with a 0 mass or inertia value, PhysX interprets this to mean infinite mass or inertia around that principal axis. This can be used to create bodies that resist all linear motion or that resist all or some angular motion. Examples of the effects that could be achieved using this approach are:</p>
<ul class="simple">
<li>Bodies that behave as if they were kinematic.</li>
<li>Bodies whose translation behaves kinematically but whose rotation is dynamic.</li>
<li>Bodies whose translation is dynamic but whose rotation is kinematic.</li>
<li>Bodies which can only rotate around a specific axis.</li>
</ul>
<p>Some examples of what could be achieved are detailed below. First, let's assume that we are creating a common structure - a windmill. The code to construct the bodies that would be part of the windmill are provided below:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">dyn</span> <span class="o">=</span> <span class="n">physics</span><span class="p">.</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">2.5f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">)));</span>
<span class="n">PxRigidActorExt</span><span class="o">::</span><span class="n">createExclusiveShape</span><span class="p">(</span><span class="o">*</span><span class="n">dyn</span><span class="p">,</span> <span class="n">PxBoxGeometry</span><span class="p">(</span><span class="mf">2.f</span><span class="p">,</span> <span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">),</span> <span class="n">material</span><span class="p">);</span>
<span class="n">PxRigidActorExt</span><span class="o">::</span><span class="n">createExclusiveShape</span><span class="p">(</span><span class="o">*</span><span class="n">dyn</span><span class="p">,</span> <span class="n">PxBoxGeometry</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">2.f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">),</span> <span class="n">material</span><span class="p">);</span>
<span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setActorFlag</span><span class="p">(</span><span class="n">PxActorFlag</span><span class="o">::</span><span class="n">eDISABLE_GRAVITY</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setAngularVelocity</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">,</span> <span class="mf">5.f</span><span class="p">));</span>
<span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setAngularDamping</span><span class="p">(</span><span class="mf">0.f</span><span class="p">);</span>
<span class="n">PxRigidStatic</span><span class="o">*</span> <span class="n">st</span> <span class="o">=</span> <span class="n">mPhysics</span><span class="p">.</span><span class="n">createRigidStatic</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">1.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.f</span><span class="p">)));</span>
<span class="n">PxRigidActorExt</span><span class="o">::</span><span class="n">createExclusiveShape</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">PxBoxGeometry</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">1.5f</span><span class="p">,</span> <span class="mf">0.8f</span><span class="p">),</span> <span class="n">material</span><span class="p">);</span>
<span class="n">scene</span><span class="p">.</span><span class="n">addActor</span><span class="p">(</span><span class="n">dyn</span><span class="p">);</span>
<span class="n">scene</span><span class="p">.</span><span class="n">addActor</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
</pre></div>
</div>
<p>The above code creates a static box frame for the windmill and a cross to represent the blades of the turbine. We turn off gravity and angular damping on the windmill blade and give it an initial angular velocity. As a result, this turbine blade will rotate at a constant angular velocity indefinitely. However, if another object collided with the turbine, our windmill would cease to function correctly because the turbine blade would be knocked out of place. There are several options to make the turbine blade stay in the correct position when other bodies interact with it. One such approach might be to make the turbine have infinite mass and inertia. In this case, any interactions with bodies would not affect the turbine at all:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setMass</span><span class="p">(</span><span class="mf">0.f</span><span class="p">);</span>
<span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setMassSpaceInertiaTensor</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="mf">0.f</span><span class="p">));</span>
</pre></div>
</div>
<p>This example retains the previous behavior of the turbine spinning at a constant angular velocity indefinitely. However, now the body's velocities cannot be affected by any constraints because the body has infinite mass and inertia. If a body collided with the turbine blade, the collision would behave as if the turbine blade was a kinematic body.</p>
<p>Another alternative would be to make the turbine have infinite mass and limit its rotation to just around the body's local z-axis. This would provide the same effect as applying a revolute joint between the turbine and the static windmill frame:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setMass</span><span class="p">(</span><span class="mf">0.f</span><span class="p">);</span>
<span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setMassSpaceInertiaTensor</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">,</span> <span class="mf">10.f</span><span class="p">));</span>
</pre></div>
</div>
<p>In both examples, the body's mass was set to 0, indicating that the body has infinite mass so its linear velocity cannot be changed by any constraints. However, in this example, the body's inertia is configured to permit the body's angular velocity to be affected by constraints around one principal axis or inertia. This provides a similar effect to introducing a revolute joint. The value of the inertia around the z-axis can be increased or decreased to make the turbines more/less resistive to motion.</p>
</div>
<div class="section" id="applying-forces-and-torques">
<h2>Applying Forces and Torques<a class="headerlink" href="#applying-forces-and-torques" title="Permalink to this headline">¶</a></h2>
<p>The most physics-friendly way to interact with a body is to apply a force to it. In classical mechanics, most interactions between bodies are typically solved by using forces. Because of the law:</p>
<blockquote>
<div>f = m*a (force = mass * acceleration)</div></blockquote>
<p>Forces directly control a body's acceleration, but its velocity and position only indirectly. For this reason control by force may be inconvenient if you need immediate response. The advantage of forces is that regardless of what forces you apply to the bodies in the scene, the simulation will be able to keep all the defined constraints (joints and contacts) satisfied. For example gravity works by applying a force to bodies.</p>
<p>Unfortunately applying large forces to articulated bodies at the resonant frequency of a system may lead to ever increasing velocities, and eventually to the failure of the solver to maintain the joint constraints. This is not unlike a real world system, where the joints would ultimately break.</p>
<p>The forces acting on a body are accumulated before each simulation frame, applied to the simulation, and then reset to zero in preparation for the next frame. The relevant methods of PxRigidBody and PxRigidBodyExt are listed below. Please refer to the API reference for more detail:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxRigidBody</span><span class="o">::</span><span class="n">addForce</span><span class="p">(</span><span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">force</span><span class="p">,</span> <span class="n">PxForceMode</span><span class="o">::</span><span class="n">Enum</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">autowake</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">PxRigidBody</span><span class="o">::</span><span class="n">addTorque</span><span class="p">(</span><span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">torque</span><span class="p">,</span> <span class="n">PxForceMode</span><span class="o">::</span><span class="n">Enum</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">autowake</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">PxRigidBodyExt</span><span class="o">::</span><span class="n">addForceAtPos</span><span class="p">(</span><span class="n">PxRigidBody</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">force</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">PxForceMode</span><span class="o">::</span><span class="n">Enum</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wakeup</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">PxRigidBodyExt</span><span class="o">::</span><span class="n">addForceAtLocalPos</span><span class="p">(</span><span class="n">PxRigidBody</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">force</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">PxForceMode</span><span class="o">::</span><span class="n">Enum</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wakeup</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">PxRigidBodyExt</span><span class="o">::</span><span class="n">addLocalForceAtPos</span><span class="p">(</span><span class="n">PxRigidBody</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">force</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">PxForceMode</span><span class="o">::</span><span class="n">Enum</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wakeup</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">PxRigidBodyExt</span><span class="o">::</span><span class="n">addLocalForceAtLocalPos</span><span class="p">(</span><span class="n">PxRigidBody</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">force</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="n">PxForceMode</span><span class="o">::</span><span class="n">Enum</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wakeup</span><span class="p">);</span>
</pre></div>
</div>
<p>The PxForceMode member defaults to PxForceMode::eFORCE to apply simple forces. There are other possibilities. For example PxForceMode::eIMPULSE will apply an impulsive force. PxForceMode::eVELOCITY_CHANGE will do the same, but also ignore the mass of the body, effectively leading to an instantaneous velocity change. See the API documentation of PxForceMode for the other possibilities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The methods in PxRigidBodyExt support only the force modes eFORCE and eIMPULSE.</p>
</div>
<p>There are further extension functions that compute the linear and angular velocity changes that would arise in the next simulation frame if an impulsive force or impulsive torque were to be applied:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxRigidBodyExt</span><span class="o">::</span><span class="n">computeVelocityDeltaFromImpulse</span><span class="p">(</span><span class="k">const</span> <span class="n">PxRigidBody</span><span class="o">&amp;</span> <span class="n">body</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">impulsiveForce</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">impulsiveTorque</span><span class="p">,</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">deltaLinearVelocity</span><span class="p">,</span>
    <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">deltaAngularVelocity</span><span class="p">);</span>
</pre></div>
</div>
<p>A use case for this function might be to predict an updated velocity for a game object so that asset loading may be initiated in advance of the simulation frame if the body is likely to exceed a threshold velocity at the end of the frame.  The impulsive force and torque are simply the force and torque that are to be applied to the body multiplied by the timestep of the simulation frame.  Neglecting the effect of constraint and contact forces, the change in linear and angular velocity that are expected to arise in the next simulation frame are returned in deltaLinearVelocity and deltaAngularVelocity.  The predicted linear velocity can then be computed with body.getLinearVelocity() + deltaLinearVelocity, while the predicted angular velocity can be computed with body.getAngularVelocity() + deltaAngularVelocity.  If required, it is possible to immediately update the velocity of the body using body.setLinearVelocity(body.getLinearVelocity() + deltaLinearVelocity) and body.setAngularVelocity(body.getAngularVelocity() + deltaAngularVelocity).</p>
</div>
<div class="section" id="gravity">
<h2>Gravity<a class="headerlink" href="#gravity" title="Permalink to this headline">¶</a></h2>
<p>Gravity is such a common force in simulations that PhysX makes it particularly simple to apply. For a scene-wide gravity effect, or any other uniform force field, set the PxScene class' gravity vector using PxScene::setGravity().</p>
<p>The parameter is the acceleration due to gravity. In meters and seconds, this works out to have a magnitude of about 9.8 on earth, and should point downwards. The force that will be applied at the center of mass of each body in the scene is this acceleration vector times the actor's mass.</p>
<p>Certain special effects can require that some dynamic actors are not influenced by gravity. To specify this set the flag:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxActor</span><span class="o">::</span><span class="n">setActorFlag</span><span class="p">(</span><span class="n">PxActorFlag</span><span class="o">::</span><span class="n">eDISABLE_GRAVITY</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Be careful when changing gravity (or enabling/disabling it) during the simulation. For performance reasons the change will not wake up sleeping actors automatically. Thus it may be necessary to iterate through all actors and call PxRigidDynamic::wakeUp() manually.</p>
</div>
<p>An alternative to PxActorFlag::eDISABLE_GRAVITY is to use a zero gravity vector for the whole scene, then apply your own gravity force to rigid bodies, each frame. This can be used to create radial gravity fields, as demonstrated in SampleCustomGravity.</p>
</div>
<div class="section" id="friction-and-restitution">
<h2>Friction and Restitution<a class="headerlink" href="#friction-and-restitution" title="Permalink to this headline">¶</a></h2>
<p>All physical objects have at least one material, which defines the friction and restitution properties used to resolve a collision with the objects.</p>
<p>To create a material, call PxPhysics::createMaterial():</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxMaterial</span><span class="o">*</span> <span class="n">mMaterial</span><span class="p">;</span>

<span class="n">mMaterial</span> <span class="o">=</span> <span class="n">mPhysics</span><span class="o">-&gt;</span><span class="n">createMaterial</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.1f</span><span class="p">);</span> <span class="c1">// static friction, dynamic friction,</span>
                                                        <span class="c1">// restitution</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mMaterial</span><span class="p">)</span>
    <span class="n">fatalError</span><span class="p">(</span><span class="s">&quot;createMaterial failed!&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Materials are owned by the PxPhysics object, and can be shared among objects in multiple scenes. The material properties of two objects involved in a collision may be combined in various ways. See the reference documentation for PxMaterial for more details.</p>
<p>PhysX objects whose collision geometry is a triangle mesh or a heightfield (see <a class="reference internal" href="RigidBodyCollision.html#rigidbodycollisionshapes"><em>Shapes</em></a>) can have a material per triangle.</p>
<p>Friction uses the coulomb friction model, which is based around the concepts of 2 coefficients: the static friction coefficient and the dynamic friction coefficient (sometimes called kinetic friction). Friction resists relative lateral motion of two solid surfaces in contact. These two coefficients define a relationship between the normal force exerted by each surface on the other and the amount of friction force that is applied to resist lateral motion. Static friction defines the amount of friction that is applied between surfaces that are not moving lateral to each-other. Dynamic friction defines the amount of friction applied between surfaces that are moving relative to each-other.</p>
<p>The coefficient of restitution of two colliding objects is a fractional value representing the ratio of speeds after and before an impact, taken along the line of impact. A coefficient of restitution of 1 is said to collide elastically, while a coefficient of restitution &lt; 1 is said to be inelastic.</p>
</div>
<div class="section" id="sleeping">
<span id="id1"></span><h2>Sleeping<a class="headerlink" href="#sleeping" title="Permalink to this headline">¶</a></h2>
<p>When an actor does not move for a period of time, it is assumed that it will not move in the future either until some external force acts on it that throws it out of equilibrium. Until then it is no longer simulated in order to save resources. This state is called sleeping. You can query an actor's sleep state with the following method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">isSleeping</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>It is however often more convenient to listen for events that the SDK sends when actors fall asleep or wake up.  To receive the following events, PxActorFlag::eSEND_SLEEP_NOTIFIES must be set for the actor:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxSimulationEventCallback</span><span class="o">::</span><span class="n">onWake</span><span class="p">(</span><span class="n">PxActor</span><span class="o">**</span> <span class="n">actors</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">PxSimulationEventCallback</span><span class="o">::</span><span class="n">onSleep</span><span class="p">(</span><span class="n">PxActor</span><span class="o">**</span> <span class="n">actors</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>See the section <a class="reference internal" href="Simulation.html#callbacks"><em>Callback Sequence</em></a> and the subsection <a class="reference internal" href="#sleep-callbacks"><em>Sleep state change events</em></a> for more information.</p>
<p>An actor goes to sleep when its kinetic energy is below a given threshold for a certain time. Basically, every dynamic rigid actor has a wake counter which gets decremented by the simulation time step when the kinetic energy of the actor is below the specified threshold. However, if the energy is above the threshold after a simulation step, the counter gets reset to a minimum default value and the whole process starts anew. Once the wake counter reaches zero, it does not get decremented any further and the actor is ready to go to sleep. Please note that a zero wake counter does not mean that the actor has to be asleep, it only indicates that it is ready to go to sleep. There are other factors that might keep an actor awake for a while longer.</p>
<p>The energy threshold as well as the minimum amount of time an actor will stay awake can be manipulated using the following methods:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">setSleepThreshold</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">threshold</span><span class="p">);</span>
<span class="n">PxReal</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">getSleepThreshold</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">setWakeCounter</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">wakeCounterValue</span><span class="p">);</span>
<span class="n">PxReal</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">getWakeCounter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For kinematic actors, special sleep rules apply. A kinematic actor is asleep unless a target pose has been set (in which case it will stay awake until the end of the next simulation step where no target pose has been set anymore). As a consequence, it is not allowed to use setWakeCounter() for kinematic actors. The wake counter of a kinematic actor is solely defined based on whether a target pose has been set.</p>
</div>
<p>If a dynamic rigid actor is sleeping, the following state is guaranteed:</p>
<ul class="simple">
<li>The wake counter is zero.</li>
<li>The linear and angular velocity is zero.</li>
<li>There is no force update pending.</li>
</ul>
<p>When an actor gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.</p>
<p>In general, a dynamic rigid actor is guaranteed to be awake if at least one of the following holds:</p>
<ul class="simple">
<li>The wake counter is positive.</li>
<li>The linear or angular velocity is non-zero.</li>
<li>A non-zero force or torque has been applied.</li>
</ul>
<p>As a consequence, the following calls will wake the actor up automatically:</p>
<ul class="simple">
<li>PxRigidDynamic::setWakeCounter(), if the wake counter value is larger than zero.</li>
<li>PxRigidBody::setLinearVelocity(), ::setAngularVelocity(), if the velocity is non-zero.</li>
<li>PxRigidBody::addForce(), ::addTorque(), if the torque is non-zero.</li>
</ul>
<p>In addition, the following calls and events wake an actor up:</p>
<ul class="simple">
<li>PxRigidDynamic::setKinematicTarget() in the case of a kinematic actor (because this also sets the wake counter to a positive value).</li>
<li>PxRigidActor::setGlobalPose(), if the autowake parameter is set to true (default).</li>
<li>Simulation gets disabled for a PxRigidActor by raising PxActorFlag::eDISABLE_SIMULATION.</li>
<li>PxScene::resetFiltering().</li>
<li>PxShape::setSimulationFilterData(), if the subsequent re-filtering causes the type of the shape pair to transition between suppressed, trigger and contact.</li>
<li>Touch with an actor that is awake.</li>
<li>A touching rigid actor gets removed from the scene (this is the default behavior but it can be specified by the user, see note further below).</li>
<li>Contact with a static rigid actor is lost.</li>
<li>Contact with a dynamic rigid actor is lost and this actor is awake in the next simulation step.</li>
<li>The actor gets hit by a two-way interaction particle.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When removing a rigid actor from the scene or a shape from an actor, it is possible to specify whether to wake up the objects that were touching the removed object in the previous simulation step. See the API comments in PxScene::removeActor() and PxRigidActor::detachShape() for details.</p>
</div>
<p>To explicitly wake up a sleeping object, or force an object to sleep, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">wakeUp</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">putToSleep</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is not allowed to use these methods for kinematic actors. The sleep state of a kinematic actor is solely defined based on whether a target pose has been set.</p>
</div>
<p>The API reference documents exactly which methods cause an actor to be woken up.</p>
<div class="section" id="sleep-state-change-events">
<span id="sleep-callbacks"></span><h3>Sleep state change events<a class="headerlink" href="#sleep-state-change-events" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, PhysX provides an event system that reports changes to the sleep state of dynamic rigid bodies during <em>PxScene::fetchResults()</em>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxSimulationEventCallback</span><span class="o">::</span><span class="n">onWake</span><span class="p">(</span><span class="n">PxActor</span><span class="o">**</span> <span class="n">actors</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">PxSimulationEventCallback</span><span class="o">::</span><span class="n">onSleep</span><span class="p">(</span><span class="n">PxActor</span><span class="o">**</span> <span class="n">actors</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>It is important to understand the correct usage of these events, and their limitations:</p>
<ul class="simple">
<li>A body added since the previous <em>fetchResults()</em> or <em>flushSimulation()</em> will always generate an event, even if no sleep state transition occured.</li>
<li>If there have been multiple changes in a body's sleep state since the previous <em>fetchResults()</em> or <em>flushSimulation()</em>, PhysX will report only the most recent.</li>
</ul>
<p>Sometimes it is desirable to detect transitions between awake and asleep, e.g. when keeping track of the number of awake bodies. Suppose a sleeping body <em>B</em> is woken by the application, the counter is incremented, and during the next simulation step <em>B</em> stays awake. Even though <em>B</em>'s sleep state did not change during simulation, it has changed since the previous <em>fetchResults()</em>, and so an <em>onWake()</em> event will be generated for it. If the counter is incremented again in response to this event, its value will be incorrect.</p>
<p>To use sleep state events to detect transitions, a record of the sleep state for objects of interest has to be kept, for example in a hash. When processing an event, this record can be used to check whether there has been a transition.</p>
</div>
</div>
<div class="section" id="kinematic-actors">
<h2>Kinematic Actors<a class="headerlink" href="#kinematic-actors" title="Permalink to this headline">¶</a></h2>
<p>Sometimes controlling an actor using forces or constraints is not sufficiently robust, precise or flexible. For example moving platforms or character controllers often need to manipulate an actor's position or have it exactly follow a specific path. Such a control scheme is provided by kinematic actors.</p>
<p>A kinematic actor is controlled using the PxRigidDynamic::setKinematicTarget() function. Each simulation step PhysX moves the actor to its target position, regardless of external forces, gravity, collision, etc. Thus one must continually call setKinematicTarget(), every time step, for each kinematic actor, to make them move along their desired paths. The movement of a kinematic actor affects dynamic actors with which it collides or to which it is constrained with a joint. The actor will appear to have infinite mass and will push regular dynamic actors out of the way.</p>
<p>To create a kinematic actor, simply create a regular dynamic actor then set its kinematic flag:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidBody</span><span class="o">::</span><span class="n">setRigidBodyFlag</span><span class="p">(</span><span class="n">PxRigidBodyFlag</span><span class="o">::</span><span class="n">eKINEMATIC</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Use the same function to transform a kinematic actor back to a regular dynamic actor. While you do need to provide a mass for the kinematic actor as for all dynamic actors, this mass will not actually be used for anything while the actor is in kinematic mode.</p>
<p>Caveats:</p>
<ul class="simple">
<li>It is important to understand the difference between PxRigidDynamic::setKinematicTarget() and PxRigidActor::setGlobalPose() here. While setGlobalPose() would also move the actor to the desired position, it would not make that actor properly interact with other objects. In particular, with setGlobalPose() the kinematic actor would not push away other dynamic actors in its path, instead it would go right through them. The setGlobalPose() function can still be used though, if one simply wants to teleport a kinematic actor to a new position.</li>
<li>A kinematic actor can push away dynamic objects, but nothing pushes it back. As a result, a kinematic can easily squish a dynamic actor against a static actor, or against another kinematic actor. As a result, the squished dynamic object can deeply penetrate the geometry it has been pushed into.</li>
<li>There is no interaction or collision between kinematic actors and static actors. However, it is possible to request contact information for these cases with the PxSceneDesc::kineKineFilteringMode and PxSceneDesc::staticKineFilteringMode.</li>
</ul>
</div>
<div class="section" id="active-transforms">
<h2>Active Transforms<a class="headerlink" href="#active-transforms" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the active transforms are currently deprecated. See next paragraph about Active Actors for its replacement.</p>
</div>
<p>The active transforms API provides an efficient way to reflect actor transform changes in a PhysX scene to an associated external object such as a render mesh.</p>
<p>When a scene's fetchResults() method is called an array of <em>PxActiveTransform</em> structs is generated, each entry in the array contains a pointer to the actor that moved, its user data and its new transform. Because only actors that have moved will be included in the list this approach is potentially much more efficient than, for example, analyzing each actor in the scene individually.</p>
<p>The example below shows how to use active transforms to update a render object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// update scene</span>
<span class="n">scene</span><span class="p">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="n">scene</span><span class="p">.</span><span class="n">fetchResults</span><span class="p">();</span>

<span class="c1">// retrieve array of actors that moved</span>
<span class="n">PxU32</span> <span class="n">nbActiveTransforms</span><span class="p">;</span>
<span class="n">PxActiveTransform</span><span class="o">*</span> <span class="n">activeTransforms</span> <span class="o">=</span> <span class="n">scene</span><span class="p">.</span><span class="n">getActiveTransforms</span><span class="p">(</span><span class="n">nbActiveTransforms</span><span class="p">);</span>

<span class="c1">// update each render object with the new transform</span>
<span class="k">for</span> <span class="p">(</span><span class="n">PxU32</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbActiveTransforms</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyRenderObject</span><span class="o">*</span> <span class="n">renderObject</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyRenderObject</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">activeTransforms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">userData</span><span class="p">);</span>
    <span class="n">renderObject</span><span class="o">-&gt;</span><span class="n">setTransform</span><span class="p">(</span><span class="n">activeTransforms</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">actor2World</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">PxSceneFlag::eENABLE_ACTIVETRANSFORMS must be set on the scene for the active transforms array to be generated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the target transform for kinematic rigid bodies is set by the user, kinematics can be excluded from the list by setting the flag PxSceneFlag::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS.</p>
</div>
</div>
<div class="section" id="active-actors">
<h2>Active Actors<a class="headerlink" href="#active-actors" title="Permalink to this headline">¶</a></h2>
<p>The active actors API provides an efficient way to reflect actor transform changes in a PhysX scene to an associated external object such as a render mesh.</p>
<p>When a scene's fetchResults() method is called an array of active <em>PxActor</em> is generated. Because only actors that have moved will be included in the list this approach is potentially much more efficient than, for example, analyzing each actor in the scene individually.</p>
<p>The example below shows how to use active actors to update a render object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// update scene</span>
<span class="n">scene</span><span class="p">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="n">scene</span><span class="p">.</span><span class="n">fetchResults</span><span class="p">();</span>

<span class="c1">// retrieve array of actors that moved</span>
<span class="n">PxU32</span> <span class="n">nbActiveActors</span><span class="p">;</span>
<span class="n">PxActor</span><span class="o">**</span> <span class="n">activeActors</span> <span class="o">=</span> <span class="n">scene</span><span class="p">.</span><span class="n">getActiveActors</span><span class="p">(</span><span class="n">nbActiveActors</span><span class="p">);</span>

<span class="c1">// update each render object with the new transform</span>
<span class="k">for</span> <span class="p">(</span><span class="n">PxU32</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbActiveActors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyRenderObject</span><span class="o">*</span> <span class="n">renderObject</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyRenderObject</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">activeActors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">);</span>
    <span class="n">renderObject</span><span class="o">-&gt;</span><span class="n">setTransform</span><span class="p">(</span><span class="n">activeActors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getGlobalPose</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">PxSceneFlag::eENABLE_ACTIVE_ACTORS must be set on the scene for the active actors array to be generated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the target transform for kinematic rigid bodies is set by the user, kinematics can be excluded from the list by setting the flag PxSceneFlag::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS.</p>
</div>
</div>
<div class="section" id="dominance">
<h2>Dominance<a class="headerlink" href="#dominance" title="Permalink to this headline">¶</a></h2>
<p>Dominance is a mechanism to enable dynamic bodies to dominate each-other. Dominance effectively imbues the dominant body in a pair with infinite mass. This is a form of local mass modification within the constraint solver and, as such, can override the mass of one of the bodies in a pair. Similar effects can be achieved through local mass modification in contact modification but dominance has the advantage of being handled automatically within the SDK so does not incur the additional memory and performance overhead of contact modification.</p>
<p>Each actor must be assigned a dominance group ID. This is a 5-bit value in the range [0, 31]. As such, you are restricted to at-most 32 dominance groups. By default, all bodies are placed in dominance group 0. An actor can be assigned to a dominance group using the following method on PxActor:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">setDominanceGroup</span><span class="p">(</span><span class="n">PxDominanceGroup</span> <span class="n">dominanceGroup</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Dominance is defined by 2 real numbers in the following struct:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">PxDominanceGroupPair</span>
<span class="p">{</span>
    <span class="n">PxDominanceGroupPair</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">a</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">b</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">dominance0</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dominance1</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">PxReal</span> <span class="n">dominance0</span><span class="p">;</span>
    <span class="n">PxReal</span> <span class="n">dominance1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>And dominance between two dominance groups can be configured using the following method on PxScene:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">setDominanceGroupPair</span><span class="p">(</span><span class="n">PxDominanceGroup</span> <span class="n">group1</span><span class="p">,</span> <span class="n">PxDominanceGroup</span> <span class="n">group2</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">PxDominanceGroupPair</span><span class="o">&amp;</span> <span class="n">dominance</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The user can define 3 different states for a given PxDominanceGroupPair:
* 1 : 1. This indicates that both bodies have equal dominance. This is the default behavior.
* 1 : 0. This indicates that body B dominates body A.
* 0 : 1. This indicates that body A dominates body B.</p>
<p>Any values other than 0 and 1 are not valid in a PxDominanceGroupPair. Assigning 0 to both sides of the PxDominanceGroupPair is also invalid. These values can be considered to be scales applied to the bodies' respective inverse mass and inverse inertia. A dominance value of 0 would therefore equate to an infinite mass body.</p>
<p>The following example sets two actors, actorA and actorB, into different dominance groups and configures the dominance group to make actorA dominate actorB:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">actorA</span> <span class="o">=</span> <span class="n">mPhysics</span><span class="o">-&gt;</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxIdentity</span><span class="p">));</span>
<span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">actorB</span> <span class="o">=</span> <span class="n">mPhysics</span><span class="o">-&gt;</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxIdentity</span><span class="p">));</span>

<span class="n">actorA</span><span class="o">-&gt;</span><span class="n">setDominanceGroup</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">actorB</span><span class="o">-&gt;</span><span class="n">setDominanceGroup</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="n">mScene</span><span class="o">-&gt;</span><span class="n">setDominanceGroupPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">PxDominanceGroupPair</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">1.f</span><span class="p">));</span>
</pre></div>
</div>
<p>Dominance values will not affect joints. Local mass modification on joints must be performed using the following methods on PxJoint:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">setInvMassScale0</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">invMassScale</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">setInvMassScale1</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">invMassScale</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">setInvInertiaScale0</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">invInertiaScale</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">setInvInertiaScale1</span><span class="p">(</span><span class="n">PxReal</span> <span class="n">invInertiaScale</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>As previously mentioned, dominance does not permit values other than 0 or 1 and any dominance values are applied uniformly to both the inverse mass and inverse inertia. Joints and contacts through contact modification permit defining separate inverse mass and inverse inertia scales, which accept any values within the range [0, PX_MAX_REAL] so can be used to achieve a wider range of effects than dominance can.</p>
<p>Dominance can produce some very peculiar results if misused. For example, given bodies A, B and C configured in the following way:</p>
<ul class="simple">
<li>Body A dominates body B</li>
<li>Body B dominance body C</li>
<li>Body C dominates body A</li>
</ul>
<p>In this situation, body A cannot push body C directly. However, it can push body C if it pushes body B into body C.</p>
</div>
<div class="section" id="solver-iterations">
<h2>Solver Iterations<a class="headerlink" href="#solver-iterations" title="Permalink to this headline">¶</a></h2>
<p>When the motion of a rigid body is constrained either by contacts or joints, the constraint solver comes into play. The solver satisfies the constraints on the bodies by iterating over all the constraints restricting the motion of the body a certain number of times. The more iterations, the more accurate the results become. The solver iteration count defaults to 4 position iterations and 1 velocity iteration. Those counts may be set individually for each body using the following function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">PxRigidDynamic</span><span class="o">::</span><span class="n">setSolverIterationCounts</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">minPositionIters</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">minVelocityIters</span><span class="p">);</span>
</pre></div>
</div>
<p>Typically it is only necessary to significantly increase these values for objects with lots of joints and a small tolerance for joint error. If you find a need to use a setting higher than 30, you may wish to reconsider the configuration of your simulation.</p>
<p>The solver groups contacts into friction patches; friction patches are groups of contacts which share the same materials and have similar contact normals. However, the solver permits a maximum of 32 friction patches per contact manager (pair of shapes). If more than 32 friction patches are produced, which may be due to very complex collision geometry or very large contact offsets, the solver will ignore the remaining friction patches. A warning will be issues in checked/debug builds when this happens.</p>
</div>
<div class="section" id="immediate-mode">
<h2>Immediate Mode<a class="headerlink" href="#immediate-mode" title="Permalink to this headline">¶</a></h2>
<p>In addition to simulation using a PxScene, PhysX offers a low-level simulation API called &quot;immediate mode&quot;. This provides an API to access the low-level contact generation and constraint solver. This approach currently supports only CPU rigid bodies and does not support articulations, clothing or particles.</p>
<p>The immediate mode API is defined in PxImmediateMode.h and there is a Snippet demonstrating its usage in &quot;SnippetImmediateMode&quot;.</p>
<p>The API provides a function to perform contact generation:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">bool</span> <span class="nf">PxGenerateContacts</span><span class="p">(</span><span class="k">const</span> <span class="n">PxGeometry</span><span class="o">*</span> <span class="n">geom0</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxGeometry</span><span class="o">*</span> <span class="n">geom1</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxTransform</span><span class="o">*</span> <span class="n">pose0</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxTransform</span><span class="o">*</span> <span class="n">pose1</span><span class="p">,</span> <span class="n">PxCache</span><span class="o">*</span> <span class="n">contactCache</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbPairs</span><span class="p">,</span> <span class="n">PxContactRecorder</span><span class="o">&amp;</span> <span class="n">contactRecorder</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">PxReal</span> <span class="n">contactDistance</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxReal</span> <span class="n">meshContactMargin</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxReal</span> <span class="n">toleranceLength</span><span class="p">,</span> <span class="n">PxCacheAllocator</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">);</span>
</pre></div>
</div>
<p>This function takes a set of pairs of PxGeometry objects located at specific poses and performs collision detection between the pairs. If the pair of geometries collide, contacts are generated, which are reported to contactRecorder. In addition, information may be cached in contactCache to accelerate future queries between these pairs of geometries. Any memory required for this cached information will be allocated using &quot;allocator&quot;.</p>
<p>In addition, the immediate mode provides APIs for the constraint solver. These include functions to create bodies used by  the solver:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">void</span> <span class="nf">PxConstructSolverBodies</span><span class="p">(</span><span class="k">const</span> <span class="n">PxRigidBodyData</span><span class="o">*</span> <span class="n">inRigidData</span><span class="p">,</span> <span class="n">PxSolverBodyData</span><span class="o">*</span> <span class="n">outSolverBodyData</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbBodies</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">gravity</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxReal</span> <span class="n">dt</span><span class="p">);</span>

<span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">void</span> <span class="nf">PxConstructStaticSolverBody</span><span class="p">(</span><span class="k">const</span> <span class="n">PxTransform</span><span class="o">&amp;</span> <span class="n">globalPose</span><span class="p">,</span><span class="n">PxSolverBodyData</span><span class="o">&amp;</span> <span class="n">solverBodyData</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition to constructing the bodies, PxConstraintSolverBodies also integrates the provided gravitational acceleration into the bodies velocities.</p>
<p>The following function is optional and is used to batch constraints:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="n">PxU32</span> <span class="nf">PxBatchConstraints</span><span class="p">(</span><span class="n">PxSolverConstraintDesc</span><span class="o">*</span> <span class="n">solverConstraintDescs</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbConstraints</span><span class="p">,</span> <span class="n">PxSolverBody</span><span class="o">*</span> <span class="n">solverBodies</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">nbBodies</span><span class="p">,</span> <span class="n">PxConstraintBatchHeader</span><span class="o">*</span> <span class="n">outBatchHeaders</span><span class="p">,</span>
        <span class="n">PxSolverConstraintDesc</span><span class="o">*</span> <span class="n">outOrderedConstraintDescs</span><span class="p">);</span>
</pre></div>
</div>
<p>Batching constraints reorders the provided constraints and produces batchHeaders, which can be used by the solver to accelerate constraint solving by grouping together independent constraints and solving them in parallel using multiple lanes in SIMD registers. This process is entirely optional and can bypassed if not desired. Note that this will change the order in which constraints are processed, which can change the outcome of the solver.</p>
<p>The following methods is provided to create contact constraints:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">bool</span> <span class="nf">PxCreateContactConstraints</span><span class="p">(</span><span class="n">PxConstraintBatchHeader</span><span class="o">*</span> <span class="n">batchHeader</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbHeaders</span><span class="p">,</span> <span class="n">PxSolverContactDesc</span><span class="o">*</span> <span class="n">contactDescs</span><span class="p">,</span>
        <span class="n">PxConstraintAllocator</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">invDt</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">bounceThreshold</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">frictionOffsetThreshold</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">correlationDistance</span><span class="p">);</span>
</pre></div>
</div>
<p>This method can be provided with the contacts produced by PxGenerateContacts or by contacts produced by application-specific contact generation approaches.</p>
<p>The following methods are provided to create joint constraints:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">bool</span> <span class="nf">PxCreateJointConstraints</span><span class="p">(</span><span class="n">PxConstraintBatchHeader</span><span class="o">*</span> <span class="n">batchHeader</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbHeaders</span><span class="p">,</span> <span class="n">PxSolverConstraintPrepDesc</span><span class="o">*</span> <span class="n">jointDescs</span><span class="p">,</span> <span class="n">PxConstraintAllocator</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">dt</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">invDt</span><span class="p">);</span>

<span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">bool</span> <span class="nf">PxCreateJointConstraintsWithShaders</span><span class="p">(</span><span class="n">PxConstraintBatchHeader</span><span class="o">*</span> <span class="n">batchHeader</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbBatchHeaders</span><span class="p">,</span> <span class="n">PxConstraint</span><span class="o">**</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">PxSolverConstraintPrepDesc</span><span class="o">*</span> <span class="n">jointDescs</span><span class="p">,</span> <span class="n">PxConstraintAllocator</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">dt</span><span class="p">,</span> <span class="n">PxReal</span> <span class="n">invDt</span><span class="p">);</span>
</pre></div>
</div>
<p>The methods provide a mechanism for the application to define joint rows or for the application to make use of PhysX PxConstraint objects, which create the constraint rows.</p>
<p>The following method solves the constraints:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PX_C_EXPORT</span> <span class="n">PX_PHYSX_CORE_API</span> <span class="kt">void</span> <span class="nf">PxSolveConstraints</span><span class="p">(</span><span class="n">PxConstraintBatchHeader</span><span class="o">*</span> <span class="n">batchHeaders</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbBatchHeaders</span><span class="p">,</span> <span class="n">PxSolverConstraintDesc</span><span class="o">*</span> <span class="n">solverConstraintDescs</span><span class="p">,</span> <span class="n">PxSolverBody</span><span class="o">*</span> <span class="n">solverBodies</span><span class="p">,</span>
        <span class="n">PxVec3</span><span class="o">*</span> <span class="n">linearMotionVelocity</span><span class="p">,</span> <span class="n">PxVec3</span><span class="o">*</span> <span class="n">angularMotionVelocity</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbSolverBodies</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbPositionIterations</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbVelocityIterations</span><span class="p">);</span>
</pre></div>
</div>
<p>This method performs all required position and velocity iterations and updates the objects' delta velocities and motion velocities, which are stored in PxSolverBody and linear/angularMotionVelocity respectively.</p>
<p>The following method is provided to integrate the bodies' final poses and update the bodies' velocities to reflect the motion produced by the constraint solver.</p>
<p>An example of how the immediate mode can be used is provided in SnippetImmediateMode.</p>
</div>
<div class="section" id="enhanced-determinism">
<h2>Enhanced Determinism<a class="headerlink" href="#enhanced-determinism" title="Permalink to this headline">¶</a></h2>
<p>PhysX provides limited deterministic simulation. Specifically, the results of the simulation will be identical between runs if simulating the exact same scene (same actors inserted in the same order) using the same time-stepping scheme and same PhysX release running on the same platform. The simulation behavior is not influenced by the number of worker threads that are used.</p>
<p>However, the results of the simulation can change if actors are inserted in a different order. In addition, the overall behavior of the simulation can change if additional actors are added or if some actors are removed from the scene. This means that the simulation of a particular collection of actors can change depending on whether other actors are present in the scene or not, irrespective of whether these actors actually interact with the collection of actors. This behavioral property is usually tolerable but there are circumstances in which it is not acceptable.</p>
<p>To overcome this issue, PhysX provides a flag: PxSceneFlag::eENABLE_ENHANCED_DETERMINISM, which provides additional levels of determinism. Specifically, provided the application inserts the actors in a deterministic order, with this flag raised, the simulation of an island will be identical regardless of any other islands in the scene. However, this mode sacrifices some performance to ensure this additional determinism.</p>
</div>
<div class="section" id="axis-locking">
<h2>Axis locking<a class="headerlink" href="#axis-locking" title="Permalink to this headline">¶</a></h2>
<p>It is possible to restrict motion along or around specific world-space axes in PhysX using PxRigidDynamicLockFlag. For example, the below code snippet demonstrates how to restrict a PxRigidDynamic to two dimensional simulation. In this case, we permit the PxRigidDynamic to rotate only around the Z-axis and to translate only along the X- and Y- axes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">dyn</span> <span class="o">=</span> <span class="n">physics</span><span class="p">.</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">2.5f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">)));</span>

<span class="p">...</span>

<span class="c1">//Lock the motion</span>
<span class="n">dyn</span><span class="o">-&gt;</span><span class="n">setRigidDynamicLockFlags</span><span class="p">(</span><span class="n">PxRigidDynamicLockFlag</span><span class="o">::</span><span class="n">eLOCK_LINEAR_Z</span> <span class="o">|</span> <span class="n">PxRigidDynamicLockFlag</span><span class="o">::</span><span class="n">eLOCK_ANGULAR_X</span> <span class="o">|</span> <span class="n">PxRigidDynamicLockFlag</span><span class="o">::</span><span class="n">eLOCK_ANGULAR_Y</span><span class="p">);</span>
</pre></div>
</div>
<p>It is legal to restrict movement or rotation around any combination of the 6 degrees of freedom.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../Index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Rigid Body Dynamics</a><ul>
<li><a class="reference internal" href="#velocity">Velocity</a></li>
<li><a class="reference internal" href="#mass-properties">Mass Properties</a></li>
<li><a class="reference internal" href="#applying-forces-and-torques">Applying Forces and Torques</a></li>
<li><a class="reference internal" href="#gravity">Gravity</a></li>
<li><a class="reference internal" href="#friction-and-restitution">Friction and Restitution</a></li>
<li><a class="reference internal" href="#sleeping">Sleeping</a><ul>
<li><a class="reference internal" href="#sleep-state-change-events">Sleep state change events</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kinematic-actors">Kinematic Actors</a></li>
<li><a class="reference internal" href="#active-transforms">Active Transforms</a></li>
<li><a class="reference internal" href="#active-actors">Active Actors</a></li>
<li><a class="reference internal" href="#dominance">Dominance</a></li>
<li><a class="reference internal" href="#solver-iterations">Solver Iterations</a></li>
<li><a class="reference internal" href="#immediate-mode">Immediate Mode</a></li>
<li><a class="reference internal" href="#enhanced-determinism">Enhanced Determinism</a></li>
<li><a class="reference internal" href="#axis-locking">Axis locking</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="RigidBodyCollision.html"
                        title="previous chapter">Rigid Body Collision</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Simulation.html"
                        title="next chapter">Simulation</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Simulation.html" title="Simulation"
             >next</a></li>
        <li class="right" >
          <a href="RigidBodyCollision.html" title="Rigid Body Collision"
             >previous</a> |</li>
        <li><a href="../Index.html">NVIDIA PhysX SDK 3.4.2 Documentation</a> &raquo;</li>
          <li><a href="Index.html" >User's Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved.
    </div>
  </body>
</html>