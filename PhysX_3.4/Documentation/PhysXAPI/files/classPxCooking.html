<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxCooking Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxCooking Class Reference<br>
<small>
[<a class="el" href="group__cooking.html">Cooking</a>]</small>
</h1><!-- doxytag: class="PxCooking" --><code>#include &lt;<a class="el" href="PxCooking_8h-source.html">PxCooking.h</a>&gt;</code>
<p>

<p>
<a href="classPxCooking-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#cf1f0cfa4c76ccbe42e84af17a90fb3e">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes this instance of the interface.  <a href="#cf1f0cfa4c76ccbe42e84af17a90fb3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321">setParams</a> (const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;params)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets cooking parameters.  <a href="#febe112057bd03660dd78dee384d5321"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#83607708fd1cb2f58a3d758a558f5b28">getParams</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets cooking parameters.  <a href="#83607708fd1cb2f58a3d758a558f5b28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#82e0864b92d51d409f3134cc8f740102">platformMismatch</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks endianness is the same between cooking &amp; target platforms.  <a href="#82e0864b92d51d409f3134cc8f740102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#29bea4d23794e1521a0a6cbfa8e62464">cookTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a triangle mesh. The results are written to the stream.  <a href="#29bea4d23794e1521a0a6cbfa8e62464"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#227e676ba5b15b9cf292fd457427b13b">createTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks and creates a triangle mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <a href="#227e676ba5b15b9cf292fd457427b13b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#fca9fe3e3bb8b4943d35475f80f37d2e">validateTriangleMesh</a> (const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;desc) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  <a href="#fca9fe3e3bb8b4943d35475f80f37d2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1">cookConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a convex mesh. The results are written to the stream.  <a href="#de8e845a8a4253292aed0ef93177ffa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#0a70f14b0fd0f449ea145dcd27b0c2f8">createConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks and creates a convex mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <a href="#0a70f14b0fd0f449ea145dcd27b0c2f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#ea8a3c270cc6db602ad250c82c1225bc">validateConvexMesh</a> (const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;desc) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  <a href="#ea8a3c270cc6db602ad250c82c1225bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#75c77a6b39563de7b2d3736e0aaac85b">computeHullPolygons</a> (const <a class="el" href="classPxSimpleTriangleMesh.html">PxSimpleTriangleMesh</a> &amp;mesh, <a class="el" href="classPxAllocatorCallback.html">PxAllocatorCallback</a> &amp;inCallback, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbVerts, <a class="el" href="classPxVec3.html">PxVec3</a> *&amp;vertices, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbIndices, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&amp;indices, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbPolygons, <a class="el" href="structPxHullPolygon.html">PxHullPolygon</a> *&amp;hullPolygons) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles.  <a href="#75c77a6b39563de7b2d3736e0aaac85b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#bf4f0fe5c9a709cde84338c5bdf7cde4">cookHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a heightfield. The results are written to the stream.  <a href="#bf4f0fe5c9a709cde84338c5bdf7cde4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#0a3d0ec6145be91dd6707535724d8ffb">createHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <a href="#0a3d0ec6145be91dd6707535724d8ffb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCooking.html#22a1e6a4a68af0bb0f6568bb59108938">~PxCooking</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="22a1e6a4a68af0bb0f6568bb59108938"></a><!-- doxytag: member="PxCooking::~PxCooking" ref="22a1e6a4a68af0bb0f6568bb59108938" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCooking::~PxCooking           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="75c77a6b39563de7b2d3736e0aaac85b"></a><!-- doxytag: member="PxCooking::computeHullPolygons" ref="75c77a6b39563de7b2d3736e0aaac85b" args="(const PxSimpleTriangleMesh &amp;mesh, PxAllocatorCallback &amp;inCallback, PxU32 &amp;nbVerts, PxVec3 *&amp;vertices, PxU32 &amp;nbIndices, PxU32 *&amp;indices, PxU32 &amp;nbPolygons, PxHullPolygon *&amp;hullPolygons) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::computeHullPolygons           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxSimpleTriangleMesh.html">PxSimpleTriangleMesh</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxAllocatorCallback.html">PxAllocatorCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHullPolygon.html">PxHullPolygon</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>hullPolygons</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles. 
<p>
Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. The output vertices, indices and polygons must be used to construct a hull.<p>
The provided <a class="el" href="classPxAllocatorCallback.html" title="Abstract base class for an application defined memory allocator that can be used...">PxAllocatorCallback</a> does allocate the out array's. It is the user responsibility to deallocated those array's.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mesh</em>&nbsp;</td><td>Simple triangle mesh containing vertices and triangles used to compute polygons. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inCallback</em>&nbsp;</td><td>Memory allocator for out array allocations. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbVerts</em>&nbsp;</td><td>Number of vertices used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vertices</em>&nbsp;</td><td>Vertices array used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbIndices</em>&nbsp;</td><td>Number of indices used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>indices</em>&nbsp;</td><td>Indices array used by polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbPolygons</em>&nbsp;</td><td>Number of created polygons. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hullPolygons</em>&nbsp;</td><td>Polygons array. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="group__cooking.html#g36d3375ae49e62c3842c3fbe0c620651" title="collection of set bits defined in PxConvexFlag.">PxConvexFlags</a> <a class="el" href="classPxConvexMeshDesc.html" title="Descriptor class for PxConvexMesh.">PxConvexMeshDesc</a> <a class="el" href="classPxSimpleTriangleMesh.html" title="A structure describing a triangle mesh.">PxSimpleTriangleMesh</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="de8e845a8a4253292aed0ef93177ffa1"></a><!-- doxytag: member="PxCooking::cookConvexMesh" ref="de8e845a8a4253292aed0ef93177ffa1" args="(const PxConvexMeshDesc &amp;desc, PxOutputStream &amp;stream, PxConvexMeshCookingResult::Enum *condition=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookConvexMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a convex mesh. The results are written to the stream. 
<p>
To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.<p>
<a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
Example<p>
<div class="fragment"><pre class="fragment"><span class="comment">//TODO: Add Code Snippet Here</span>
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255. <p>
If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>condition</em>&nbsp;</td><td>Result from convex mesh cooking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf4f0fe5c9a709cde84338c5bdf7cde4"></a><!-- doxytag: member="PxCooking::cookHeightField" ref="bf4f0fe5c9a709cde84338c5bdf7cde4" args="(const PxHeightFieldDesc &amp;desc, PxOutputStream &amp;stream) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookHeightField           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a heightfield. The results are written to the stream. 
<p>
To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.<p>
<a class="el" href="classPxCooking.html#bf4f0fe5c9a709cde84338c5bdf7cde4" title="Cooks a heightfield. The results are written to the stream.">cookHeightField()</a> allows a heightfield description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#1806546c22306e8d44b7ff7719fbcc99" title="Creates a heightfield object from previously cooked stream.">PxPhysics.createHeightField()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="29bea4d23794e1521a0a6cbfa8e62464"></a><!-- doxytag: member="PxCooking::cookTriangleMesh" ref="29bea4d23794e1521a0a6cbfa8e62464" args="(const PxTriangleMeshDesc &amp;desc, PxOutputStream &amp;stream, PxTriangleMeshCookingResult::Enum *condition=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::cookTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxOutputStream.html">PxOutputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a triangle mesh. The results are written to the stream. 
<p>
To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.<p>
<a class="el" href="classPxCooking.html#29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
Example<p>
<div class="fragment"><pre class="fragment"><span class="comment">//TODO: Add Code Snippet Here</span>
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>condition</em>&nbsp;</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a70f14b0fd0f449ea145dcd27b0c2f8"></a><!-- doxytag: member="PxCooking::createConvexMesh" ref="0a70f14b0fd0f449ea145dcd27b0c2f8" args="(const PxConvexMeshDesc &amp;desc, PxPhysicsInsertionCallback &amp;insertionCallback, PxConvexMeshCookingResult::Enum *condition=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a>* PxCooking::createConvexMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insertionCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxConvexMeshCookingResult.html#c1c7b1cbfc80b0af00bec95faf1ebf42">PxConvexMeshCookingResult::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks and creates a convex mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method does the same as cookConvexMesh, but the produced convex mesh is not stored into a stream but is directly inserted in <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. Use this method if you are unable to cook offline.<p>
<a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#7a4588fd79b87766cb81fae3ddd4f074" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertionCallback</em>&nbsp;</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>condition</em>&nbsp;</td><td>Result from convex mesh cooking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> pointer on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a3d0ec6145be91dd6707535724d8ffb"></a><!-- doxytag: member="PxCooking::createHeightField" ref="0a3d0ec6145be91dd6707535724d8ffb" args="(const PxHeightFieldDesc &amp;desc, PxPhysicsInsertionCallback &amp;insertionCallback) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a>* PxCooking::createHeightField           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insertionCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertionCallback</em>&nbsp;</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> pointer on success</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="227e676ba5b15b9cf292fd457427b13b"></a><!-- doxytag: member="PxCooking::createTriangleMesh" ref="227e676ba5b15b9cf292fd457427b13b" args="(const PxTriangleMeshDesc &amp;desc, PxPhysicsInsertionCallback &amp;insertionCallback, PxTriangleMeshCookingResult::Enum *condition=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a>* PxCooking::createTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>insertionCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxTriangleMeshCookingResult.html#be8e2312c47cc522a546c34ea337fb64">PxTriangleMeshCookingResult::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks and creates a triangle mesh and inserts it into <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> can be obtained through <a class="el" href="classPxPhysics.html#7a4588fd79b87766cb81fae3ddd4f074" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>insertionCallback</em>&nbsp;</td><td>The insertion interface from <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>condition</em>&nbsp;</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> pointer on success.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classPxPhysicsInsertionCallback.html" title="Callback interface that permits PxCooking to insert a TriangleMesh, HeightfieldMesh...">PxPhysicsInsertionCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="83607708fd1cb2f58a3d758a558f5b28"></a><!-- doxytag: member="PxCooking::getParams" ref="83607708fd1cb2f58a3d758a558f5b28" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structPxCookingParams.html">PxCookingParams</a>&amp; PxCooking::getParams           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets cooking parameters. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current cooking parameters.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxCookingParams.html" title="Structure describing parameters affecting mesh cooking.">PxCookingParams</a> <a class="el" href="classPxCooking.html#febe112057bd03660dd78dee384d5321" title="Sets cooking parameters.">setParams()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="82e0864b92d51d409f3134cc8f740102"></a><!-- doxytag: member="PxCooking::platformMismatch" ref="82e0864b92d51d409f3134cc8f740102" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::platformMismatch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks endianness is the same between cooking &amp; target platforms. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if there is and endian mismatch. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf1f0cfa4c76ccbe42e84af17a90fb3e"></a><!-- doxytag: member="PxCooking::release" ref="cf1f0cfa4c76ccbe42e84af17a90fb3e" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCooking::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes this instance of the interface. 
<p>
This function should be called to cleanly shut down the Cooking library before application exit.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is required to be called to release foundation usage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="febe112057bd03660dd78dee384d5321"></a><!-- doxytag: member="PxCooking::setParams" ref="febe112057bd03660dd78dee384d5321" args="(const PxCookingParams &amp;params)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxCooking::setParams           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxCookingParams.html">PxCookingParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>params</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets cooking parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>Cooking parameters</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#83607708fd1cb2f58a3d758a558f5b28" title="Gets cooking parameters.">getParams()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea8a3c270cc6db602ad250c82c1225bc"></a><!-- doxytag: member="PxCooking::validateConvexMesh" ref="ea8a3c270cc6db602ad250c82c1225bc" args="(const PxConvexMeshDesc &amp;desc) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::validateConvexMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshDesc.html">PxConvexMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Verifies if the convex mesh is valid. Prints an error message for each inconsistency found. 
<p>
The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function should be used if <a class="el" href="structPxConvexFlag.html#4b7bd21fa96c72b320a39e880208b4b610a876ecefb45e1c7dbaec2afed5c3ad" title="Disables the convex mesh validation to speed-up hull creation. Please use separate...">PxConvexFlag::eDISABLE_MESH_VALIDATION</a> is planned to be used in release builds.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#de8e845a8a4253292aed0ef93177ffa1" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fca9fe3e3bb8b4943d35475f80f37d2e"></a><!-- doxytag: member="PxCooking::validateTriangleMesh" ref="fca9fe3e3bb8b4943d35475f80f37d2e" args="(const PxTriangleMeshDesc &amp;desc) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxCooking::validateTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshDesc.html">PxTriangleMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found. 
<p>
The following conditions are true for a valid triangle mesh: 1. There are no duplicate vertices (within specified vertexWeldTolerance. See <a class="el" href="structPxCookingParams.html#19bb7e28765df5c8ec1a86a45004c7b6" title="Mesh weld tolerance. If mesh welding is enabled, this controls the distance at which...">PxCookingParams::meshWeldTolerance</a>) 2. There are no large triangles (within specified <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a>.)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#29bea4d23794e1521a0a6cbfa8e62464" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCooking_8h-source.html">PxCooking.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
