<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: Physics</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Physics</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxActorFlag.html">PxActorFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags which control the behavior of an actor.  <a href="structPxActorFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxActorType.html">PxActorType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies each type of actor.  <a href="structPxActorType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html">PxActor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> is the base class for the main simulation objects in the physics SDK.  <a href="classPxActor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html">PxAggregate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to aggregate actors into a single broad-phase entry.  <a href="classPxAggregate.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulationDriveCache.html">PxArticulationDriveCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Articulation drive cache.  <a href="classPxArticulationDriveCache.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html">PxArticulation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a tree structure of bodies connected by joints that is treated as a unit by the dynamics solver  <a href="classPxArticulation.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxArticulationJointDriveType.html">PxArticulationJointDriveType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of joint drive to use for the articulation joint.  <a href="structPxArticulationJointDriveType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulationJoint.html">PxArticulationJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a joint between two links in an articulation.  <a href="classPxArticulationJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulationLink.html">PxArticulationLink</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a component of an articulation that represents a rigid body  <a href="classPxArticulationLink.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBatchQueryStatus.html">PxBatchQueryStatus</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Batched query status.  <a href="structPxBatchQueryStatus.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult&lt; HitType &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic struct for receiving results of single query in a batch. Gets templated on hit type <a class="el" href="structPxRaycastHit.html" title="Stores results of raycast queries.">PxRaycastHit</a>, <a class="el" href="structPxSweepHit.html" title="Stores results of sweep queries.">PxSweepHit</a> or <a class="el" href="structPxOverlapHit.html" title="Stores results of overlap queries.">PxOverlapHit</a>.  <a href="structPxBatchQueryResult.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBatchQueryMemory.html">PxBatchQueryMemory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct for <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> memory pointers.  <a href="structPxBatchQueryMemory.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQueryDesc.html">PxBatchQueryDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor class for <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a>.  <a href="classPxBatchQueryDesc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBroadPhaseType.html">PxBroadPhaseType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broad phase algorithm used in the simulation.  <a href="structPxBroadPhaseType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broad-phase callback to receive broad-phase related events.  <a href="classPxBroadPhaseCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBroadPhaseRegion.html">PxBroadPhaseRegion</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Region of interest" for the broad-phase.  <a href="structPxBroadPhaseRegion.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBroadPhaseRegionInfo.html">PxBroadPhaseRegionInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information &amp; stats structure for a region.  <a href="structPxBroadPhaseRegionInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxBroadPhaseCaps.html">PxBroadPhaseCaps</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Caps class for broad phase.  <a href="structPxBroadPhaseCaps.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintFlag.html">PxConstraintFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a table of function pointers for a constraint  <a href="structPxConstraintFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintShaderTable.html">PxConstraintShaderTable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraint.html">PxConstraint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A plugin class for implementing constraints.  <a href="classPxConstraint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPx1DConstraintFlag.html">Px1DConstraintFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constraint row flags  <a href="structPx1DConstraintFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintSolveHint.html">PxConstraintSolveHint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constraint type hints which the solver uses to optimize constraint handling  <a href="structPxConstraintSolveHint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPx1DConstraint.html">Px1DConstraint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constraint.  <a href="structPx1DConstraint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintVisualizationFlag.html">PxConstraintVisualizationFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags for determining which components of the constraint should be visualized.  <a href="structPxConstraintVisualizationFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintInvMassScale.html">PxConstraintInvMassScale</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintVisualizer.html">PxConstraintVisualizer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxPvdUpdateType.html">PxPvdUpdateType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html">PxConstraintConnector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class connects a custom constraint to the SDK.  <a href="classPxConstraintConnector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxContactSet.html">PxContactSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An array of contact points, as passed to contact modification.  <a href="classPxContactSet.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxContactModifyPair.html">PxContactModifyPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An array of instances of this class is passed to <a class="el" href="classPxContactModifyCallback.html#383f0448886bf352215c886b3066f790" title="Passes modifiable arrays of contacts to the application.">PxContactModifyCallback::onContactModify()</a>.  <a href="classPxContactModifyPair.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An interface class that the user can implement in order to modify contact constraints.  <a href="classPxContactModifyCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An interface class that the user can implement in order to modify CCD contact constraints.  <a href="classPxCCDContactModifyCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxDeletionEventFlag.html">PxDeletionEventFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags specifying deletion event types.  <a href="structPxDeletionEventFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDeletionListener.html">PxDeletionListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">interface to get notification on object deletion  <a href="classPxDeletionListener.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxPairFlag.html">PxPairFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags describing the actions to take for a collision pair.  <a href="structPxPairFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFilterFlag.html">PxFilterFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags describing the filter actions to take for a collision pair.  <a href="structPxFilterFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFilterData.html">PxFilterData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> is user-definable data which gets passed into the collision filtering shader and/or callback.  <a href="structPxFilterData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFilterObjectType.html">PxFilterObjectType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies each type of filter object.  <a href="structPxFilterObjectType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFilterObjectFlag.html">PxFilterObjectFlag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter callback to specify handling of collision pairs.  <a href="classPxSimulationFilterCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFilterInfo.html">PxFilterInfo</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxPairFilteringMode.html">PxPairFilteringMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxForceMode.html">PxForceMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.  <a href="structPxForceMode.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxDataAccessFlag.html">PxDataAccessFlag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxLockedData.html">PxLockedData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parent class for bulk data that is shared between the SDK and the application.  <a href="classPxLockedData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxMaterialFlag.html">PxMaterialFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags which control the behavior of a material.  <a href="structPxMaterialFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxCombineMode.html">PxCombineMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enumeration that determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision.  <a href="structPxCombineMode.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxMaterial.html">PxMaterial</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Material class to represent a set of surface properties.  <a href="classPxMaterial.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html">PxPhysics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract singleton factory class used for instancing objects in the Physics SDK.  <a href="classPxPhysics.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPruningStructure.html">PxPruningStructure</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A precomputed pruning structure to accelerate scene queries against newly added actors.  <a href="classPxPruningStructure.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html">PxRigidActor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> represents a base class shared between dynamic and static rigid bodies in the physics SDK.  <a href="classPxRigidActor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxRigidBodyFlag.html">PxRigidBodyFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags describing the behavior of a rigid body.  <a href="structPxRigidBodyFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html">PxRigidBody</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects.  <a href="classPxRigidBody.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxRigidDynamicLockFlag.html">PxRigidDynamicLockFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags providing a mechanism to lock motion along/around a specific axis.  <a href="structPxRigidDynamicLockFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK.  <a href="classPxRigidDynamic.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> represents a static rigid body simulation object in the physics SDK.  <a href="classPxRigidStatic.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxActiveTransform.html">PxActiveTransform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data struct for use with Active Transform Notification. Used with <a class="el" href="classPxScene.html#5fdec7976b853ad4af5573bb13197426" title="Queries the PxScene for a list of the PxActors whose transforms have been updated...">PxScene::getActiveTransforms()</a>.  <a href="structPxActiveTransform.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxDominanceGroupPair.html">PxDominanceGroupPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expresses the dominance relationship of a contact. For the time being only three settings are permitted:.  <a href="structPxDominanceGroupPair.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxActorTypeFlag.html">PxActorTypeFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies each type of actor for retrieving actors from a scene.  <a href="structPxActorTypeFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxQueryCache.html">PxQueryCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">single hit cache for scene queries.  <a href="structPxQueryCache.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html">PxScene</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A scene is a collection of bodies, particle systems and constraints which can interact.  <a href="classPxScene.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxPruningStructureType.html">PxPruningStructureType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pruning structure used to accelerate scene queries.  <a href="structPxPruningStructureType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxSceneQueryUpdateMode.html">PxSceneQueryUpdateMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scene query update mode.  <a href="structPxSceneQueryUpdateMode.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFrictionType.html">PxFrictionType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum for selecting the friction algorithm used for simulation.  <a href="structPxFrictionType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxSceneFlag.html">PxSceneFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flags for configuring properties of the scene  <a href="structPxSceneFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneLimits.html">PxSceneLimits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits are used as a hint to the size of the scene, not as a hard limit (i.e. it will be possible to create more objects than specified in the scene limits).  <a href="classPxSceneLimits.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxgDynamicsMemoryConfig.html">PxgDynamicsMemoryConfig</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sizes of pre-allocated buffers use for GPU dynamics.  <a href="structPxgDynamicsMemoryConfig.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html">PxSceneDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor class for scenes. See <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>.  <a href="classPxSceneDesc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneReadLock.html">PxSceneReadLock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RAII wrapper for the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> read lock.  <a href="classPxSceneReadLock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneWriteLock.html">PxSceneWriteLock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RAII wrapper for the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> write lock.  <a href="classPxSceneWriteLock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxShapeFlag.html">PxShapeFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags which affect the behavior of PxShapes.  <a href="structPxShapeFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html">PxShape</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract class for collision shapes.  <a href="classPxShape.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairExtraDataType.html">PxContactPairExtraDataType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extra data item types for contact pairs.  <a href="structPxContactPairExtraDataType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairExtraDataItem.html">PxContactPairExtraDataItem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for items in the extra data stream of contact pairs.  <a href="structPxContactPairExtraDataItem.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairVelocity.html">PxContactPairVelocity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Velocities of the contact pair rigid bodies.  <a href="structPxContactPairVelocity.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairPose.html">PxContactPairPose</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">World space actor poses of the contact pair rigid bodies.  <a href="structPxContactPairPose.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairIndex.html">PxContactPairIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marker for the beginning of a new item set in the extra data stream.  <a href="structPxContactPairIndex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairExtraDataIterator.html">PxContactPairExtraDataIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class to iterate over a contact pair extra data stream.  <a href="structPxContactPairExtraDataIterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairHeaderFlag.html">PxContactPairHeaderFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags providing information on contact report pairs.  <a href="structPxContactPairHeaderFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An Instance of this class is passed to <a class="el" href="classPxSimulationEventCallback.html#4dc1da28643ccf9f77c8432b5eb2fd32" title="This is called when certain contact events occur.">PxSimulationEventCallback.onContact()</a>.  <a href="structPxContactPairHeader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairFlag.html">PxContactPairFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags providing information on contact report pairs.  <a href="structPxContactPairFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPairPoint.html">PxContactPairPoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A contact point as used by contact notification.  <a href="structPxContactPairPoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxContactPair.html">PxContactPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contact report pair information.  <a href="structPxContactPair.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxTriggerPairFlag.html">PxTriggerPairFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of flags providing information on trigger report pairs.  <a href="structPxTriggerPairFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxTriggerPair.html">PxTriggerPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor for a trigger pair.  <a href="structPxTriggerPair.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor for a broken constraint.  <a href="structPxConstraintInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An interface class that the user can implement in order to receive simulation events.  <a href="classPxSimulationEventCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationStatistics.html">PxSimulationStatistics</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class used to retrieve statistics for a simulation step.  <a href="classPxSimulationStatistics.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSpatialIndexItem.html">PxSpatialIndexItem</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxSpatialOverlapCallback.html">PxSpatialOverlapCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback class for overlap queries against <a class="el" href="classPxSpatialIndex.html" title="provides direct access to PhysX&#39; Spatial Query engine">PxSpatialIndex</a>.  <a href="structPxSpatialOverlapCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxSpatialLocationCallback.html">PxSpatialLocationCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback class for raycast and sweep queries against <a class="el" href="classPxSpatialIndex.html" title="provides direct access to PhysX&#39; Spatial Query engine">PxSpatialIndex</a>.  <a href="structPxSpatialLocationCallback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSpatialIndex.html">PxSpatialIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">provides direct access to PhysX' Spatial Query engine  <a href="classPxSpatialIndex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxVisualizationParameter.html">PxVisualizationParameter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug visualization parameters.  <a href="structPxVisualizationParameter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html">PxVolumeCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Volumetric cache for local collision geometry.  <a href="classPxVolumeCache.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxMetaDataEntry.html">PxMetaDataEntry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct to store meta data definitions.  <a href="structPxMetaDataEntry.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxStringTable.html">PxStringTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a table to manage strings. Strings allocated through this object are expected to be owned by this object.  <a href="classPxStringTable.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g4bbe5f9e9d6c0dc6c9a030201bcc4bdd">PX_USE_PARTICLE_SYSTEM_API</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gd61cd3c12ce8e68a6eb95e351f6e175c">PX_USE_CLOTH_API</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, metaData)&nbsp;&nbsp;&nbsp;stream.write(&amp;metaData, sizeof(<a class="el" href="structPxMetaDataEntry.html">PxMetaDataEntry</a>))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, Member)&nbsp;&nbsp;&nbsp;sizeof((reinterpret_cast&lt;Class*&gt;(0))-&gt;Member)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g14481630a9253df1784a9cad4e94d904">PX_DEF_BIN_METADATA_ITEM</a>(stream, Class, type, name, flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a member variable of a class  <a href="#g14481630a9253df1784a9cad4e94d904"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gd42d1fc82f3ab8db230e5050f2fe0cd0">PX_DEF_BIN_METADATA_ITEMS</a>(stream, Class, type, name, flags, count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a member array variable of a class  <a href="#gd42d1fc82f3ab8db230e5050f2fe0cd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g5c5117095910154a5e39fee736503e72">PX_DEF_BIN_METADATA_ITEMS_AUTO</a>(stream, Class, type, name, flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a member array variable of a class  <a href="#g5c5117095910154a5e39fee736503e72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g7d5660bc1b17b72651434edf7fa022a8">PX_DEF_BIN_METADATA_CLASS</a>(stream, Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a class  <a href="#g7d5660bc1b17b72651434edf7fa022a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g314967fa3f63ec7c0b84832edb318458">PX_DEF_BIN_METADATA_VCLASS</a>(stream, Class)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a virtual class  <a href="#g314967fa3f63ec7c0b84832edb318458"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g190471540583d37595e5532c7534f950">PX_DEF_BIN_METADATA_TYPEDEF</a>(stream, newType, oldType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a typedef  <a href="#g190471540583d37595e5532c7534f950"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g032d753d48dd9e14306d309c2b618410">PX_DEF_BIN_METADATA_BASE_CLASS</a>(stream, Class, BaseClass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for declaring a base class  <a href="#g032d753d48dd9e14306d309c2b618410"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gdf1f469d767ae64422c20cce7c71a6b3">PX_DEF_BIN_METADATA_UNION</a>(stream, Class, name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a union  <a href="#gdf1f469d767ae64422c20cce7c71a6b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g0f17b2c81d2d85ff9ff7f853464c38e7">PX_DEF_BIN_METADATA_UNION_TYPE</a>(stream, Class, type, enumValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for a particular member type of a union  <a href="#g0f17b2c81d2d85ff9ff7f853464c38e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g2cc87661da498e4f0c4ce26b6656e467">PX_DEF_BIN_METADATA_EXTRA_ITEM</a>(stream, Class, type, control, align)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for extra data  <a href="#g2cc87661da498e4f0c4ce26b6656e467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g39043f3971c7c14f163a41f41982701f">PX_DEF_BIN_METADATA_EXTRA_ITEMS</a>(stream, Class, type, control, count, flags, align)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for an array of extra data  <a href="#g39043f3971c7c14f163a41f41982701f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g5605c240ca14c7fbfabf545edb73bcdc">PX_DEF_BIN_METADATA_EXTRA_ITEMS_MASKED_CONTROL</a>(stream, Class, type, control, controlMask,count, flags, align)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for an array of extra data additional to PX_DEF_BIN_METADATA_EXTRA_ITEMS a mask can be specified to interpret the control value  <a href="#g5605c240ca14c7fbfabf545edb73bcdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge42707bb37470210b586a341ff585b78">PX_DEF_BIN_METADATA_EXTRA_ARRAY</a>(stream, Class, type, dyn_count, align, flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for an array of extra data  <a href="#ge42707bb37470210b586a341ff585b78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g03a3549588909e6ca0a491af76146757">PX_DEF_BIN_METADATA_EXTRA_NAME</a>(stream, Class, control, align)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry for an string of extra data  <a href="#g03a3549588909e6ca0a491af76146757"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g8a5eb66875b992351ed7038b8001bbea">PX_DEF_BIN_METADATA_EXTRA_ALIGN</a>(stream, Class, align)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specifies a binary metadata entry declaring an extra data alignment for a class  <a href="#g8a5eb66875b992351ed7038b8001bbea"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PxU8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d">PxActorFlag::Enum</a>, PxU8 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g468ad85db838378f0c58cfd02a96949b">PxActorFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collection of set bits defined in <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a>.  <a href="#g468ad85db838378f0c58cfd02a96949b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PX_DEPRECATED <br class="typebreak">
<a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult</a><br class="typebreak">
&lt; <a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g5d8a1dc3627cf1442f40d91a5ec6b4e3">PxRaycastQueryResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for the result of a batched raycast query.  <a href="#g5d8a1dc3627cf1442f40d91a5ec6b4e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PX_DEPRECATED <br class="typebreak">
<a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult</a>&lt; <a class="el" href="structPxSweepHit.html">PxSweepHit</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g89ec6835295298336ceaca7069ba96e4">PxSweepQueryResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for the result of a batched sweep query.  <a href="#g89ec6835295298336ceaca7069ba96e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PX_DEPRECATED <br class="typebreak">
<a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult</a><br class="typebreak">
&lt; <a class="el" href="structPxOverlapHit.html">PxOverlapHit</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge0a66b10a979f7449050bc97669530b2">PxOverlapQueryResult</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for the result of a batched overlap query.  <a href="#ge0a66b10a979f7449050bc97669530b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxConstraintFlag.html#86960e99b3e80ddb9e0ab51d7afc3427">PxConstraintFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gf2b7f07d3fa7fafaf3d85114fbb120ee">PxConstraintFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constraint flags  <a href="#gf2b7f07d3fa7fafaf3d85114fbb120ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPx1DConstraintFlag.html#0d9f59379f0d8eba3bace01f8bb88b76">Px1DConstraintFlag::Type</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga03d6d79255886721c3e1a946b5a805f">Px1DConstraintFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g538ba0a5410c612bc666bb10d44bcb7a">PxConstraintSolverPrep</a> )(<a class="el" href="structPx1DConstraint.html">Px1DConstraint</a> *constraints, <a class="el" href="classPxVec3.html">PxVec3</a> &amp;bodyAWorldOffset, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxConstraints, <a class="el" href="structPxConstraintInvMassScale.html">PxConstraintInvMassScale</a> &amp;invMassScale, const void *constantBlock, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyAToWorld, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyBToWorld)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g26f16746e25ee96e354e4ee05d6b359e">PxConstraintProject</a> )(const void *constantBlock, <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyAToWorld, <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyBToWorld, bool projectToA)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gcb8cd04ba92e7016abe9e14053e22373">PxConstraintVisualize</a> )(<a class="el" href="classPxConstraintVisualizer.html">PxConstraintVisualizer</a> &amp;visualizer, const void *constantBlock, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;body0Transform, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;body1Transform, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxDeletionEventFlag.html#77bf8900dd0107b612cdc7d86cb796f6">PxDeletionEventFlag::Enum</a>, <br class="typebreak">
PxU8 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gfb4c5337ad84e1f9eeaa8d3d33caa819">PxDeletionEventFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of set bits defined in <a class="el" href="structPxDeletionEventFlag.html" title="Flags specifying deletion event types.">PxDeletionEventFlag</a>.  <a href="#gfb4c5337ad84e1f9eeaa8d3d33caa819"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f">PxPairFlag::Enum</a>, PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gcacbeccf757e60dbf45089ef382681d9">PxPairFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitfield that contains a set of raised flags defined in <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>.  <a href="#gcacbeccf757e60dbf45089ef382681d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc58083">PxFilterFlag::Enum</a>, PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g675117fb97324a28d3b982b47430ea02">PxFilterFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitfield that contains a set of raised flags defined in <a class="el" href="structPxFilterFlag.html" title="Collection of flags describing the filter actions to take for a collision pair.">PxFilterFlag</a>.  <a href="#g675117fb97324a28d3b982b47430ea02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure which gets passed into the collision filtering shader and/or callback providing additional information on objects of a collision pair.  <a href="#g7b0c5783657e45e3fd752adfe3c1d069"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFilterFlags</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a> )(<a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attributes0, <a class="el" href="structPxFilterData.html">PxFilterData</a> filterData0, <a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attributes1, <a class="el" href="structPxFilterData.html">PxFilterData</a> filterData1, <a class="el" href="classPxFlags.html">PxPairFlags</a> &amp;pairFlags, const void *constantBlock, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> constantBlockSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filter shader to specify handling of collision pairs.  <a href="#g9db06e901a760fb02c06f27bf3e474b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxDataAccessFlag.html#b6bd468adf2809435d24c9fe4882b6be">PxDataAccessFlag::Enum</a>, PxU8 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g90395861aa5abb531d3dd02790bc2b18">PxDataAccessFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collection of set bits defined in <a class="el" href="structPxDataAccessFlag.html">PxDataAccessFlag</a>.  <a href="#g90395861aa5abb531d3dd02790bc2b18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxMaterialFlag.html#0cbfebf648d620e4619a5a81b49cc298">PxMaterialFlag::Enum</a>, PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gacd9cb0f0e89fbbc09fec759b254d109">PxMaterialFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collection of set bits defined in <a class="el" href="structPxMaterialFlag.html" title="Flags which control the behavior of a material.">PxMaterialFlag</a>.  <a href="#gacd9cb0f0e89fbbc09fec759b254d109"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a>, PxU8 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g2ab6803c803ae6372791ff060068c6a1">PxRigidBodyFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collection of set bits defined in <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a>.  <a href="#g2ab6803c803ae6372791ff060068c6a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxRigidDynamicLockFlag.html#e2e527a7cf32504d4b5c8c6d147280e1">PxRigidDynamicLockFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gb35e15599f740af43f399ed4ad9f04e8">PxRigidDynamicLockFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PxU8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxActorTypeFlag.html#62171a3f7d2dfa4b4b87285afdf6bae4">PxActorTypeFlag::Enum</a>, PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge76639de8e4ab9d5e155f72b394812d2">PxActorTypeFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of set bits defined in <a class="el" href="structPxActorTypeFlag.html" title="Identifies each type of actor for retrieving actors from a scene.">PxActorTypeFlag</a>.  <a href="#ge76639de8e4ab9d5e155f72b394812d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53">PxSceneFlag::Enum</a>, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g54a626a9a6d80543048bffc654814704">PxSceneFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collection of set bits defined in <a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a>.  <a href="#g54a626a9a6d80543048bffc654814704"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a">PxShapeFlag::Enum</a>, PxU8 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g18053d8127ddb5ed5609e4c748b6ad0d">PxShapeFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collection of set bits defined in <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>.  <a href="#g18053d8127ddb5ed5609e4c748b6ad0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxContactPairHeaderFlag.html#143dcb345f5c81bd542d33e67085ba3a">PxContactPairHeaderFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga4275c674f70ce3f0be586339eb0b045">PxContactPairHeaderFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitfield that contains a set of raised flags defined in <a class="el" href="structPxContactPairHeaderFlag.html" title="Collection of flags providing information on contact report pairs.">PxContactPairHeaderFlag</a>.  <a href="#ga4275c674f70ce3f0be586339eb0b045"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxContactPairFlag.html#a9414bf8c45ed9d53da3e5c98025fbe9">PxContactPairFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge73039b8bd7e7f4a606acfba4811291c">PxContactPairFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitfield that contains a set of raised flags defined in <a class="el" href="structPxContactPairFlag.html" title="Collection of flags providing information on contact report pairs.">PxContactPairFlag</a>.  <a href="#ge73039b8bd7e7f4a606acfba4811291c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxTriggerPairFlag.html#a3c006812673a9dc0a2a87e2be483ebb">PxTriggerPairFlag::Enum</a>, <br class="typebreak">
PxU8 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge5d4ef1b3321702c4431da8fe72b8f7f">PxTriggerPairFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitfield that contains a set of raised flags defined in <a class="el" href="structPxTriggerPairFlag.html" title="Collection of flags providing information on trigger report pairs.">PxTriggerPairFlag</a>.  <a href="#ge5d4ef1b3321702c4431da8fe72b8f7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga07c59a855d77f9e5f7bc2fc3cf8b816">PxSpatialIndexItemId</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE <a class="el" href="structPxFilterObjectType.html#6b94c22981119369d08ce8b13838a3cf">PxFilterObjectType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g479e145e0c33b0708ec9dd997480294a">PxGetFilterObjectType</a> (<a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract filter object type from the filter attributes of a collision pair object.  <a href="#g479e145e0c33b0708ec9dd997480294a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g396ee882c9ea7398e48bb9e0375a567c">PxFilterObjectIsKinematic</a> (<a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies whether the collision object belongs to a kinematic rigid body.  <a href="#g396ee882c9ea7398e48bb9e0375a567c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gbd83d1895d4f68e1e3e0f406c4c8ce65">PxFilterObjectIsTrigger</a> (<a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies whether the collision object is a trigger shape.  <a href="#gbd83d1895d4f68e1e3e0f406c4c8ce65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API <br class="typebreak">
void PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g92144d0904f8a696f85737c576b88d9f">PxRegisterArticulations</a> (physx::PxPhysics &amp;physics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the usage of the articulations feature. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use articulations. In this case the linker should strip out the relevant implementation code from the library. If you need to use articulations but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call.  <a href="#g92144d0904f8a696f85737c576b88d9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API <br class="typebreak">
void PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1">PxRegisterHeightFields</a> (physx::PxPhysics &amp;physics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the usage of the heightfield feature.  <a href="#ge3a84455caaa6a7de67513ea29a315e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED PX_C_EXPORT <br class="typebreak">
PX_PHYSX_CORE_API void <br class="typebreak">
PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g3a556a2d568cf1f36726d099bb21abd4">PxRegisterLegacyHeightFields</a> (physx::PxPhysics &amp;physics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the usage of the legacy heightfield feature.  <a href="#g3a556a2d568cf1f36726d099bb21abd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED PX_INLINE void <br class="typebreak">
PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g6adbba7aad2d451e684110269dddd720">PxRegisterUnifiedHeightFields</a> (physx::PxPhysics &amp;physics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the usage of the unified heightfield feature.  <a href="#g6adbba7aad2d451e684110269dddd720"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED PX_C_EXPORT <br class="typebreak">
PX_PHYSX_CORE_API void <br class="typebreak">
PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge2faa96309a4fb0cbfcd512d2431fc82">PxRegisterCloth</a> (physx::PxPhysics &amp;physics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the usage of the cloth feature. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use cloth. In this case the linker should strip out the relevant implementation code from the library. If you need to use cloth but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call.  <a href="#ge2faa96309a4fb0cbfcd512d2431fc82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED PX_C_EXPORT <br class="typebreak">
PX_PHYSX_CORE_API void <br class="typebreak">
PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g197726c3bfa1abc6fbe43875c2483b38">PxRegisterParticles</a> (physx::PxPhysics &amp;physics)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the usage of the particles feature. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. (deprecated) On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use particles. In this case the linker should strip out the relevant implementation code from the library. If you need to use particles but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call.  <a href="#g197726c3bfa1abc6fbe43875c2483b38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API <br class="typebreak">
physx::PxPhysics *PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66">PxCreateBasePhysics</a> (<a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a> version, physx::PxFoundation &amp;foundation, const physx::PxTolerancesScale &amp;scale, bool trackOutstandingAllocations=false, physx::PxPvd *pvd=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an instance of the physics SDK with minimal additional components registered.  <a href="#gd63c429157f9c8c87fcd0ea2f9b79f66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE physx::PxPhysics *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66">PxCreatePhysics</a> (<a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a> version, physx::PxFoundation &amp;foundation, const physx::PxTolerancesScale &amp;scale, bool trackOutstandingAllocations=false, physx::PxPvd *pvd=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an instance of the physics SDK.  <a href="#g8039bfec65da68b2294a97175ddb2c66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API <br class="typebreak">
physx::PxPhysics &amp;PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g824f991be62d7c28eadf32316562408f">PxGetPhysics</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the Physics SDK after it has been created.  <a href="#g824f991be62d7c28eadf32316562408f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED <br class="typebreak">
PX_PHYSX_CORE_API <br class="typebreak">
<a class="el" href="classPxSpatialIndex.html">PxSpatialIndex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g4608473fcea7bec808f20e2e9ed4bbf1">PxCreateSpatialIndex</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a spatial index.  <a href="#g4608473fcea7bec808f20e2e9ed4bbf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g7c50eeff3e586897d4441a18e43b7237">PxBatchQueryDesc::PxBatchQueryDesc</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxRaycastsPerExecute, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxSweepsPerExecute, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxOverlapsPerExecute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a batch query with specified maximum number of queries per batch.  <a href="#g7c50eeff3e586897d4441a18e43b7237"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g6c065d106bbbace6f2cc1d6f321af6bb">PxBatchQueryDesc::isValid</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gd36024f1760b55b0947dc0d91e080bd7">PxSceneLimits::PxSceneLimits</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor sets to default  <a href="#gd36024f1760b55b0947dc0d91e080bd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ge673c050f15b0fc912860adbb3394e34">PxSceneLimits::setToDefault</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(re)sets the structure to the default  <a href="#ge673c050f15b0fc912860adbb3394e34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g0fdb519fc67615aed0a8548b8f6fcab1">PxSceneLimits::isValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the descriptor is valid.  <a href="#g0fdb519fc67615aed0a8548b8f6fcab1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g8c083fd86a8c52ff269aa4dd3407127b">PxSceneDesc::PxSceneDesc</a> (const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor sets to default.  <a href="#g8c083fd86a8c52ff269aa4dd3407127b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga7375184ba494172fa7677dae44bd9a8">PxSceneDesc::setToDefault</a> (const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(re)sets the structure to the default.  <a href="#ga7375184ba494172fa7677dae44bd9a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g67b3ce67bea6cdb19619bed61f9e7641">PxSceneDesc::isValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the descriptor is valid.  <a href="#g67b3ce67bea6cdb19619bed61f9e7641"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g7ff203676a71282e269ff6844e93fa13">PxContactPair::extractContacts</a> (<a class="el" href="structPxContactPairPoint.html">PxContactPairPoint</a> *userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the contact points from the stream and stores them in a convenient format.  <a href="#g7ff203676a71282e269ff6844e93fa13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gdcafe5e4172403f89d62e592248fc5dc">PxContactPair::bufferContacts</a> (<a class="el" href="structPxContactPair.html">PxContactPair</a> *newPair, PxU8 *bufferMemory) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method to clone the contact pair and copy the contact data stream into a user buffer.  <a href="#gdcafe5e4172403f89d62e592248fc5dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g305b4df8647fb1ddb2b67918482ec789">PxContactPair::getInternalFaceIndices</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structPx1DConstraint.html">Px1DConstraint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g91f52ef3693d57cc073138122d8e24ec">PX_ALIGN_SUFFIX</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constraint.  <a href="#g91f52ef3693d57cc073138122d8e24ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gec480d86354043f6c7cb13b237914e7f">INVALID_FILTER_PAIR_INDEX</a> = 0xffffffff</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__physics.html#ga07c59a855d77f9e5f7bc2fc3cf8b816">PxSpatialIndexItemId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#gc5525ef79da01168ea797595a3e4dac0">PX_SPATIAL_INDEX_INVALID_ITEM_ID</a> = 0xffffffff</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Configuration include file for PhysX SDK <hr><h2>Define Documentation</h2>
<a class="anchor" name="g032d753d48dd9e14306d309c2b618410"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_BASE_CLASS" ref="g032d753d48dd9e14306d309c2b618410" args="(stream, Class, BaseClass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_BASE_CLASS          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseClass&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        Class* myClass = <span class="keyword">reinterpret_cast&lt;</span>Class*<span class="keyword">&gt;</span>(42);                                                          \
        BaseClass* s = <span class="keyword">static_cast&lt;</span>BaseClass*<span class="keyword">&gt;</span>(myClass);                                                        \
        <span class="keyword">const</span> <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> offset = <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<span class="keywordtype">size_t</span>(s) - <span class="keywordtype">size_t</span>(myClass));                                                \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #Class, #BaseClass, offset, <span class="keyword">sizeof</span>(Class), 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654cd9aa10c12e5694495894ce759636071a" title="declares a class">PxMetaDataFlag::eCLASS</a>, 0 };   \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp);                                                                         \
    }
</pre></div>specifies a binary metadata entry for declaring a base class 
<p>

</div>
</div><p>
<a class="anchor" name="g7d5660bc1b17b72651434edf7fa022a8"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_CLASS" ref="g7d5660bc1b17b72651434edf7fa022a8" args="(stream, Class)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_CLASS          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #Class, 0, 0, <span class="keyword">sizeof</span>(Class), 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654cd9aa10c12e5694495894ce759636071a" title="declares a class">PxMetaDataFlag::eCLASS</a>, 0 }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a class 
<p>

</div>
</div><p>
<a class="anchor" name="g8a5eb66875b992351ed7038b8001bbea"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_EXTRA_ALIGN" ref="g8a5eb66875b992351ed7038b8001bbea" args="(stream, Class, align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_EXTRA_ALIGN          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { <span class="stringliteral">"PxU8"</span>, <span class="stringliteral">"Alignment"</span>, 0, 0, 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654ced572f08dc7c6adff8f2b229a7354cce" title="declares extra data exported with PxSerializer::exportExtraData">PxMetaDataFlag::eEXTRA_DATA</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c50e48879be65410602056c6c386e798f" title="declares aligned data">PxMetaDataFlag::eALIGNMENT</a>, align}; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry declaring an extra data alignment for a class 
<p>

</div>
</div><p>
<a class="anchor" name="ge42707bb37470210b586a341ff585b78"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_EXTRA_ARRAY" ref="ge42707bb37470210b586a341ff585b78" args="(stream, Class, type, dyn_count, align, flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_EXTRA_ARRAY          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dyn_count,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flags&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, 0, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, dyn_count)), <a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, dyn_count), align, 0, \
                            <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654ced572f08dc7c6adff8f2b229a7354cce" title="declares extra data exported with PxSerializer::exportExtraData">PxMetaDataFlag::eEXTRA_DATA</a>|flags, align }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for an array of extra data 
<p>
similar to PX_DEF_BIN_METADATA_EXTRA_ITEMS, but supporting no control - <a class="el" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c1d241c59c1e26a777c46ff7688f8f1dd" title="declares a pointer">PxMetaDataFlag::ePTR</a> is also not supported 
</div>
</div><p>
<a class="anchor" name="g2cc87661da498e4f0c4ce26b6656e467"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_EXTRA_ITEM" ref="g2cc87661da498e4f0c4ce26b6656e467" args="(stream, Class, type, control, align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_EXTRA_ITEM          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">control,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, 0, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, control)), <span class="keyword">sizeof</span>(type), 0, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, control)), \
                            <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654ced572f08dc7c6adff8f2b229a7354cce" title="declares extra data exported with PxSerializer::exportExtraData">PxMetaDataFlag::eEXTRA_DATA</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c798b67b9b884d9937c5e020f227ac72d" title="specifies one element of extra data">PxMetaDataFlag::eEXTRA_ITEM</a>, align }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for extra data 
<p>

</div>
</div><p>
<a class="anchor" name="g39043f3971c7c14f163a41f41982701f"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_EXTRA_ITEMS" ref="g39043f3971c7c14f163a41f41982701f" args="(stream, Class, type, control, count, flags, align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_EXTRA_ITEMS          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">control,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flags,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, 0, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, control)), <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, control)), \
                            <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, count)), <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, count)), \
                            <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654ced572f08dc7c6adff8f2b229a7354cce" title="declares extra data exported with PxSerializer::exportExtraData">PxMetaDataFlag::eEXTRA_DATA</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c0480301f6d90a4bfdafa082c2be71b14" title="specifies an array of extra data">PxMetaDataFlag::eEXTRA_ITEMS</a>|flags, align }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for an array of extra data 
<p>

</div>
</div><p>
<a class="anchor" name="g5605c240ca14c7fbfabf545edb73bcdc"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_EXTRA_ITEMS_MASKED_CONTROL" ref="g5605c240ca14c7fbfabf545edb73bcdc" args="(stream, Class, type, control, controlMask,count, flags, align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_EXTRA_ITEMS_MASKED_CONTROL          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">control,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">controlMask,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flags,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, 0, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, control)), <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, control)), \
                            <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, count)), <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, count)), \
                            <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c361e04e4149dd27200c276f908a4106b" title="specifies that the control value is masked - mask bits are assumed to be within eCONTROL_MASK_RANGE...">PxMetaDataFlag::eCONTROL_MASK</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654ced572f08dc7c6adff8f2b229a7354cce" title="declares extra data exported with PxSerializer::exportExtraData">PxMetaDataFlag::eEXTRA_DATA</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c0480301f6d90a4bfdafa082c2be71b14" title="specifies an array of extra data">PxMetaDataFlag::eEXTRA_ITEMS</a>|flags|(controlMask &amp; <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654cbec61fbbaa42b2bf3ad7a397455f2f87" title="mask range allowed for eCONTROL_MASK">PxMetaDataFlag::eCONTROL_MASK_RANGE</a>) &lt;&lt; 16, \
                            align}; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for an array of extra data additional to PX_DEF_BIN_METADATA_EXTRA_ITEMS a mask can be specified to interpret the control value 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c361e04e4149dd27200c276f908a4106b" title="specifies that the control value is masked - mask bits are assumed to be within eCONTROL_MASK_RANGE...">PxMetaDataFlag::eCONTROL_MASK</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g03a3549588909e6ca0a491af76146757"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_EXTRA_NAME" ref="g03a3549588909e6ca0a491af76146757" args="(stream, Class, control, align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_EXTRA_NAME          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">control,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">align&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { <span class="stringliteral">"char"</span>, <span class="stringliteral">"string"</span>, 0, 0, 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654ced572f08dc7c6adff8f2b229a7354cce" title="declares extra data exported with PxSerializer::exportExtraData">PxMetaDataFlag::eEXTRA_DATA</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c0d903640b00c4f61682c59c792108e96" title="specifies a name of extra data">PxMetaDataFlag::eEXTRA_NAME</a>, align }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for an string of extra data 
<p>

</div>
</div><p>
<a class="anchor" name="g14481630a9253df1784a9cad4e94d904"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_ITEM" ref="g14481630a9253df1784a9cad4e94d904" args="(stream, Class, type, name, flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_ITEM          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">name,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flags&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, #name, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, name)), <a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, name), \
                                1, 0, flags, 0}; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a member variable of a class 
<p>

</div>
</div><p>
<a class="anchor" name="gd42d1fc82f3ab8db230e5050f2fe0cd0"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_ITEMS" ref="gd42d1fc82f3ab8db230e5050f2fe0cd0" args="(stream, Class, type, name, flags, count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_ITEMS          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">name,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flags,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, #name, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, name)), <a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, name), \
                            count, 0, flags, 0}; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a member array variable of a class 
<p>
similar to PX_DEF_BIN_METADATA_ITEMS_AUTO but for cases with mismatch between specified type and array type 
</div>
</div><p>
<a class="anchor" name="g5c5117095910154a5e39fee736503e72"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_ITEMS_AUTO" ref="g5c5117095910154a5e39fee736503e72" args="(stream, Class, type, name, flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_ITEMS_AUTO          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">name,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flags&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #type, #name, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, name)), <a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, name), \
                            <span class="keyword">sizeof</span>((<span class="keyword">reinterpret_cast&lt;</span>Class*<span class="keyword">&gt;</span>(0))-&gt;name)/<span class="keyword">sizeof</span>(type), 0, flags, 0}; \
                            <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a member array variable of a class 
<p>
similar to PX_DEF_BIN_METADATA_ITEMS but automatically detects the array length, which only works when the specified type matches the type of the array - does not support <a class="el" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c1d241c59c1e26a777c46ff7688f8f1dd" title="declares a pointer">PxMetaDataFlag::ePTR</a> 
</div>
</div><p>
<a class="anchor" name="g190471540583d37595e5532c7534f950"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_TYPEDEF" ref="g190471540583d37595e5532c7534f950" args="(stream, newType, oldType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_TYPEDEF          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">newType,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">oldType&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #newType, #oldType, 0, 0, 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c01cb08bb8663787a10fdc899fdcc5d41" title="declares a typedef">PxMetaDataFlag::eTYPEDEF</a>, 0 }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a typedef 
<p>

</div>
</div><p>
<a class="anchor" name="gdf1f469d767ae64422c20cce7c71a6b3"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_UNION" ref="gdf1f469d767ae64422c20cce7c71a6b3" args="(stream, Class, name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_UNION          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #Class, 0, <a class="code" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(<a class="code" href="group__foundation.html#g2ac82f7e080e1411a86f98758a0f3875">PX_OFFSET_OF_RT</a>(Class, name)), <a class="code" href="group__physics.html#g59c318a035d7a555f3e2188d757059bf">PX_SIZE_OF</a>(Class, name), \
                            1, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c1e6f153be653b33f7abfc2e91bd473cc" title="declares a union">PxMetaDataFlag::eUNION</a>, 0 }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a union 
<p>

</div>
</div><p>
<a class="anchor" name="g0f17b2c81d2d85ff9ff7f853464c38e7"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_UNION_TYPE" ref="g0f17b2c81d2d85ff9ff7f853464c38e7" args="(stream, Class, type, enumValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_UNION_TYPE          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enumValue&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #Class, #type, enumValue, 0, 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c1e6f153be653b33f7abfc2e91bd473cc" title="declares a union">PxMetaDataFlag::eUNION</a>, 0 }; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a particular member type of a union 
<p>

</div>
</div><p>
<a class="anchor" name="g314967fa3f63ec7c0b84832edb318458"></a><!-- doxytag: member="PxMetaData.h::PX_DEF_BIN_METADATA_VCLASS" ref="g314967fa3f63ec7c0b84832edb318458" args="(stream, Class)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DEF_BIN_METADATA_VCLASS          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Class&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        <a class="code" href="structPxMetaDataEntry.html" title="Struct to store meta data definitions.">PxMetaDataEntry</a> tmp = { #Class, 0, 0, <span class="keyword">sizeof</span>(Class), 0, 0, <a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654cd9aa10c12e5694495894ce759636071a" title="declares a class">PxMetaDataFlag::eCLASS</a>|<a class="code" href="structPxMetaDataFlag.html#5125f2eba9d78234a2bc7a00b3c3654c5af5b1fe2c903eef9584a6d6d24f9a47" title="declares class to be virtual">PxMetaDataFlag::eVIRTUAL</a>, 0}; \
        <a class="code" href="group__physics.html#gffbcca4cdc677e1e2fe5cf379146727e">PX_STORE_METADATA</a>(stream, tmp); \
    }
</pre></div>specifies a binary metadata entry for a virtual class 
<p>

</div>
</div><p>
<a class="anchor" name="g59c318a035d7a555f3e2188d757059bf"></a><!-- doxytag: member="PxMetaData.h::PX_SIZE_OF" ref="g59c318a035d7a555f3e2188d757059bf" args="(Class, Member)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_SIZE_OF          </td>
          <td>(</td>
          <td class="paramtype">Class,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Member&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;sizeof((reinterpret_cast&lt;Class*&gt;(0))-&gt;Member)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gffbcca4cdc677e1e2fe5cf379146727e"></a><!-- doxytag: member="PxMetaData.h::PX_STORE_METADATA" ref="gffbcca4cdc677e1e2fe5cf379146727e" args="(stream, metaData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_STORE_METADATA          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metaData&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;stream.write(&amp;metaData, sizeof(<a class="el" href="structPxMetaDataEntry.html">PxMetaDataEntry</a>))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gd61cd3c12ce8e68a6eb95e351f6e175c"></a><!-- doxytag: member="PxPhysXConfig.h::PX_USE_CLOTH_API" ref="gd61cd3c12ce8e68a6eb95e351f6e175c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_USE_CLOTH_API&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g4bbe5f9e9d6c0dc6c9a030201bcc4bdd"></a><!-- doxytag: member="PxPhysXConfig.h::PX_USE_PARTICLE_SYSTEM_API" ref="g4bbe5f9e9d6c0dc6c9a030201bcc4bdd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_USE_PARTICLE_SYSTEM_API&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga03d6d79255886721c3e1a946b5a805f"></a><!-- doxytag: member="PxConstraintDesc.h::Px1DConstraintFlags" ref="ga03d6d79255886721c3e1a946b5a805f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPx1DConstraintFlag.html#0d9f59379f0d8eba3bace01f8bb88b76">Px1DConstraintFlag::Type</a>, PxU16&gt; <a class="el" href="classPxFlags.html">Px1DConstraintFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g468ad85db838378f0c58cfd02a96949b"></a><!-- doxytag: member="PxActor.h::PxActorFlags" ref="g468ad85db838378f0c58cfd02a96949b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d">PxActorFlag::Enum</a>,PxU8&gt; <a class="el" href="classPxFlags.html">PxActorFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collection of set bits defined in <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge76639de8e4ab9d5e155f72b394812d2"></a><!-- doxytag: member="PxScene.h::PxActorTypeFlags" ref="ge76639de8e4ab9d5e155f72b394812d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxActorTypeFlag.html#62171a3f7d2dfa4b4b87285afdf6bae4">PxActorTypeFlag::Enum</a>,PxU16&gt; <a class="el" href="classPxFlags.html">PxActorTypeFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collection of set bits defined in <a class="el" href="structPxActorTypeFlag.html" title="Identifies each type of actor for retrieving actors from a scene.">PxActorTypeFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxActorTypeFlag.html" title="Identifies each type of actor for retrieving actors from a scene.">PxActorTypeFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf2b7f07d3fa7fafaf3d85114fbb120ee"></a><!-- doxytag: member="PxConstraint.h::PxConstraintFlags" ref="gf2b7f07d3fa7fafaf3d85114fbb120ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxConstraintFlag.html#86960e99b3e80ddb9e0ab51d7afc3427">PxConstraintFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxConstraintFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constraint flags 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxConstraintFlag.html" title="a table of function pointers for a constraint">PxConstraintFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g26f16746e25ee96e354e4ee05d6b359e"></a><!-- doxytag: member="PxConstraintDesc.h::PxConstraintProject" ref="g26f16746e25ee96e354e4ee05d6b359e" args=")(const void *constantBlock, PxTransform &amp;bodyAToWorld, PxTransform &amp;bodyBToWorld, bool projectToA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__physics.html#g26f16746e25ee96e354e4ee05d6b359e">PxConstraintProject</a>)(const void *constantBlock, <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyAToWorld, <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyBToWorld, bool projectToA)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
solver constraint projection shader<p>
This function is called by the constraint post-solver framework. The function must be reentrant, since it may be called simultaneously from multiple threads and should access only the arguments passed into it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constantBlock</em>&nbsp;</td><td>the constant data block </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bodyAToWorld</em>&nbsp;</td><td>The center of mass frame of the first constrained body (the identity if the actor is static or a NULL pointer was provided for it) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bodyBToWorld</em>&nbsp;</td><td>The center of mass frame of the second constrained body (the identity if the actor is static or a NULL pointer was provided for it) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>projectToA</em>&nbsp;</td><td>true if the constraint should be projected by moving the second body towards the first, false if the converse </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g538ba0a5410c612bc666bb10d44bcb7a"></a><!-- doxytag: member="PxConstraintDesc.h::PxConstraintSolverPrep" ref="g538ba0a5410c612bc666bb10d44bcb7a" args=")(Px1DConstraint *constraints, PxVec3 &amp;bodyAWorldOffset, PxU32 maxConstraints, PxConstraintInvMassScale &amp;invMassScale, const void *constantBlock, const PxTransform &amp;bodyAToWorld, const PxTransform &amp;bodyBToWorld)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>(* <a class="el" href="group__physics.html#g538ba0a5410c612bc666bb10d44bcb7a">PxConstraintSolverPrep</a>)(<a class="el" href="structPx1DConstraint.html">Px1DConstraint</a> *constraints, <a class="el" href="classPxVec3.html">PxVec3</a> &amp;bodyAWorldOffset, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxConstraints, <a class="el" href="structPxConstraintInvMassScale.html">PxConstraintInvMassScale</a> &amp;invMassScale, const void *constantBlock, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyAToWorld, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;bodyBToWorld)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
solver constraint generation shader<p>
This function is called by the constraint solver framework. The function must be reentrant, since it may be called simultaneously from multiple threads, and should access only the arguments passed into it.<p>
Developers writing custom constraints are encouraged to read the documentation in the user guide and the implementation code in PhysXExtensions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>constraints</em>&nbsp;</td><td>an array of solver constraint rows to be filled in </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bodyAWorldOffset</em>&nbsp;</td><td>the origin point (offset from the position vector of bodyA's center of mass) at which the constraint is resolved. This value does not affect how constraints are solved, only the constraint force reported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxConstraints</em>&nbsp;</td><td>the size of the constraint buffer. At most this many constraints rows may be written </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>invMassScale</em>&nbsp;</td><td>the inverse mass and inertia scales for the constraint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constantBlock</em>&nbsp;</td><td>the constant data block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bodyAToWorld</em>&nbsp;</td><td>The center of mass frame of the first constrained body (the identity transform if the first actor is static, or if a NULL actor pointer was provided for it) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bodyBToWorld</em>&nbsp;</td><td>The center of mass frame of the second constrained body (the identity transform if the second actor is static, or if a NULL actor pointer was provided for it)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of constraint rows written. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcb8cd04ba92e7016abe9e14053e22373"></a><!-- doxytag: member="PxConstraintDesc.h::PxConstraintVisualize" ref="gcb8cd04ba92e7016abe9e14053e22373" args=")(PxConstraintVisualizer &amp;visualizer, const void *constantBlock, const PxTransform &amp;body0Transform, const PxTransform &amp;body1Transform, PxU32 flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__physics.html#gcb8cd04ba92e7016abe9e14053e22373">PxConstraintVisualize</a>)(<a class="el" href="classPxConstraintVisualizer.html">PxConstraintVisualizer</a> &amp;visualizer, const void *constantBlock, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;body0Transform, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;body1Transform, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> flags)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
solver constraint visualization function<p>
This function is called by the constraint post-solver framework to visualize the constraint<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>visualizer</em>&nbsp;</td><td>The render buffer to render to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constantBlock</em>&nbsp;</td><td>The constant data block </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body0Transform</em>&nbsp;</td><td>The center of mass frame of the first constrained body (the identity if the actor is static, or a NULL pointer was provided for it) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body1Transform</em>&nbsp;</td><td>The center of mass frame of the second constrained body (the identity if the actor is static, or a NULL pointer was provided for it) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>The visualization flags (<a class="el" href="structPxConstraintVisualizationFlag.html" title="Flags for determining which components of the constraint should be visualized.">PxConstraintVisualizationFlag</a>)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRenderBuffer.html" title="Interface for points, lines, triangles, and text buffer.">PxRenderBuffer</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge73039b8bd7e7f4a606acfba4811291c"></a><!-- doxytag: member="PxSimulationEventCallback.h::PxContactPairFlags" ref="ge73039b8bd7e7f4a606acfba4811291c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxContactPairFlag.html#a9414bf8c45ed9d53da3e5c98025fbe9">PxContactPairFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxContactPairFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitfield that contains a set of raised flags defined in <a class="el" href="structPxContactPairFlag.html" title="Collection of flags providing information on contact report pairs.">PxContactPairFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxContactPairFlag.html" title="Collection of flags providing information on contact report pairs.">PxContactPairFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga4275c674f70ce3f0be586339eb0b045"></a><!-- doxytag: member="PxSimulationEventCallback.h::PxContactPairHeaderFlags" ref="ga4275c674f70ce3f0be586339eb0b045" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxContactPairHeaderFlag.html#143dcb345f5c81bd542d33e67085ba3a">PxContactPairHeaderFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxContactPairHeaderFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitfield that contains a set of raised flags defined in <a class="el" href="structPxContactPairHeaderFlag.html" title="Collection of flags providing information on contact report pairs.">PxContactPairHeaderFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxContactPairHeaderFlag.html" title="Collection of flags providing information on contact report pairs.">PxContactPairHeaderFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g90395861aa5abb531d3dd02790bc2b18"></a><!-- doxytag: member="PxLockedData.h::PxDataAccessFlags" ref="g90395861aa5abb531d3dd02790bc2b18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxDataAccessFlag.html#b6bd468adf2809435d24c9fe4882b6be">PxDataAccessFlag::Enum</a>,PxU8&gt; <a class="el" href="classPxFlags.html">PxDataAccessFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collection of set bits defined in <a class="el" href="structPxDataAccessFlag.html">PxDataAccessFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxDataAccessFlag.html">PxDataAccessFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfb4c5337ad84e1f9eeaa8d3d33caa819"></a><!-- doxytag: member="PxDeletionListener.h::PxDeletionEventFlags" ref="gfb4c5337ad84e1f9eeaa8d3d33caa819" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxDeletionEventFlag.html#77bf8900dd0107b612cdc7d86cb796f6">PxDeletionEventFlag::Enum</a>,PxU8&gt; <a class="el" href="classPxFlags.html">PxDeletionEventFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Collection of set bits defined in <a class="el" href="structPxDeletionEventFlag.html" title="Flags specifying deletion event types.">PxDeletionEventFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxDeletionEventFlag.html" title="Flags specifying deletion event types.">PxDeletionEventFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf665154f3f66f7c4f65ca9015db8ee87"></a><!-- doxytag: member="PxScene.h::PxDominanceGroup" ref="gf665154f3f66f7c4f65ca9015db8ee87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PxU8 <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gf665154f3f66f7c4f65ca9015db8ee87"></a><!-- doxytag: member="PxActor.h::PxDominanceGroup" ref="gf665154f3f66f7c4f65ca9015db8ee87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PxU8 <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Group index which allows to specify 1- or 2-way interaction 
</div>
</div><p>
<a class="anchor" name="g675117fb97324a28d3b982b47430ea02"></a><!-- doxytag: member="PxFiltering.h::PxFilterFlags" ref="g675117fb97324a28d3b982b47430ea02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc58083">PxFilterFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxFilterFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitfield that contains a set of raised flags defined in <a class="el" href="structPxFilterFlag.html" title="Collection of flags describing the filter actions to take for a collision pair.">PxFilterFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxFilterFlag.html" title="Collection of flags describing the filter actions to take for a collision pair.">PxFilterFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7b0c5783657e45e3fd752adfe3c1d069"></a><!-- doxytag: member="PxFiltering.h::PxFilterObjectAttributes" ref="g7b0c5783657e45e3fd752adfe3c1d069" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Structure which gets passed into the collision filtering shader and/or callback providing additional information on objects of a collision pair. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> getActorType() <a class="el" href="group__physics.html#g396ee882c9ea7398e48bb9e0375a567c" title="Specifies whether the collision object belongs to a kinematic rigid body.">PxFilterObjectIsKinematic()</a> <a class="el" href="group__physics.html#gbd83d1895d4f68e1e3e0f406c4c8ce65" title="Specifies whether the collision object is a trigger shape.">PxFilterObjectIsTrigger()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gacd9cb0f0e89fbbc09fec759b254d109"></a><!-- doxytag: member="PxMaterial.h::PxMaterialFlags" ref="gacd9cb0f0e89fbbc09fec759b254d109" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxMaterialFlag.html#0cbfebf648d620e4619a5a81b49cc298">PxMaterialFlag::Enum</a>,PxU16&gt; <a class="el" href="classPxFlags.html">PxMaterialFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collection of set bits defined in <a class="el" href="structPxMaterialFlag.html" title="Flags which control the behavior of a material.">PxMaterialFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxMaterialFlag.html" title="Flags which control the behavior of a material.">PxMaterialFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge0a66b10a979f7449050bc97669530b2"></a><!-- doxytag: member="PxBatchQueryDesc.h::PxOverlapQueryResult" ref="ge0a66b10a979f7449050bc97669530b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PX_DEPRECATED <a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult</a>&lt;<a class="el" href="structPxOverlapHit.html">PxOverlapHit</a>&gt; <a class="el" href="group__physics.html#ge0a66b10a979f7449050bc97669530b2">PxOverlapQueryResult</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience typedef for the result of a batched overlap query. 
<p>

</div>
</div><p>
<a class="anchor" name="gcacbeccf757e60dbf45089ef382681d9"></a><!-- doxytag: member="PxFiltering.h::PxPairFlags" ref="gcacbeccf757e60dbf45089ef382681d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f">PxPairFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxPairFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitfield that contains a set of raised flags defined in <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5d8a1dc3627cf1442f40d91a5ec6b4e3"></a><!-- doxytag: member="PxBatchQueryDesc.h::PxRaycastQueryResult" ref="g5d8a1dc3627cf1442f40d91a5ec6b4e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PX_DEPRECATED <a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult</a>&lt;<a class="el" href="structPxRaycastHit.html">PxRaycastHit</a>&gt; <a class="el" href="group__physics.html#g5d8a1dc3627cf1442f40d91a5ec6b4e3">PxRaycastQueryResult</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience typedef for the result of a batched raycast query. 
<p>

</div>
</div><p>
<a class="anchor" name="g2ab6803c803ae6372791ff060068c6a1"></a><!-- doxytag: member="PxRigidBody.h::PxRigidBodyFlags" ref="g2ab6803c803ae6372791ff060068c6a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a>,PxU8&gt; <a class="el" href="classPxFlags.html">PxRigidBodyFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collection of set bits defined in <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb35e15599f740af43f399ed4ad9f04e8"></a><!-- doxytag: member="PxRigidDynamic.h::PxRigidDynamicLockFlags" ref="gb35e15599f740af43f399ed4ad9f04e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxRigidDynamicLockFlag.html#e2e527a7cf32504d4b5c8c6d147280e1">PxRigidDynamicLockFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxRigidDynamicLockFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g54a626a9a6d80543048bffc654814704"></a><!-- doxytag: member="PxSceneDesc.h::PxSceneFlags" ref="g54a626a9a6d80543048bffc654814704" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53">PxSceneFlag::Enum</a>,<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&gt; <a class="el" href="classPxFlags.html">PxSceneFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collection of set bits defined in <a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g18053d8127ddb5ed5609e4c748b6ad0d"></a><!-- doxytag: member="PxShape.h::PxShapeFlags" ref="g18053d8127ddb5ed5609e4c748b6ad0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a">PxShapeFlag::Enum</a>,PxU8&gt; <a class="el" href="classPxFlags.html">PxShapeFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collection of set bits defined in <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9db06e901a760fb02c06f27bf3e474b3"></a><!-- doxytag: member="PxFiltering.h::PxSimulationFilterShader" ref="g9db06e901a760fb02c06f27bf3e474b3" args=")(PxFilterObjectAttributes attributes0, PxFilterData filterData0, PxFilterObjectAttributes attributes1, PxFilterData filterData1, PxPairFlags &amp;pairFlags, const void *constantBlock, PxU32 constantBlockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFilterFlags</a>(* <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a>)(<a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attributes0, <a class="el" href="structPxFilterData.html">PxFilterData</a> filterData0, <a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attributes1, <a class="el" href="structPxFilterData.html">PxFilterData</a> filterData1, <a class="el" href="classPxFlags.html">PxPairFlags</a> &amp;pairFlags, const void *constantBlock, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> constantBlockSize)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Filter shader to specify handling of collision pairs. 
<p>
Collision filtering is a mechanism to specify how a pair of potentially colliding objects should be processed by the simulation. A pair of objects is potentially colliding if the bounding volumes of the two objects overlap. In short, a collision filter decides whether a collision pair should get processed, temporarily ignored or discarded. If a collision pair should get processed, the filter can additionally specify how it should get processed, for instance, whether contacts should get resolved, which callbacks should get invoked or which reports should be sent etc.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A default implementation of a filter shader is provided in the PhysX extensions library, see <a class="el" href="group__extensions.html#g587ba12f90f77543c3e4452abeb0f22f" title="Implementation of a simple filter shader that emulates PhysX 2.8.x filtering.">PxDefaultSimulationFilterShader</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#9410287c6ea926dad9e2b2374541ad38" title="The custom filter shader to use for collision filtering.">PxSceneDesc.filterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> Filter method to specify how a pair of potentially colliding objects should be processed.Return the <a class="el" href="structPxFilterFlag.html" title="Collection of flags describing the filter actions to take for a collision pair.">PxFilterFlag</a> flags and set the <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> flags to define what the simulation should do with the given collision pair.</dd></dl>
This methods gets called when: <ul>
<li>The bounding volumes of two objects start to overlap. </li>
<li>The bounding volumes of two objects overlap and the filter data or filter attributes of one of the objects changed </li>
<li>A re-filtering was forced through resetFiltering() (see <a class="el" href="classPxScene.html#f648aa06d19cfec20eeee278719f345c" title="Marks the object to reset interactions and re-run collision filters in the next simulation...">PxScene::resetFiltering()</a>) </li>
<li>Filtering is requested in scene queries</li>
</ul>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Certain pairs of objects are always ignored and this method does not get called. This is the case for the following pairs:</dd></dl>
<ul>
<li>Pair of static rigid actors </li>
<li>A static rigid actor and a kinematic actor (unless one is a trigger or if explicitly enabled through PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS) </li>
<li>Two kinematic actors (unless one is a trigger or if explicitly enabled through PxSceneFlag::eENABLE_KINEMATIC_PAIRS) </li>
<li>Pair of particle systems </li>
<li>Two jointed rigid bodies and the joint was defined to disable collision </li>
<li>Two articulation links if connected through an articulation joint </li>
<li>Cloth objects and rigid body actors</li>
</ul>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is a performance critical method and should be stateless. You should neither access external objects from within this method nor should you call external methods that are not inlined. If you need a more complex logic to filter a collision pair then use the filter callback mechanism for this pair (see <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a>, <a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc5808362c42e8178d44dc0ead47699f9df87b8" title="Invoke the filter callback (PxSimulationFilterCallback::pairFound()) for this collision...">PxFilterFlag::eCALLBACK</a>, <a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc58083fbb0680c3ea5447f44fc90560bd7dd8f" title="Track this collision pair with the filter callback mechanism.">PxFilterFlag::eNOTIFY</a>).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attributes0</em>&nbsp;</td><td>The filter attribute of the first object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData0</em>&nbsp;</td><td>The custom filter data of the first object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attributes1</em>&nbsp;</td><td>The filter attribute of the second object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData1</em>&nbsp;</td><td>The custom filter data of the second object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pairFlags</em>&nbsp;</td><td>Flags giving additional information on how an accepted pair should get processed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constantBlock</em>&nbsp;</td><td>The constant global filter data (see <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constantBlockSize</em>&nbsp;</td><td>Size of the global filter data (see <a class="el" href="classPxSceneDesc.html#710c03915bbaaa9bdf23925d535c3883" title="Size (in bytes) of the shared global filter data filterShaderData.">PxSceneDesc.filterShaderDataSize</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Filter flags defining whether the pair should be discarded, temporarily ignored, processed and whether the filter callback should get invoked for this pair.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> <a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> <a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069" title="Structure which gets passed into the collision filtering shader and/or callback providing...">PxFilterObjectAttributes</a> <a class="el" href="structPxFilterFlag.html" title="Collection of flags describing the filter actions to take for a collision pair.">PxFilterFlag</a> <a class="el" href="group__physics.html#g675117fb97324a28d3b982b47430ea02" title="Bitfield that contains a set of raised flags defined in PxFilterFlag.">PxFilterFlags</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="group__physics.html#gcacbeccf757e60dbf45089ef382681d9" title="Bitfield that contains a set of raised flags defined in PxPairFlag.">PxPairFlags</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga07c59a855d77f9e5f7bc2fc3cf8b816"></a><!-- doxytag: member="PxSpatialIndex.h::PxSpatialIndexItemId" ref="ga07c59a855d77f9e5f7bc2fc3cf8b816" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="group__physics.html#ga07c59a855d77f9e5f7bc2fc3cf8b816">PxSpatialIndexItemId</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g89ec6835295298336ceaca7069ba96e4"></a><!-- doxytag: member="PxBatchQueryDesc.h::PxSweepQueryResult" ref="g89ec6835295298336ceaca7069ba96e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PX_DEPRECATED <a class="el" href="structPxBatchQueryResult.html">PxBatchQueryResult</a>&lt;<a class="el" href="structPxSweepHit.html">PxSweepHit</a>&gt; <a class="el" href="group__physics.html#g89ec6835295298336ceaca7069ba96e4">PxSweepQueryResult</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience typedef for the result of a batched sweep query. 
<p>

</div>
</div><p>
<a class="anchor" name="ge5d4ef1b3321702c4431da8fe72b8f7f"></a><!-- doxytag: member="PxSimulationEventCallback.h::PxTriggerPairFlags" ref="ge5d4ef1b3321702c4431da8fe72b8f7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxTriggerPairFlag.html#a3c006812673a9dc0a2a87e2be483ebb">PxTriggerPairFlag::Enum</a>, PxU8&gt; <a class="el" href="classPxFlags.html">PxTriggerPairFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitfield that contains a set of raised flags defined in <a class="el" href="structPxTriggerPairFlag.html" title="Collection of flags providing information on trigger report pairs.">PxTriggerPairFlag</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxTriggerPairFlag.html" title="Collection of flags providing information on trigger report pairs.">PxTriggerPairFlag</a> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gdcafe5e4172403f89d62e592248fc5dc"></a><!-- doxytag: member="PxContactPair::bufferContacts" ref="gdcafe5e4172403f89d62e592248fc5dc" args="(PxContactPair *newPair, PxU8 *bufferMemory) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE void PxContactPair::bufferContacts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxContactPair.html">PxContactPair</a> *&nbsp;</td>
          <td class="paramname"> <em>newPair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU8 *&nbsp;</td>
          <td class="paramname"> <em>bufferMemory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper method to clone the contact pair and copy the contact data stream into a user buffer. 
<p>
The contact data stream is only accessible during the contact report callback. This helper function provides copy functionality to buffer the contact stream information such that it can get accessed at a later stage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>newPair</em>&nbsp;</td><td>The contact pair info will get copied to this instance. The contact data stream pointer of the copy will be redirected to the provided user buffer. Use NULL to skip the contact pair copy operation. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bufferMemory</em>&nbsp;</td><td>Memory block to store the contact data stream to. At most <a class="el" href="structPxContactPair.html#8bee18db2d05286fc1e1b14bac54184f" title="Size of the contact stream [bytes] including force buffer.">requiredBufferSize</a> bytes will get written to the buffer. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="PxSimulationEventCallback_8h-source.html#l00555">PxContactPair::contactCount</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00545">PxContactPair::contactImpulses</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00529">PxContactPair::contactPatches</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00537">PxContactPair::contactPoints</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00567">PxContactPair::contactStreamSize</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00561">PxContactPair::patchCount</a>, and <a class="el" href="PxMemory_8h-source.html#l00084">PxMemCopy()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7ff203676a71282e269ff6844e93fa13"></a><!-- doxytag: member="PxContactPair::extractContacts" ref="g7ff203676a71282e269ff6844e93fa13" args="(PxContactPairPoint *userBuffer, PxU32 bufferSize) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxContactPair::extractContacts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxContactPairPoint.html">PxContactPairPoint</a> *&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts the contact points from the stream and stores them in a convenient format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>Array of <a class="el" href="structPxContactPairPoint.html" title="A contact point as used by contact notification.">PxContactPairPoint</a> structures to extract the contact points to. The number of contacts for a pair is defined by <a class="el" href="structPxContactPair.html#fd3b2178f7005d3563f41b4925e60a39" title="Number of contact points stored in the contact stream.">contactCount</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Number of <a class="el" href="structPxContactPairPoint.html" title="A contact point as used by contact notification.">PxContactPairPoint</a> structures the provided buffer can store. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of contact points written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxContactPairPoint.html" title="A contact point as used by contact notification.">PxContactPairPoint</a> </dd></dl>

<p>References <a class="el" href="PxSimulationEventCallback_8h-source.html#l00555">PxContactPair::contactCount</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00545">PxContactPair::contactImpulses</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00529">PxContactPair::contactPatches</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00537">PxContactPair::contactPoints</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00447">PxContactPairFlag::eINTERNAL_CONTACTS_ARE_FLIPPED</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00440">PxContactPairFlag::eINTERNAL_HAS_IMPULSES</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00574">PxContactPair::flags</a>, <a class="el" href="PxContact_8h-source.html#l00370">PxContactStreamIterator::getContactNormal()</a>, <a class="el" href="PxContact_8h-source.html#l00433">PxContactStreamIterator::getContactPoint()</a>, <a class="el" href="PxContact_8h-source.html#l00451">PxContactStreamIterator::getFaceIndex0()</a>, <a class="el" href="PxContact_8h-source.html#l00460">PxContactStreamIterator::getFaceIndex1()</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00705">PxContactPair::getInternalFaceIndices()</a>, <a class="el" href="PxContact_8h-source.html#l00442">PxContactStreamIterator::getSeparation()</a>, <a class="el" href="PxContact_8h-source.html#l00345">PxContactStreamIterator::hasNextContact()</a>, <a class="el" href="PxContact_8h-source.html#l00303">PxContactStreamIterator::hasNextPatch()</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00488">PxContactPairPoint::impulse</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00483">PxContactPairPoint::internalFaceIndex0</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00493">PxContactPairPoint::internalFaceIndex1</a>, <a class="el" href="PxContact_8h-source.html#l00353">PxContactStreamIterator::nextContact()</a>, <a class="el" href="PxContact_8h-source.html#l00325">PxContactStreamIterator::nextPatch()</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00478">PxContactPairPoint::normal</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00561">PxContactPair::patchCount</a>, <a class="el" href="PxSimulationEventCallback_8h-source.html#l00468">PxContactPairPoint::position</a>, and <a class="el" href="PxSimulationEventCallback_8h-source.html#l00473">PxContactPairPoint::separation</a>.</p>

</div>
</div><p>
<a class="anchor" name="g305b4df8647fb1ddb2b67918482ec789"></a><!-- doxytag: member="PxContactPair::getInternalFaceIndices" ref="g305b4df8647fb1ddb2b67918482ec789" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> * PxContactPair::getInternalFaceIndices           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="PxSimulationEventCallback_8h-source.html#l00555">PxContactPair::contactCount</a>, and <a class="el" href="PxSimulationEventCallback_8h-source.html#l00545">PxContactPair::contactImpulses</a>.</p>

<p>Referenced by <a class="el" href="PxSimulationEventCallback_8h-source.html#l00628">PxContactPair::extractContacts()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g67b3ce67bea6cdb19619bed61f9e7641"></a><!-- doxytag: member="PxSceneDesc::isValid" ref="g67b3ce67bea6cdb19619bed61f9e7641" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE bool PxSceneDesc::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the descriptor is valid. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the current settings are valid. </dd></dl>

<p>References <a class="el" href="PxSceneDesc_8h-source.html#l00660">PxSceneDesc::bounceThresholdVelocity</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00686">PxSceneDesc::ccdMaxSeparation</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00849">PxSceneDesc::contactReportStreamBufferSize</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00710">PxSceneDesc::cpuDispatcher</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00750">PxSceneDesc::dynamicTreeRebuildRateHint</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00215">PxSceneFlag::eADAPTIVE_FORCE</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00072">PxPruningStructureType::eDYNAMIC_AABB_TREE</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00296">PxSceneFlag::eENABLE_STABILIZATION</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00073">PxPruningStructureType::eSTATIC_AABB_TREE</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00581">PxSceneDesc::filterShader</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00561">PxSceneDesc::filterShaderData</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00570">PxSceneDesc::filterShaderDataSize</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00703">PxSceneDesc::flags</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00675">PxSceneDesc::frictionOffsetThreshold</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00898">PxSceneDesc::gpuMaxNumPartitions</a>, <a class="el" href="PxBounds3_8h-source.html#l00467">PxBounds3::isValid()</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00460">PxSceneLimits::isValid()</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00637">PxSceneDesc::limits</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00816">PxSceneDesc::maxNbContactDataBlocks</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00796">PxSceneDesc::nbContactDataBlocks</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00885">PxSceneDesc::sanityBounds</a>, <a class="el" href="PxSceneDesc_8h-source.html#l00726">PxSceneDesc::staticStructure</a>, and <a class="el" href="PxSceneDesc_8h-source.html#l00874">PxSceneDesc::wakeCounterResetValue</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0fdb519fc67615aed0a8548b8f6fcab1"></a><!-- doxytag: member="PxSceneLimits::isValid" ref="g0fdb519fc67615aed0a8548b8f6fcab1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE bool PxSceneLimits::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the descriptor is valid. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the current settings are valid. </dd></dl>

<p>References <a class="el" href="PxSceneDesc_8h-source.html#l00421">PxSceneLimits::maxNbRegions</a>.</p>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">PxSceneDesc::isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6c065d106bbbace6f2cc1d6f321af6bb"></a><!-- doxytag: member="PxBatchQueryDesc::isValid" ref="g6c065d106bbbace6f2cc1d6f321af6bb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE bool PxBatchQueryDesc::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="PxBatchQueryDesc_8h-source.html#l00230">PxBatchQueryDesc::filterShaderData</a>, and <a class="el" href="PxBatchQueryDesc_8h-source.html#l00239">PxBatchQueryDesc::filterShaderDataSize</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7c50eeff3e586897d4441a18e43b7237"></a><!-- doxytag: member="PxBatchQueryDesc::PxBatchQueryDesc" ref="g7c50eeff3e586897d4441a18e43b7237" args="(PxU32 maxRaycastsPerExecute, PxU32 maxSweepsPerExecute, PxU32 maxOverlapsPerExecute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxBatchQueryDesc::PxBatchQueryDesc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxRaycastsPerExecute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxSweepsPerExecute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxOverlapsPerExecute</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a batch query with specified maximum number of queries per batch. 
<p>
If the number of raycasts/sweeps/overlaps per execute exceeds the limit, the query will be discarded with a warning.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxRaycastsPerExecute</em>&nbsp;</td><td>Maximum number of raycast() calls allowed before execute() call. This has to match the amount of memory allocated for <a class="el" href="structPxBatchQueryMemory.html#194b1ad50e68760d9499e253151c7d31" title="The pointer to the user-allocated buffer for results of raycast queries in corresponding...">PxBatchQueryMemory::userRaycastResultBuffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSweepsPerExecute</em>&nbsp;</td><td>Maximum number of sweep() calls allowed before execute() call. This has to match the amount of memory allocated for <a class="el" href="structPxBatchQueryMemory.html#21e15901b0b7e88fe8f59ea06dcff69e" title="The pointer to the user-allocated buffer for results of sweep queries in corresponding...">PxBatchQueryMemory::userSweepResultBuffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxOverlapsPerExecute</em>&nbsp;</td><td>Maximum number of overlap() calls allowed before execute() call. This has to match the amount of memory allocated for <a class="el" href="structPxBatchQueryMemory.html#7c54ac68c7049897accaa4520c418d1e" title="The pointer to the user-allocated buffer for results of overlap queries in corresponding...">PxBatchQueryMemory::userOverlapResultBuffer</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd63c429157f9c8c87fcd0ea2f9b79f66"></a><!-- doxytag: member="PxPhysics.h::PxCreateBasePhysics" ref="gd63c429157f9c8c87fcd0ea2f9b79f66" args="(physx::PxU32 version, physx::PxFoundation &amp;foundation, const physx::PxTolerancesScale &amp;scale, bool trackOutstandingAllocations=false, physx::PxPvd *pvd=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API physx::PxPhysics* PX_CALL_CONV PxCreateBasePhysics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxFoundation &amp;&nbsp;</td>
          <td class="paramname"> <em>foundation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const physx::PxTolerancesScale &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>trackOutstandingAllocations</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxPvd *&nbsp;</td>
          <td class="paramname"> <em>pvd</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of the physics SDK with minimal additional components registered. 
<p>
Creates an instance of this class. May not be a class member to avoid name mangling. Pass the constant PX_PHYSICS_VERSION as the argument. There may be only one instance of this class per process. Calling this method after an instance has been created already will result in an error message and NULL will be returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>Version number we are expecting(should be PX_PHYSICS_VERSION) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>foundation</em>&nbsp;</td><td>Foundation instance (see <a class="el" href="classPxFoundation.html" title="Foundation SDK singleton class.">PxFoundation</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>values used to determine default tolerances for objects at creation time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trackOutstandingAllocations</em>&nbsp;</td><td>true if you want to track memory allocations so a debugger connection partway through your physics simulation will get an accurate map of everything that has been allocated so far. This could have a memory and performance impact on your simulation hence it defaults to off. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvd</em>&nbsp;</td><td>When pvd points to a valid <a class="el" href="classPxPvd.html" title="PxPvd is the top-level class for the PVD framework, and the main customer interface...">PxPvd</a> instance (PhysX Visual Debugger), a connection to the specified <a class="el" href="classPxPvd.html" title="PxPvd is the top-level class for the PVD framework, and the main customer interface...">PxPvd</a> instance is created. If pvd is NULL no connection will be attempted. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> instance on success, NULL if operation failed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, <a class="el" href="classPxFoundation.html" title="Foundation SDK singleton class.">PxFoundation</a>, <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a>, PxProfileZoneManager, <a class="el" href="classPxPvd.html" title="PxPvd is the top-level class for the PVD framework, and the main customer interface...">PxPvd</a> </dd></dl>

<p>Referenced by <a class="el" href="PxPhysics_8h-source.html#l00822">PxCreatePhysics()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8039bfec65da68b2294a97175ddb2c66"></a><!-- doxytag: member="PxPhysics.h::PxCreatePhysics" ref="g8039bfec65da68b2294a97175ddb2c66" args="(physx::PxU32 version, physx::PxFoundation &amp;foundation, const physx::PxTolerancesScale &amp;scale, bool trackOutstandingAllocations=false, physx::PxPvd *pvd=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE physx::PxPhysics* PxCreatePhysics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxFoundation &amp;&nbsp;</td>
          <td class="paramname"> <em>foundation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const physx::PxTolerancesScale &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>trackOutstandingAllocations</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxPvd *&nbsp;</td>
          <td class="paramname"> <em>pvd</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of the physics SDK. 
<p>
Creates an instance of this class. May not be a class member to avoid name mangling. Pass the constant PX_PHYSICS_VERSION as the argument. There may be only one instance of this class per process. Calling this method after an instance has been created already will result in an error message and NULL will be returned.<p>
Calling this will register all optional code modules (Articulations, HeightFields, Cloth and Particles), preparing them for use. If you do not need some of these modules, consider calling <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> instead and registering needed modules manually. If you would like to use the unified heightfield collision code instead, it is permitted to follow this call with a call to <a class="el" href="group__physics.html#g6adbba7aad2d451e684110269dddd720" title="Enables the usage of the unified heightfield feature.">PxRegisterUnifiedHeightFields()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>Version number we are expecting(should be PX_PHYSICS_VERSION) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>foundation</em>&nbsp;</td><td>Foundation instance (see <a class="el" href="classPxFoundation.html" title="Foundation SDK singleton class.">PxFoundation</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>values used to determine default tolerances for objects at creation time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trackOutstandingAllocations</em>&nbsp;</td><td>true if you want to track memory allocations so a debugger connection partway through your physics simulation will get an accurate map of everything that has been allocated so far. This could have a memory and performance impact on your simulation hence it defaults to off. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvd</em>&nbsp;</td><td>When pvd points to a valid <a class="el" href="classPxPvd.html" title="PxPvd is the top-level class for the PVD framework, and the main customer interface...">PxPvd</a> instance (PhysX Visual Debugger), a connection to the specified <a class="el" href="classPxPvd.html" title="PxPvd is the top-level class for the PVD framework, and the main customer interface...">PxPvd</a> instance is created. If pvd is NULL no connection will be attempted. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> instance on success, NULL if operation failed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics</a>, <a class="el" href="group__physics.html#g92144d0904f8a696f85737c576b88d9f" title="Enables the usage of the articulations feature. This function is called automatically...">PxRegisterArticulations</a>, <a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1" title="Enables the usage of the heightfield feature.">PxRegisterHeightFields</a>, <a class="el" href="group__physics.html#ge2faa96309a4fb0cbfcd512d2431fc82" title="Enables the usage of the cloth feature. This function is called automatically inside...">PxRegisterCloth</a>, <a class="el" href="group__physics.html#g197726c3bfa1abc6fbe43875c2483b38" title="Enables the usage of the particles feature. This function is called automatically...">PxRegisterParticles</a> </dd></dl>

<p>References <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66">PxCreateBasePhysics()</a>, <a class="el" href="group__physics.html#g92144d0904f8a696f85737c576b88d9f">PxRegisterArticulations()</a>, <a class="el" href="group__physics.html#ge2faa96309a4fb0cbfcd512d2431fc82">PxRegisterCloth()</a>, <a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1">PxRegisterHeightFields()</a>, and <a class="el" href="group__physics.html#g197726c3bfa1abc6fbe43875c2483b38">PxRegisterParticles()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4608473fcea7bec808f20e2e9ed4bbf1"></a><!-- doxytag: member="PxSpatialIndex.h::PxCreateSpatialIndex" ref="g4608473fcea7bec808f20e2e9ed4bbf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED PX_PHYSX_CORE_API <a class="el" href="classPxSpatialIndex.html">PxSpatialIndex</a>* PxCreateSpatialIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a spatial index. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Spatial index feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSpatialIndex.html" title="provides direct access to PhysX&#39; Spatial Query engine">PxSpatialIndex</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g396ee882c9ea7398e48bb9e0375a567c"></a><!-- doxytag: member="PxFiltering.h::PxFilterObjectIsKinematic" ref="g396ee882c9ea7398e48bb9e0375a567c" args="(PxFilterObjectAttributes attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE bool PxFilterObjectIsKinematic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a>&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies whether the collision object belongs to a kinematic rigid body. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>The filter attribute of a collision pair object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the object belongs to a kinematic rigid body, else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596bd76e6985e9db78efb7a66148ea4c212" title="Enables kinematic mode for the actor.">PxRigidBodyFlag::eKINEMATIC</a> </dd></dl>

<p>References <a class="el" href="PxFiltering_8h-source.html#l00502">PxFilterObjectFlag::eKINEMATIC</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbd83d1895d4f68e1e3e0f406c4c8ce65"></a><!-- doxytag: member="PxFiltering.h::PxFilterObjectIsTrigger" ref="gbd83d1895d4f68e1e3e0f406c4c8ce65" args="(PxFilterObjectAttributes attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE bool PxFilterObjectIsTrigger           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a>&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies whether the collision object is a trigger shape. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>The filter attribute of a collision pair object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the object is a trigger shape, else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1aef2b90024dc86be72b68bbaf94a5821d" title="The shape is a trigger which can send reports whenever other shapes enter/leave its...">PxShapeFlag::eTRIGGER_SHAPE</a> </dd></dl>

<p>References <a class="el" href="PxFiltering_8h-source.html#l00503">PxFilterObjectFlag::eTRIGGER</a>.</p>

</div>
</div><p>
<a class="anchor" name="g479e145e0c33b0708ec9dd997480294a"></a><!-- doxytag: member="PxFiltering.h::PxGetFilterObjectType" ref="g479e145e0c33b0708ec9dd997480294a" args="(PxFilterObjectAttributes attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE <a class="el" href="structPxFilterObjectType.html#6b94c22981119369d08ce8b13838a3cf">PxFilterObjectType::Enum</a> PxGetFilterObjectType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a>&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract filter object type from the filter attributes of a collision pair object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>attr</em>&nbsp;</td><td>The filter attribute of a collision pair object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of the collision pair object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxFilterObjectType.html" title="Identifies each type of filter object.">PxFilterObjectType</a> </dd></dl>

<p>References <a class="el" href="PxFiltering_8h-source.html#l00489">PxFilterObjectType::eMAX_TYPE_COUNT</a>.</p>

</div>
</div><p>
<a class="anchor" name="g824f991be62d7c28eadf32316562408f"></a><!-- doxytag: member="PxPhysics.h::PxGetPhysics" ref="g824f991be62d7c28eadf32316562408f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API physx::PxPhysics&amp; PX_CALL_CONV PxGetPhysics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the Physics SDK after it has been created. 
<p>
Before using this function the user must call <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The behavior of this method is undefined if the Physics SDK instance has not been created already. </dd></dl>

<p>Referenced by <a class="el" href="PxRigidActorExt_8h-source.html#l00086">PxRigidActorExt::createExclusiveShape()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g92144d0904f8a696f85737c576b88d9f"></a><!-- doxytag: member="PxPhysics.h::PxRegisterArticulations" ref="g92144d0904f8a696f85737c576b88d9f" args="(physx::PxPhysics &amp;physics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API void PX_CALL_CONV PxRegisterArticulations           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the usage of the articulations feature. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use articulations. In this case the linker should strip out the relevant implementation code from the library. If you need to use articulations but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call. 
<p>

<p>Referenced by <a class="el" href="PxPhysics_8h-source.html#l00822">PxCreatePhysics()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge2faa96309a4fb0cbfcd512d2431fc82"></a><!-- doxytag: member="PxPhysics.h::PxRegisterCloth" ref="ge2faa96309a4fb0cbfcd512d2431fc82" args="(physx::PxPhysics &amp;physics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED PX_C_EXPORT PX_PHYSX_CORE_API void PX_CALL_CONV PxRegisterCloth           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the usage of the cloth feature. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use cloth. In this case the linker should strip out the relevant implementation code from the library. If you need to use cloth but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

<p>Referenced by <a class="el" href="PxPhysics_8h-source.html#l00822">PxCreatePhysics()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge3a84455caaa6a7de67513ea29a315e1"></a><!-- doxytag: member="PxPhysics.h::PxRegisterHeightFields" ref="ge3a84455caaa6a7de67513ea29a315e1" args="(physx::PxPhysics &amp;physics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API void PX_CALL_CONV PxRegisterHeightFields           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the usage of the heightfield feature. 
<p>
This call will link the default 'unified' implementation of heightfields which is identical to the narrow phase of triangle meshes. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>.<p>
On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use heightfields. In this case the linker should strip out the relevant implementation code from the library. If you need to use heightfield but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call.<p>
You must call this function at a time where no <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> instance exists, typically before calling <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene()</a>. This is to prevent a change to the heightfield implementation code at runtime which would have undefined results.<p>
Calling <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then attempting to create a heightfield shape without first calling <a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1" title="Enables the usage of the heightfield feature.">PxRegisterHeightFields()</a>, <a class="el" href="group__physics.html#g6adbba7aad2d451e684110269dddd720" title="Enables the usage of the unified heightfield feature.">PxRegisterUnifiedHeightFields()</a> or <a class="el" href="group__physics.html#g3a556a2d568cf1f36726d099bb21abd4" title="Enables the usage of the legacy heightfield feature.">PxRegisterLegacyHeightFields()</a> will result in an error. 
<p>Referenced by <a class="el" href="PxPhysics_8h-source.html#l00822">PxCreatePhysics()</a>, and <a class="el" href="PxPhysics_8h-source.html#l00740">PxRegisterUnifiedHeightFields()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3a556a2d568cf1f36726d099bb21abd4"></a><!-- doxytag: member="PxPhysics.h::PxRegisterLegacyHeightFields" ref="g3a556a2d568cf1f36726d099bb21abd4" args="(physx::PxPhysics &amp;physics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED PX_C_EXPORT PX_PHYSX_CORE_API void PX_CALL_CONV PxRegisterLegacyHeightFields           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the usage of the legacy heightfield feature. 
<p>
This call will link the default 'legacy' implementation of heightfields which uses a special purpose collison code path distinct from triangle meshes.<p>
You must call this function at a time where no <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> instance exists, typically before calling <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene()</a>. This is to prevent a change to the heightfield implementation code at runtime which would have undefined results.<p>
Calling <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then attempting to create a heightfield shape without first calling <a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1" title="Enables the usage of the heightfield feature.">PxRegisterHeightFields()</a>, <a class="el" href="group__physics.html#g3a556a2d568cf1f36726d099bb21abd4" title="Enables the usage of the legacy heightfield feature.">PxRegisterLegacyHeightFields()</a> or <a class="el" href="group__physics.html#g6adbba7aad2d451e684110269dddd720" title="Enables the usage of the unified heightfield feature.">PxRegisterUnifiedHeightFields()</a> will result in an error. 
</div>
</div><p>
<a class="anchor" name="g197726c3bfa1abc6fbe43875c2483b38"></a><!-- doxytag: member="PxPhysics.h::PxRegisterParticles" ref="g197726c3bfa1abc6fbe43875c2483b38" args="(physx::PxPhysics &amp;physics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED PX_C_EXPORT PX_PHYSX_CORE_API void PX_CALL_CONV PxRegisterParticles           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the usage of the particles feature. This function is called automatically inside <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. (deprecated) On resource constrained platforms, it is possible to call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> and then NOT call this function to save on code memory if your application does not use particles. In this case the linker should strip out the relevant implementation code from the library. If you need to use particles but not some other optional component, you shoud call <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> followed by this call. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>The PhysX particle feature has been deprecated in PhysX version 3.4 </dd></dl>

<p>Referenced by <a class="el" href="PxPhysics_8h-source.html#l00822">PxCreatePhysics()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6adbba7aad2d451e684110269dddd720"></a><!-- doxytag: member="PxPhysics.h::PxRegisterUnifiedHeightFields" ref="g6adbba7aad2d451e684110269dddd720" args="(physx::PxPhysics &amp;physics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED PX_INLINE void PX_CALL_CONV PxRegisterUnifiedHeightFields           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the usage of the unified heightfield feature. 
<p>
This method is deprecated and provided only for compatibility with legacy applications. It will be removed in future releases. Call PxRegisterHeightFields instead, which also registers unified heightfields. 
<p>References <a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1">PxRegisterHeightFields()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8c083fd86a8c52ff269aa4dd3407127b"></a><!-- doxytag: member="PxSceneDesc::PxSceneDesc" ref="g8c083fd86a8c52ff269aa4dd3407127b" args="(const PxTolerancesScale &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxSceneDesc::PxSceneDesc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constructor sets to default. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scale</em>&nbsp;</td><td>scale values for the tolerances in the scene, these must be the same values passed into <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. The affected tolerances are bounceThresholdVelocity and frictionOffsetThreshold.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> <a class="el" href="classPxSceneDesc.html#bc7769532392c8e47ec4580677145e34" title="A contact with a relative velocity below this will not bounce. A typical value for...">bounceThresholdVelocity</a> <a class="el" href="classPxSceneDesc.html#f707e0c97624aaf6fa9ab2e82aadbecf" title="A threshold of contact separation distance used to decide if a contact point will...">frictionOffsetThreshold</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01005">PxSceneDesc::setToDefault()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd36024f1760b55b0947dc0d91e080bd7"></a><!-- doxytag: member="PxSceneLimits::PxSceneLimits" ref="gd36024f1760b55b0947dc0d91e080bd7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxSceneLimits::PxSceneLimits           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constructor sets to default 
<p>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l00455">PxSceneLimits::setToDefault()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga7375184ba494172fa7677dae44bd9a8"></a><!-- doxytag: member="PxSceneDesc::setToDefault" ref="ga7375184ba494172fa7677dae44bd9a8" args="(const PxTolerancesScale &amp;scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE void PxSceneDesc::setToDefault           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scale</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(re)sets the structure to the default. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scale</em>&nbsp;</td><td>scale values for the tolerances in the scene, these must be the same values passed into <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>. The affected tolerances are bounceThresholdVelocity and frictionOffsetThreshold.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> <a class="el" href="classPxSceneDesc.html#bc7769532392c8e47ec4580677145e34" title="A contact with a relative velocity below this will not bounce. A typical value for...">bounceThresholdVelocity</a> <a class="el" href="classPxSceneDesc.html#f707e0c97624aaf6fa9ab2e82aadbecf" title="A threshold of contact separation distance used to decide if a contact point will...">frictionOffsetThreshold</a> </dd></dl>

<p>References <a class="el" href="PxSceneDesc_8h-source.html#l00953">PxSceneDesc::PxSceneDesc()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge673c050f15b0fc912860adbb3394e34"></a><!-- doxytag: member="PxSceneLimits::setToDefault" ref="ge673c050f15b0fc912860adbb3394e34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE void PxSceneLimits::setToDefault           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(re)sets the structure to the default 
<p>

<p>References <a class="el" href="PxSceneDesc_8h-source.html#l00442">PxSceneLimits::PxSceneLimits()</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="gec480d86354043f6c7cb13b237914e7f"></a><!-- doxytag: member="PxFiltering.h::INVALID_FILTER_PAIR_INDEX" ref="gec480d86354043f6c7cb13b237914e7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="group__physics.html#gec480d86354043f6c7cb13b237914e7f">INVALID_FILTER_PAIR_INDEX</a> = 0xffffffff<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g91f52ef3693d57cc073138122d8e24ec"></a><!-- doxytag: member="PxConstraintDesc.h::PX_ALIGN_SUFFIX" ref="g91f52ef3693d57cc073138122d8e24ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxModifiableContact.html">PxModifiableContact</a> <a class="el" href="group__geomutils.html#gaad56fd2611227e004393c504092bdac">PX_ALIGN_SUFFIX</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A constraint. 
<p>
A modifiable contact point. This has additional fields per-contact to permit modification by user.<p>
Contact point data including face (feature) indices.<p>
Header for contact patch where all points share same material and normal.<p>
A constraint is expressed as a set of 1-dimensional constraint rows which define the required constraint on the objects' velocities.<p>
Each constraint is either a hard constraint or a spring. We define the velocity at the constraint to be the quantity<p>
v = body0vel.dot(lin0,ang0) - body1vel.dot(lin1, ang1)<p>
For a hard constraint, the solver attempts to generate<p>
1. a set of velocities for the objects which, when integrated, respect the constraint errors:<p>
v + (geometricError / timestep) = velocityTarget<p>
2. a set of velocities for the objects which respect the constraints:<p>
v = velocityTarget<p>
Hard constraints support restitution: if the impact velocity exceeds the bounce threshold, then the target velocity of the constraint will be set to restitution * -v<p>
Alternatively, the solver can attempt to resolve the velocity constraint as an implicit spring:<p>
F = stiffness * -geometricError + damping * (velocityTarget - v)<p>
where F is the constraint force or acceleration. Springs are fully implicit: that is, the force or acceleration is a function of the position and velocity after the solve.<p>
All constraints support limits on the minimum or maximum impulse applied.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not all fields are currently exposed to the user. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc5525ef79da01168ea797595a3e4dac0"></a><!-- doxytag: member="PxSpatialIndex.h::PX_SPATIAL_INDEX_INVALID_ITEM_ID" ref="gc5525ef79da01168ea797595a3e4dac0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__physics.html#ga07c59a855d77f9e5f7bc2fc3cf8b816">PxSpatialIndexItemId</a> <a class="el" href="group__physics.html#gc5525ef79da01168ea797595a3e4dac0">PX_SPATIAL_INDEX_INVALID_ITEM_ID</a> = 0xffffffff<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
