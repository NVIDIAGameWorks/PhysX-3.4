<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: Extensions</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Extensions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSerializer.html">PxSerializer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialization interface class.  <a href="classPxSerializer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSerializerDefaultAdapter.html">PxSerializerDefaultAdapter&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default <a class="el" href="classPxSerializer.html" title="Serialization interface class.">PxSerializer</a> implementation.  <a href="classPxSerializerDefaultAdapter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConverterReportMode.html">PxConverterReportMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBinaryConverter.html">PxBinaryConverter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary converter for serialized streams.  <a href="classPxBinaryConverter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBroadPhaseExt.html">PxBroadPhaseExt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothFabricCooker.html">PxClothFabricCooker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxCollectionExt.html">PxCollectionExt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxConstraintExtIDs.html">PxConstraintExtIDs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unique identifiers for extensions classes which implement a constraint based on <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a>.  <a href="structPxConstraintExtIDs.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxD6Axis.html">PxD6Axis</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to specify one of the degrees of freedom of a D6 joint.  <a href="structPxD6Axis.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxD6Motion.html">PxD6Motion</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to specify the range of motions allowed for a degree of freedom in a D6 joint.  <a href="structPxD6Motion.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxD6Drive.html">PxD6Drive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to specify which axes of a D6 joint are driven.  <a href="structPxD6Drive.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxD6JointDriveFlag.html">PxD6JointDriveFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flags for configuring the drive model of a <a class="el" href="classPxD6Joint.html" title="A D6 joint is a general constraint between two actors.">PxD6Joint</a>  <a href="structPxD6JointDriveFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxD6JointDrive.html">PxD6JointDrive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">parameters for configuring the drive model of a <a class="el" href="classPxD6Joint.html" title="A D6 joint is a general constraint between two actors.">PxD6Joint</a>  <a href="classPxD6JointDrive.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxD6Joint.html">PxD6Joint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A D6 joint is a general constraint between two actors.  <a href="classPxD6Joint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDefaultAllocator.html">PxDefaultAllocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of the allocator interface required by the SDK  <a href="classPxDefaultAllocator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDefaultCpuDispatcher.html">PxDefaultCpuDispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A default implementation for a CPU task dispatcher.  <a href="classPxDefaultCpuDispatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxGroupsMask.html">PxGroupsMask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">64-bit mask used for collision filtering.  <a href="classPxGroupsMask.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxFilterOp.html">PxFilterOp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collision filtering operations.  <a href="structPxFilterOp.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDefaultMemoryOutputStream.html">PxDefaultMemoryOutputStream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of a memory write stream  <a href="classPxDefaultMemoryOutputStream.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDefaultMemoryInputData.html">PxDefaultMemoryInputData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of a memory read stream  <a href="classPxDefaultMemoryInputData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDefaultFileOutputStream.html">PxDefaultFileOutputStream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of a file write stream  <a href="classPxDefaultFileOutputStream.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDefaultFileInputData.html">PxDefaultFileInputData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of a file read stream  <a href="classPxDefaultFileInputData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxDistanceJointFlag.html">PxDistanceJointFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">flags for configuring the drive of a <a class="el" href="classPxDistanceJoint.html" title="a joint that maintains an upper or lower bound (or both) on the distance between...">PxDistanceJoint</a>  <a href="structPxDistanceJointFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDistanceJoint.html">PxDistanceJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a joint that maintains an upper or lower bound (or both) on the distance between two points on different objects  <a href="classPxDistanceJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxFixedJoint.html">PxFixedJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fixed joint permits no relative movement between two bodies. ie the bodies are glued together.  <a href="classPxFixedJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxJointConcreteType.html">PxJointConcreteType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an enumeration of PhysX' built-in joint types  <a href="structPxJointConcreteType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxJointActorIndex.html">PxJointActorIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">an enumeration for specifying one or other of the actors referenced by a joint  <a href="structPxJointActorIndex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxJoint.html">PxJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a base interface providing common functionality for PhysX joints  <a href="classPxJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSpring.html">PxSpring</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxJointLimitParameters.html">PxJointLimitParameters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes the parameters for a joint limit.  <a href="classPxJointLimitParameters.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxJointLinearLimit.html">PxJointLinearLimit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a one-sided linear limit.  <a href="classPxJointLinearLimit.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxJointLinearLimitPair.html">PxJointLinearLimitPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a two-sided limit.  <a href="classPxJointLinearLimitPair.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxJointAngularLimitPair.html">PxJointAngularLimitPair</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxJointLimitCone.html">PxJointLimitCone</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes an elliptical conical joint limit. Note that very small or highly elliptical limit cones may result in jitter.  <a href="classPxJointLimitCone.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxMassProperties.html">PxMassProperties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class to compute and manipulate mass and inertia tensor properties.  <a href="classPxMassProperties.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxParticleExt.html">PxParticleExt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">extensions for the partice feature (deprecated)  <a href="classPxParticleExt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxPrismaticJointFlag.html">PxPrismaticJointFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags specific to the prismatic joint.  <a href="structPxPrismaticJointFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPrismaticJoint.html">PxPrismaticJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A prismatic joint permits relative translational movement between two bodies along an axis, but no relative rotational movement.  <a href="classPxPrismaticJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRaycastCCDManager.html">RaycastCCDManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raycast-CCD manager.  <a href="classRaycastCCDManager.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxRepXObject.html">PxRepXObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class containing the mapping of id to object, and type name.  <a href="structPxRepXObject.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxRepXInstantiationArgs.html">PxRepXInstantiationArgs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arguments required to instantiate a serializable object from RepX.  <a href="structPxRepXInstantiationArgs.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxRevoluteJointFlag.html">PxRevoluteJointFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags specific to the Revolute Joint.  <a href="structPxRevoluteJointFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRevoluteJoint.html">PxRevoluteJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A joint which behaves in a similar way to a hinge or axle.  <a href="classPxRevoluteJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActorExt.html">PxRigidActorExt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility functions for use with <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> and subclasses  <a href="classPxRigidActorExt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html">PxRigidBodyExt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility functions for use with <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> and subclasses  <a href="classPxRigidBodyExt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneQueryExt.html">PxSceneQueryExt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility functions for use with <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>, related to scene queries.  <a href="classPxSceneQueryExt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSerialization.html">PxSerialization</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility functions for serialization.  <a href="classPxSerialization.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShapeExt.html">PxShapeExt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility functions for use with <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>  <a href="classPxShapeExt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxSphericalJointFlag.html">PxSphericalJointFlag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags specific to the spherical joint.  <a href="structPxSphericalJointFlag.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSphericalJoint.html">PxSphericalJoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A joint which behaves in a similar way to a ball and socket.  <a href="classPxSphericalJoint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxMeshOverlapUtil.html">PxMeshOverlapUtil</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class to find mesh triangles touched by a specified geometry object.  <a href="classPxMeshOverlapUtil.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g8695b63c3fd0f8e29ecce92c64e8f79b">PX_NEW_SERIALIZER_ADAPTER</a>(x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preprocessor Macro to simplify adapter creation.  <a href="#g8695b63c3fd0f8e29ecce92c64e8f79b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf9d523f77e7143a4c7e49424d9f0081e">PX_DELETE_SERIALIZER_ADAPTER</a>(x)&nbsp;&nbsp;&nbsp;{ <a class="el" href="classPxSerializer.html">PxSerializer</a>* s = x; if (s) { s-&gt;~<a class="el" href="classPxSerializer.html">PxSerializer</a>(); PxGetFoundation().getAllocatorCallback().deallocate(s); } }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preprocessor Macro to simplify adapter deletion.  <a href="#gf9d523f77e7143a4c7e49424d9f0081e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gced14ebcd90bf2d866b38867cde959ae">PX_BINARY_SERIAL_VERSION</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxD6JointDriveFlag.html#0560fd8c87c7004eb8c52a17a549e42e">PxD6JointDriveFlag::Enum</a>, <br class="typebreak">
<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gdabf6cf5b61c51816897119d793d16b7">PxD6JointDriveFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g8e55355887d57086f097b0248b7ea768">PxFileHandle</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxDistanceJointFlag.html#739197f319da75b41a1f3fbcc39607d9">PxDistanceJointFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#ge24713c38834275bb67d41f03bcd28b5">PxDistanceJointFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxPrismaticJointFlag.html#d175483117d7036cc021df8ac7dc15f4">PxPrismaticJointFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf683a32f0fc263a83be447fac2879dac">PxPrismaticJointFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxRevoluteJointFlag.html#da2c678da47fe6828e338052480a40c8">PxRevoluteJointFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g064759e7f7a48b93670218bb400355e8">PxRevoluteJointFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structPxQueryHit.html">PxQueryHit</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g55259fcecc0dd432e8c97f80a1425aad">PxSceneQueryHit</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g4d19f53556b8b6114e8a359d326c6d10">PxSceneQueryFilterData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf9d442ec851f833a9276ddb7ea46dd23">PxSceneQueryFilterCallback</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structPxQueryCache.html">PxQueryCache</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g871e9d89cdf9bbab58883b5f0822b5c3">PxSceneQueryCache</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structPxHitFlag.html">PxHitFlag</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g8a87a0175a8d5014472d5e9eabef59d7">PxSceneQueryFlag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef PxHitFlags&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g2ddebd682bdb0bdb1db7ba113a93afe4">PxSceneQueryFlags</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classPxFlags.html">PxFlags</a><br class="typebreak">
&lt; <a class="el" href="structPxSphericalJointFlag.html#fc657f6cb078dd077c835e798ac56561">PxSphericalJointFlag::Enum</a>, <br class="typebreak">
PxU16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g4e2440ba605d9e05614c938fcb2e6fcb">PxSphericalJointFlags</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxClothFabric.html">PxClothFabric</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf39f6f4f4aa2bdadc81159d28a648c20">PxClothFabricCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, const <a class="el" href="classPxClothMeshDesc.html">PxClothMeshDesc</a> &amp;desc, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;gravity, bool useGeodesicTether=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a triangle mesh to a <a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a>.  <a href="#gf39f6f4f4aa2bdadc81159d28a648c20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g450abb675b283fd8031caf82e85844e2">PxFindFaceIndex</a> (const <a class="el" href="classPxConvexMeshGeometry.html">PxConvexMeshGeometry</a> &amp;convexGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;geomPose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;impactPos, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes closest polygon of the convex hull geometry for a given impact point and impact direction. When doing sweeps against a scene, one might want to delay the rather expensive computation of the hit face index for convexes until it is clear the information is really needed and then use this method to get the corresponding face index.  <a href="#g450abb675b283fd8031caf82e85844e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxD6Joint.html">PxD6Joint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g5d942bf8c3069024e50a8dd2254c390c">PxD6JointCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a D6 joint.  <a href="#g5d942bf8c3069024e50a8dd2254c390c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_FORCE_INLINE void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gd874c3dcee0d1f3ec91e1880a1f09582">platformAlignedAlloc</a> (size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_FORCE_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gea2576f54650c42280d79ce79ea1979a">platformAlignedFree</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxDefaultCpuDispatcher.html">PxDefaultCpuDispatcher</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g68e9b3c3ee8961234464d8eb0b64d5e3">PxDefaultCpuDispatcherCreate</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> numThreads, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *affinityMasks=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create default dispatcher, extensions SDK needs to be initialized first.  <a href="#g68e9b3c3ee8961234464d8eb0b64d5e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxFlags.html">PxFilterFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g587ba12f90f77543c3e4452abeb0f22f">PxDefaultSimulationFilterShader</a> (<a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attributes0, <a class="el" href="structPxFilterData.html">PxFilterData</a> filterData0, <a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a> attributes1, <a class="el" href="structPxFilterData.html">PxFilterData</a> filterData1, <a class="el" href="classPxFlags.html">PxPairFlags</a> &amp;pairFlags, const void *constantBlock, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> constantBlockSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of a simple filter shader that emulates PhysX 2.8.x filtering.  <a href="#g587ba12f90f77543c3e4452abeb0f22f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#ge13799b44f055e19212220bdff322597">PxGetGroupCollisionFlag</a> (const PxU16 group1, const PxU16 group2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if collision detection is performed between a pair of groups.  <a href="#ge13799b44f055e19212220bdff322597"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g8ced9dfabbe8811f9c5ea8933e1298f7">PxSetGroupCollisionFlag</a> (const PxU16 group1, const PxU16 group2, const bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies if collision should be performed by a pair of groups.  <a href="#g8ced9dfabbe8811f9c5ea8933e1298f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxU16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g0918cc645e6e95c3077a816ba33b42e9">PxGetGroup</a> (const <a class="el" href="classPxActor.html">PxActor</a> &amp;actor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="group__extensions.html#g0f895f83f81c371385418a3284d28070" title="Sets which collision group this actor is part of.">PxSetGroup()</a>.  <a href="#g0918cc645e6e95c3077a816ba33b42e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g0f895f83f81c371385418a3284d28070">PxSetGroup</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor, const PxU16 collisionGroup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets which collision group this actor is part of.  <a href="#g0f895f83f81c371385418a3284d28070"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gb5878e8b784c6c17d26a20bc202c4c0e">PxGetFilterOps</a> (<a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;op0, <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;op1, <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;op2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves filtering operation. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#gb5878e8b784c6c17d26a20bc202c4c0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g64679ee1d097cd1699fd8d3413ac2932">PxSetFilterOps</a> (const <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;op0, const <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;op1, const <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;op2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering operations. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#g64679ee1d097cd1699fd8d3413ac2932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g4ad1c1fb89841e9f9416530aed66170b">PxGetFilterBool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves filtering's boolean value. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#g4ad1c1fb89841e9f9416530aed66170b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf17024df6afd1cbab816914f25b33214">PxSetFilterBool</a> (const bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering's boolean value. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#gf17024df6afd1cbab816914f25b33214"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf61e11222319b3a664d8127c8b64bb98">PxGetFilterConstants</a> (<a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;c0, <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;c1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets filtering constant K0 and K1. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#gf61e11222319b3a664d8127c8b64bb98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g7f3ed5a3baab55369f7ee35e4e44cfb0">PxSetFilterConstants</a> (const <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;c0, const <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;c1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering's K0 and K1 value. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#g7f3ed5a3baab55369f7ee35e4e44cfb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxGroupsMask.html">PxGroupsMask</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g13ef0a91d385e0f45c1b73b3ffafa8dc">PxGetGroupsMask</a> (const <a class="el" href="classPxActor.html">PxActor</a> &amp;actor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets 64-bit mask used for collision filtering. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#g13ef0a91d385e0f45c1b73b3ffafa8dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g4e9876a60fc230eb433a6b3d77beaae9">PxSetGroupsMask</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor, const <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets 64-bit mask used for collision filtering. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.  <a href="#g4e9876a60fc230eb433a6b3d77beaae9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxDistanceJoint.html">PxDistanceJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gf7580a5a315137094cb676a7874c978a">PxDistanceJointCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a distance Joint.  <a href="#gf7580a5a315137094cb676a7874c978a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT bool PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g54f81dd3dbc77a3363357b5150dcba21">PxInitExtensions</a> (physx::PxPhysics &amp;physics, physx::PxPvd *pvd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the PhysXExtensions library.  <a href="#g54f81dd3dbc77a3363357b5150dcba21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT void PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g574914ae1ef022264d4338d355a50ed8">PxCloseExtensions</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the PhysXExtensions library.  <a href="#g574914ae1ef022264d4338d355a50ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxFixedJoint.html">PxFixedJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g17f2eab8a94d35778f2555a85c34ea7f">PxFixedJointCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a fixed joint.  <a href="#g17f2eab8a94d35778f2555a85c34ea7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT void PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g43cc950618f193fd1fdbde2f624e0e52">PxSetJointGlobalFrame</a> (physx::PxJoint &amp;joint, const physx::PxVec3 *wsAnchor, const physx::PxVec3 *wsAxis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to setup a joint's global frame.  <a href="#g43cc950618f193fd1fdbde2f624e0e52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxPrismaticJoint.html">PxPrismaticJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gef94272b3a37bbcce4008c1911a06b5c">PxPrismaticJointCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a prismatic joint.  <a href="#gef94272b3a37bbcce4008c1911a06b5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRevoluteJoint.html">PxRevoluteJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g4aa56f32cb1cb2245d1c0cde99d0af17">PxRevoluteJointCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a revolute joint.  <a href="#g4aa56f32cb1cb2245d1c0cde99d0af17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g6f8a1ee174c919242d7e5a00c57f0fdb">PxCreateDynamic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material, PxReal density, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;shapeOffset=<a class="el" href="classPxTransform.html">PxTransform</a>(PxIdentity))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">simple method to create a <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>.  <a href="#g6f8a1ee174c919242d7e5a00c57f0fdb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g868bf680832c3f47e924fd2da011957d">PxCreateDynamic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, <a class="el" href="classPxShape.html">PxShape</a> &amp;shape, PxReal density)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">simple method to create a <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>.  <a href="#g868bf680832c3f47e924fd2da011957d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gd2b49dd51647b7228668827c689bbb32">PxCreateKinematic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material, PxReal density, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;shapeOffset=<a class="el" href="classPxTransform.html">PxTransform</a>(PxIdentity))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">simple method to create a kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>.  <a href="#gd2b49dd51647b7228668827c689bbb32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g63356d306e103b6bf13dc7bf2ae233f6">PxCreateKinematic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, <a class="el" href="classPxShape.html">PxShape</a> &amp;shape, PxReal density)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">simple method to create a kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>.  <a href="#g63356d306e103b6bf13dc7bf2ae233f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g79da8a82087b6fe978e615f61118f03e">PxCreateStatic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;shapeOffset=<a class="el" href="classPxTransform.html">PxTransform</a>(PxIdentity))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">simple method to create a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>.  <a href="#g79da8a82087b6fe978e615f61118f03e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g5b375e0249df691cb6c9375fe3ce3eda">PxCreateStatic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, <a class="el" href="classPxShape.html">PxShape</a> &amp;shape)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">simple method to create a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>.  <a href="#g5b375e0249df691cb6c9375fe3ce3eda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g29519a6806bb5661fe1d0e0c78389520">PxCloneShape</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physicsSDK, const <a class="el" href="classPxShape.html">PxShape</a> &amp;shape, bool isExclusive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a shape by copying attributes from another shape  <a href="#g29519a6806bb5661fe1d0e0c78389520"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gda9542f6f10912eb3f3f89c1ea2f87e6">PxCloneStatic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physicsSDK, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, const <a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;actor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a static body by copying attributes from another rigid actor  <a href="#gda9542f6f10912eb3f3f89c1ea2f87e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gcef7efd5d06512fbf61e9810f46805c1">PxCloneDynamic</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physicsSDK, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;transform, const <a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a dynamic body by copying attributes from an existing body  <a href="#gcef7efd5d06512fbf61e9810f46805c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gbbffb883dd38c52aef27f7ea084a1cde">PxCreatePlane</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;sdk, const <a class="el" href="classPxPlane.html">PxPlane</a> &amp;plane, <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a plane actor. The plane equation is n.x + d = 0  <a href="#gbbffb883dd38c52aef27f7ea084a1cde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g34084817afc2cfd9f1bb9108c5244b08">PxScaleRigidActor</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;actor, PxReal scale, bool scaleMassProps=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scale a rigid actor by a uniform scale  <a href="#g34084817afc2cfd9f1bb9108c5244b08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT bool PX_CALL_CONV&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g0b02c67cce6515397bef82eba539a4d8">PxBuildSmoothNormals</a> (<a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a> nbTris, <a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a> nbVerts, const physx::PxVec3 *verts, const <a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a> *dFaces, const <a class="el" href="namespacephysx.html#9caf1cbcda071b6d2a9c069faa99da23">physx::PxU16</a> *wFaces, physx::PxVec3 *normals, bool flip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds smooth vertex normals over a mesh.  <a href="#g0b02c67cce6515397bef82eba539a4d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxSphericalJoint.html">PxSphericalJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g02d8221452498576e374288ef10b8dc9">PxSphericalJointCreate</a> (<a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;physics, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localFrame1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a spherical joint.  <a href="#g02d8221452498576e374288ef10b8dc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gdc8527630e57855176639ffc43028ef6">PxComputeMeshPenetration</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxIter, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;geomPose, const <a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;meshGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;meshPose, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an approximate minimum translational distance (MTD) between a geometry object and a mesh.  <a href="#gdc8527630e57855176639ffc43028ef6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g78a7fcf3e5c470de1083ada5fde8e32f">PxComputeTriangleMeshPenetration</a> (<a class="el" href="classPxVec3.html">PxVec3</a> &amp;direction, PxReal &amp;depth, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;geomPose, const <a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;meshGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;meshPose, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxIter, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *usedIter=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an approximate minimum translational distance (MTD) between a geometry object and a mesh.  <a href="#g78a7fcf3e5c470de1083ada5fde8e32f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#g0e11331d1427e0eb67f60b45b84e7053">PxComputeHeightFieldPenetration</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxIter, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;geomPose, const <a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;heightFieldGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;heightFieldPose, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an approximate minimum translational distance (MTD) between a geometry object and a heightfield.  <a href="#g0e11331d1427e0eb67f60b45b84e7053"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__extensions.html#gdf1d4e04d0c9587b111c3737c9789658">PxComputeHeightFieldPenetration</a> (<a class="el" href="classPxVec3.html">PxVec3</a> &amp;direction, PxReal &amp;depth, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;geomPose, const <a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;heightFieldGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;heightFieldPose, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxIter, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *usedIter=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes an approximate minimum translational distance (MTD) between a geometry object and a heightfield.  <a href="#gdf1d4e04d0c9587b111c3737c9789658"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="gced14ebcd90bf2d866b38867cde959ae"></a><!-- doxytag: member="PxSerialization.h::PX_BINARY_SERIAL_VERSION" ref="gced14ebcd90bf2d866b38867cde959ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_BINARY_SERIAL_VERSION&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
PX_BINARY_SERIAL_VERSION is used to specify the binary data format compatibility additionally to the physics sdk version. The binary format version is defined as "PX_PHYSICS_VERSION_MAJOR.PX_PHYSICS_VERSION_MINOR.PX_PHYSICS_VERSION_BUGFIX-PX_BINARY_SERIAL_VERSION". The following binary format versions are compatible with the current physics version: (no compatible versions)<p>
The PX_BINARY_SERIAL_VERSION for a given PhysX release is typically 0. If incompatible modifications are made to a customer specific branch the number should be increased. 
</div>
</div><p>
<a class="anchor" name="gf9d523f77e7143a4c7e49424d9f0081e"></a><!-- doxytag: member="PxSerializer.h::PX_DELETE_SERIALIZER_ADAPTER" ref="gf9d523f77e7143a4c7e49424d9f0081e" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_DELETE_SERIALIZER_ADAPTER          </td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{ <a class="el" href="classPxSerializer.html">PxSerializer</a>* s = x; if (s) { s-&gt;~<a class="el" href="classPxSerializer.html">PxSerializer</a>(); PxGetFoundation().getAllocatorCallback().deallocate(s); } }</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Preprocessor Macro to simplify adapter deletion. 
<p>

</div>
</div><p>
<a class="anchor" name="g8695b63c3fd0f8e29ecce92c64e8f79b"></a><!-- doxytag: member="PxSerializer.h::PX_NEW_SERIALIZER_ADAPTER" ref="g8695b63c3fd0f8e29ecce92c64e8f79b" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PX_NEW_SERIALIZER_ADAPTER          </td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">*<span class="keyword">new</span>( <a class="code" href="group__foundation.html#g2f06b47e22c6e93701d766444c67f3a6" title="Retrieves the Foundation SDK after it has been created.">PxGetFoundation</a>().getAllocatorCallback().allocate(<span class="keyword">sizeof</span>(<a class="code" href="classPxSerializerDefaultAdapter.html" title="Default PxSerializer implementation.">PxSerializerDefaultAdapter&lt;x&gt;</a>), \
    <span class="stringliteral">"PxSerializerDefaultAdapter"</span>,  __FILE__, __LINE__ )) <a class="code" href="classPxSerializerDefaultAdapter.html" title="Default PxSerializer implementation.">PxSerializerDefaultAdapter&lt;x&gt;</a>(#x)
</pre></div>Preprocessor Macro to simplify adapter creation. 
<p>
Note: that the allocator used for creation needs to match with the one used in PX_DELETE_SERIALIZER_ADAPTER. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gdabf6cf5b61c51816897119d793d16b7"></a><!-- doxytag: member="PxD6Joint.h::PxD6JointDriveFlags" ref="gdabf6cf5b61c51816897119d793d16b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxD6JointDriveFlag.html#0560fd8c87c7004eb8c52a17a549e42e">PxD6JointDriveFlag::Enum</a>, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&gt; <a class="el" href="classPxFlags.html">PxD6JointDriveFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ge24713c38834275bb67d41f03bcd28b5"></a><!-- doxytag: member="PxDistanceJoint.h::PxDistanceJointFlags" ref="ge24713c38834275bb67d41f03bcd28b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxDistanceJointFlag.html#739197f319da75b41a1f3fbcc39607d9">PxDistanceJointFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxDistanceJointFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g8e55355887d57086f097b0248b7ea768"></a><!-- doxytag: member="PxDefaultStreams.h::PxFileHandle" ref="g8e55355887d57086f097b0248b7ea768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FILE* <a class="el" href="group__extensions.html#g8e55355887d57086f097b0248b7ea768">PxFileHandle</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gf683a32f0fc263a83be447fac2879dac"></a><!-- doxytag: member="PxPrismaticJoint.h::PxPrismaticJointFlags" ref="gf683a32f0fc263a83be447fac2879dac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxPrismaticJointFlag.html#d175483117d7036cc021df8ac7dc15f4">PxPrismaticJointFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxPrismaticJointFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g064759e7f7a48b93670218bb400355e8"></a><!-- doxytag: member="PxRevoluteJoint.h::PxRevoluteJointFlags" ref="g064759e7f7a48b93670218bb400355e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxRevoluteJointFlag.html#da2c678da47fe6828e338052480a40c8">PxRevoluteJointFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxRevoluteJointFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g871e9d89cdf9bbab58883b5f0822b5c3"></a><!-- doxytag: member="PxSceneQueryExt.h::PxSceneQueryCache" ref="g871e9d89cdf9bbab58883b5f0822b5c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structPxQueryCache.html">PxQueryCache</a> <a class="el" href="structPxQueryCache.html">PxSceneQueryCache</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="gf9d442ec851f833a9276ddb7ea46dd23"></a><!-- doxytag: member="PxSceneQueryExt.h::PxSceneQueryFilterCallback" ref="gf9d442ec851f833a9276ddb7ea46dd23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> <a class="el" href="classPxQueryFilterCallback.html">PxSceneQueryFilterCallback</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g4d19f53556b8b6114e8a359d326c6d10"></a><!-- doxytag: member="PxSceneQueryExt.h::PxSceneQueryFilterData" ref="g4d19f53556b8b6114e8a359d326c6d10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> <a class="el" href="structPxQueryFilterData.html">PxSceneQueryFilterData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g8a87a0175a8d5014472d5e9eabef59d7"></a><!-- doxytag: member="PxSceneQueryExt.h::PxSceneQueryFlag" ref="g8a87a0175a8d5014472d5e9eabef59d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structPxHitFlag.html">PxHitFlag</a> <a class="el" href="structPxHitFlag.html">PxSceneQueryFlag</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g2ddebd682bdb0bdb1db7ba113a93afe4"></a><!-- doxytag: member="PxSceneQueryExt.h::PxSceneQueryFlags" ref="g2ddebd682bdb0bdb1db7ba113a93afe4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PxHitFlags <a class="el" href="group__extensions.html#g2ddebd682bdb0bdb1db7ba113a93afe4">PxSceneQueryFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g55259fcecc0dd432e8c97f80a1425aad"></a><!-- doxytag: member="PxSceneQueryExt.h::PxSceneQueryHit" ref="g55259fcecc0dd432e8c97f80a1425aad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structPxQueryHit.html">PxQueryHit</a> <a class="el" href="structPxQueryHit.html">PxSceneQueryHit</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g4e2440ba605d9e05614c938fcb2e6fcb"></a><!-- doxytag: member="PxSphericalJoint.h::PxSphericalJointFlags" ref="g4e2440ba605d9e05614c938fcb2e6fcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classPxFlags.html">PxFlags</a>&lt;<a class="el" href="structPxSphericalJointFlag.html#fc657f6cb078dd077c835e798ac56561">PxSphericalJointFlag::Enum</a>, PxU16&gt; <a class="el" href="classPxFlags.html">PxSphericalJointFlags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gd874c3dcee0d1f3ec91e1880a1f09582"></a><!-- doxytag: member="PxDefaultAllocator.h::platformAlignedAlloc" ref="gd874c3dcee0d1f3ec91e1880a1f09582" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_FORCE_INLINE void* platformAlignedAlloc           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="PxDefaultAllocator_8h-source.html#l00092">PxDefaultAllocator::allocate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gea2576f54650c42280d79ce79ea1979a"></a><!-- doxytag: member="PxDefaultAllocator.h::platformAlignedFree" ref="gea2576f54650c42280d79ce79ea1979a" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_FORCE_INLINE void platformAlignedFree           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="PxDefaultAllocator_8h-source.html#l00099">PxDefaultAllocator::deallocate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0b02c67cce6515397bef82eba539a4d8"></a><!-- doxytag: member="PxSmoothNormals.h::PxBuildSmoothNormals" ref="g0b02c67cce6515397bef82eba539a4d8" args="(physx::PxU32 nbTris, physx::PxU32 nbVerts, const physx::PxVec3 *verts, const physx::PxU32 *dFaces, const physx::PxU16 *wFaces, physx::PxVec3 *normals, bool flip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT bool PX_CALL_CONV PxBuildSmoothNormals           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const physx::PxVec3 *&nbsp;</td>
          <td class="paramname"> <em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacephysx.html#9b7fbd746d18bf5b6545713a8d818f41">physx::PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>dFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacephysx.html#9caf1cbcda071b6d2a9c069faa99da23">physx::PxU16</a> *&nbsp;</td>
          <td class="paramname"> <em>wFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxVec3 *&nbsp;</td>
          <td class="paramname"> <em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flip</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds smooth vertex normals over a mesh. 
<p>
<ul>
<li>"smooth" because smoothing groups are not supported here</li><li>takes angles into account for correct cube normals computation</li></ul>
<p>
To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to wFaces and set dFaces to zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbTris</em>&nbsp;</td><td>Number of triangles </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbVerts</em>&nbsp;</td><td>Number of vertices </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>verts</em>&nbsp;</td><td>Array of vertices </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dFaces</em>&nbsp;</td><td>Array of dword triangle indices, or null </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wFaces</em>&nbsp;</td><td>Array of word triangle indices, or null </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>normals</em>&nbsp;</td><td>Array of computed normals (assumes nbVerts vectors) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flip</em>&nbsp;</td><td>Flips the normals or not </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcef7efd5d06512fbf61e9810f46805c1"></a><!-- doxytag: member="PxSimpleFactory.h::PxCloneDynamic" ref="gcef7efd5d06512fbf61e9810f46805c1" args="(PxPhysics &amp;physicsSDK, const PxTransform &amp;transform, const PxRigidDynamic &amp;body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxCloneDynamic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physicsSDK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a dynamic body by copying attributes from an existing body 
<p>
The following properties are copied:<ul>
<li>shapes</li><li>actor flags and rigidDynamic flags</li><li>mass, moment of inertia, and center of mass frame</li><li>linear and angular velocity</li><li>linear and angular damping</li><li>maximum angular velocity</li><li>position and velocity solver iterations</li><li>maximum depenetration velocity</li><li>sleep threshold</li><li>contact report threshold</li><li>dominance group</li><li>owner client and client behavior bits</li><li>name pointer</li></ul>
<p>
The following are not copied and retain their default values:<ul>
<li>name</li><li>joints or observers</li><li>aggregate or scene membership</li><li>sleep timer</li><li>user data</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Transforms are not copied with bit-exact accuracy.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physicsSDK</em>&nbsp;</td><td><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> - the physics SDK used to allocate the rigid static </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>the rigid dynamic to clone. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the transform of the new dynamic</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the newly-created rigid static </dd></dl>

</div>
</div><p>
<a class="anchor" name="g29519a6806bb5661fe1d0e0c78389520"></a><!-- doxytag: member="PxSimpleFactory.h::PxCloneShape" ref="g29519a6806bb5661fe1d0e0c78389520" args="(PxPhysics &amp;physicsSDK, const PxShape &amp;shape, bool isExclusive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxShape.html">PxShape</a>* PxCloneShape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physicsSDK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxShape.html">PxShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isExclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a shape by copying attributes from another shape 
<p>
The function clones a <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. The following properties are copied:<ul>
<li>geometry</li><li>flags</li><li>materials</li><li>actor-local pose</li><li>contact offset</li><li>rest offset</li><li>simulation filter data</li><li>query filter data</li></ul>
<p>
The following are not copied and retain their default values:<ul>
<li>name</li><li>user data</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physicsSDK</em>&nbsp;</td><td>- the physics SDK used to allocate the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>the shape from which to take the attributes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isExclusive</em>&nbsp;</td><td>whether the new shape should be an exclusive or shared shape.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the newly-created rigid static </dd></dl>

</div>
</div><p>
<a class="anchor" name="gda9542f6f10912eb3f3f89c1ea2f87e6"></a><!-- doxytag: member="PxSimpleFactory.h::PxCloneStatic" ref="gda9542f6f10912eb3f3f89c1ea2f87e6" args="(PxPhysics &amp;physicsSDK, const PxTransform &amp;transform, const PxRigidActor &amp;actor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a>* PxCloneStatic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physicsSDK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a static body by copying attributes from another rigid actor 
<p>
The function clones a <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> or <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> as a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a>. A uniform scale is applied. The following properties are copied:<ul>
<li>shapes</li><li>actor flags</li><li>owner client and client behavior bits</li></ul>
<p>
The following are not copied and retain their default values:<ul>
<li>name</li><li>joints or observers</li><li>aggregate or scene membership</li><li>user data</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Transforms are not copied with bit-exact accuracy.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physicsSDK</em>&nbsp;</td><td>- the physics SDK used to allocate the rigid static </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>the rigid actor from which to take the attributes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the transform of the new static.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the newly-created rigid static </dd></dl>

</div>
</div><p>
<a class="anchor" name="g574914ae1ef022264d4338d355a50ed8"></a><!-- doxytag: member="PxExtensionsAPI.h::PxCloseExtensions" ref="g574914ae1ef022264d4338d355a50ed8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT void PX_CALL_CONV PxCloseExtensions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shut down the PhysXExtensions library. 
<p>
This function should be called to cleanly shut down the PhysXExtensions library before application exit.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is required to be called to release foundation usage.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g54f81dd3dbc77a3363357b5150dcba21" title="Initialize the PhysXExtensions library.">PxInitExtensions</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf39f6f4f4aa2bdadc81159d28a648c20"></a><!-- doxytag: member="PxClothFabricCooker.h::PxClothFabricCreate" ref="gf39f6f4f4aa2bdadc81159d28a648c20" args="(PxPhysics &amp;physics, const PxClothMeshDesc &amp;desc, const PxVec3 &amp;gravity, bool useGeodesicTether=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxClothFabric.html">PxClothFabric</a>* PxClothFabricCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxClothMeshDesc.html">PxClothMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gravity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useGeodesicTether</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cooks a triangle mesh to a <a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>physics</em>&nbsp;</td><td>The physics instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desc</em>&nbsp;</td><td>The cloth mesh descriptor on which the generation of the cooked mesh depends. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gravity</em>&nbsp;</td><td>A normalized vector which specifies the direction of gravity. This information allows the cooker to generate a fabric with higher quality simulation behavior. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useGeodesicTether</em>&nbsp;</td><td>A flag to indicate whether to compute geodesic distance for tether constraints. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The created cloth fabric, or NULL if creation failed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdf1d4e04d0c9587b111c3737c9789658"></a><!-- doxytag: member="PxTriangleMeshExt.h::PxComputeHeightFieldPenetration" ref="gdf1d4e04d0c9587b111c3737c9789658" args="(PxVec3 &amp;direction, PxReal &amp;depth, const PxGeometry &amp;geom, const PxTransform &amp;geomPose, const PxHeightFieldGeometry &amp;heightFieldGeom, const PxTransform &amp;heightFieldPose, PxU32 maxIter, PxU32 *usedIter=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PxComputeHeightFieldPenetration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal &amp;&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>heightFieldGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>heightFieldPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>usedIter</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes an approximate minimum translational distance (MTD) between a geometry object and a heightfield. 
<p>
This iterative function computes an approximate vector that can be used to depenetrate a geom object from a heightfield. Returned depenetration vector should be applied to 'geom', to get out of the heightfield.<p>
The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the heightfield, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.<p>
The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>direction</em>&nbsp;</td><td>Computed MTD unit direction </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>depth</em>&nbsp;</td><td>Penetration depth. Always positive or zero. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geom</em>&nbsp;</td><td>The geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geomPose</em>&nbsp;</td><td>Pose for the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>heightFieldGeom</em>&nbsp;</td><td>The heightfield geometry </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>heightFieldPose</em>&nbsp;</td><td>Pose for the heightfield </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxIter</em>&nbsp;</td><td>Max number of iterations before returning. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>usedIter</em>&nbsp;</td><td>Number of depenetrations attempts performed during the call. Will not be returned if the pointer is NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the MTD has successfully been computed, i.e. if objects do overlap.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> <a class="el" href="classPxHeightFieldGeometry.html" title="Height field geometry class.">PxHeightFieldGeometry</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0e11331d1427e0eb67f60b45b84e7053"></a><!-- doxytag: member="PxTriangleMeshExt.h::PxComputeHeightFieldPenetration" ref="g0e11331d1427e0eb67f60b45b84e7053" args="(PxU32 maxIter, const PxGeometry &amp;geom, const PxTransform &amp;geomPose, const PxHeightFieldGeometry &amp;heightFieldGeom, const PxTransform &amp;heightFieldPose, PxU32 &amp;nb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED <a class="el" href="classPxVec3.html">PxVec3</a> PxComputeHeightFieldPenetration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>heightFieldGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>heightFieldPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes an approximate minimum translational distance (MTD) between a geometry object and a heightfield. 
<p>
This iterative function computes an approximate vector that can be used to depenetrate a geom object from a heightfield. Returned depenetration vector should be applied to 'geom', to get out of the heightfield.<p>
The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the heightfield, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.<p>
The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxIter</em>&nbsp;</td><td>Max number of iterations before returning. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geom</em>&nbsp;</td><td>The geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geomPose</em>&nbsp;</td><td>Pose for the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>heightFieldGeom</em>&nbsp;</td><td>The heightfield geometry </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>heightFieldPose</em>&nbsp;</td><td>Pose for the heightfield </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>Number of depenetrations attempts performed during the call. 0 means no overlap has been detected.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximate depenetration vector</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> <a class="el" href="classPxHeightFieldGeometry.html" title="Height field geometry class.">PxHeightFieldGeometry</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdc8527630e57855176639ffc43028ef6"></a><!-- doxytag: member="PxTriangleMeshExt.h::PxComputeMeshPenetration" ref="gdc8527630e57855176639ffc43028ef6" args="(PxU32 maxIter, const PxGeometry &amp;geom, const PxTransform &amp;geomPose, const PxTriangleMeshGeometry &amp;meshGeom, const PxTransform &amp;meshPose, PxU32 &amp;nb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED <a class="el" href="classPxVec3.html">PxVec3</a> PxComputeMeshPenetration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>meshGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>meshPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes an approximate minimum translational distance (MTD) between a geometry object and a mesh. 
<p>
This iterative function computes an approximate vector that can be used to depenetrate a geom object from a triangle mesh. Returned depenetration vector should be applied to 'geom', to get out of the mesh.<p>
The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the mesh, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.<p>
The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxIter</em>&nbsp;</td><td>Max number of iterations before returning. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geom</em>&nbsp;</td><td>The geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geomPose</em>&nbsp;</td><td>Pose for the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>meshGeom</em>&nbsp;</td><td>The mesh geometry </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>meshPose</em>&nbsp;</td><td>Pose for the mesh </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nb</em>&nbsp;</td><td>Number of depenetrations attempts performed during the call. 0 means no overlap has been detected.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximate depenetration vector</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> <a class="el" href="classPxTriangleMeshGeometry.html" title="Triangle mesh geometry class.">PxTriangleMeshGeometry</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g78a7fcf3e5c470de1083ada5fde8e32f"></a><!-- doxytag: member="PxTriangleMeshExt.h::PxComputeTriangleMeshPenetration" ref="g78a7fcf3e5c470de1083ada5fde8e32f" args="(PxVec3 &amp;direction, PxReal &amp;depth, const PxGeometry &amp;geom, const PxTransform &amp;geomPose, const PxTriangleMeshGeometry &amp;meshGeom, const PxTransform &amp;meshPose, PxU32 maxIter, PxU32 *usedIter=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PxComputeTriangleMeshPenetration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal &amp;&nbsp;</td>
          <td class="paramname"> <em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>meshGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>meshPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>usedIter</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes an approximate minimum translational distance (MTD) between a geometry object and a mesh. 
<p>
This iterative function computes an approximate vector that can be used to depenetrate a geom object from a triangle mesh. Returned depenetration vector should be applied to 'geom', to get out of the mesh.<p>
The function works best when the amount of overlap between the geom object and the mesh is small. If the geom object's center goes inside the mesh, backface culling usually kicks in, no overlap is detected, and the function does not compute an MTD vector.<p>
The function early exits if no overlap is detected after a depenetration attempt. This means that if maxIter = N, the code will attempt at most N iterations but it might exit earlier if depenetration has been successful. Usually N = 4 gives good results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>direction</em>&nbsp;</td><td>Computed MTD unit direction </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>depth</em>&nbsp;</td><td>Penetration depth. Always positive or zero. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geom</em>&nbsp;</td><td>The geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geomPose</em>&nbsp;</td><td>Pose for the geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>meshGeom</em>&nbsp;</td><td>The mesh geometry </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>meshPose</em>&nbsp;</td><td>Pose for the mesh </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxIter</em>&nbsp;</td><td>Max number of iterations before returning. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>usedIter</em>&nbsp;</td><td>Number of depenetrations attempts performed during the call. Will not be returned if the pointer is NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the MTD has successfully been computed, i.e. if objects do overlap.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> <a class="el" href="classPxTriangleMeshGeometry.html" title="Triangle mesh geometry class.">PxTriangleMeshGeometry</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g868bf680832c3f47e924fd2da011957d"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreateDynamic" ref="g868bf680832c3f47e924fd2da011957d" args="(PxPhysics &amp;sdk, const PxTransform &amp;transform, PxShape &amp;shape, PxReal density)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxCreateDynamic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>density</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
simple method to create a <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the transform of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>the shape of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>the density of the new object. Must be greater than zero.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new dynamic actor with the <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a>, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6f8a1ee174c919242d7e5a00c57f0fdb"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreateDynamic" ref="g6f8a1ee174c919242d7e5a00c57f0fdb" args="(PxPhysics &amp;sdk, const PxTransform &amp;transform, const PxGeometry &amp;geometry, PxMaterial &amp;material, PxReal density, const PxTransform &amp;shapeOffset=PxTransform(PxIdentity))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxCreateDynamic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shapeOffset</em> = <code><a class="el" href="classPxTransform.html">PxTransform</a>(PxIdentity)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
simple method to create a <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the global pose of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the new object's shape, which must be a sphere, capsule, box or convex </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the new object's shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>the density of the new object. Must be greater than zero. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeOffset</em>&nbsp;</td><td>an optional offset for the new shape, defaults to identity</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new dynamic actor with the <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a>, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g63356d306e103b6bf13dc7bf2ae233f6"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreateKinematic" ref="g63356d306e103b6bf13dc7bf2ae233f6" args="(PxPhysics &amp;sdk, const PxTransform &amp;transform, PxShape &amp;shape, PxReal density)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxCreateKinematic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>density</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
simple method to create a kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the global pose of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>the density of the new object. Must be greater than zero if the object is to participate in simulation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>the shape of the new object</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>unlike PxCreateDynamic, the geometry is not restricted to box, capsule, sphere or convex. However, kinematics of other geometry types may not participate in simulation collision and may be used only for triggers or scene queries of moving objects under animation control. In this case the density parameter will be ignored and the created shape will be set up as a scene query only shape (see <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1abc7ec24b00ed57f3914482f0706c6273" title="The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...).">PxShapeFlag::eSCENE_QUERY_SHAPE</a>)</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new dynamic actor with the <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596bd76e6985e9db78efb7a66148ea4c212" title="Enables kinematic mode for the actor.">PxRigidBodyFlag::eKINEMATIC</a> set, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd2b49dd51647b7228668827c689bbb32"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreateKinematic" ref="gd2b49dd51647b7228668827c689bbb32" args="(PxPhysics &amp;sdk, const PxTransform &amp;transform, const PxGeometry &amp;geometry, PxMaterial &amp;material, PxReal density, const PxTransform &amp;shapeOffset=PxTransform(PxIdentity))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxCreateKinematic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shapeOffset</em> = <code><a class="el" href="classPxTransform.html">PxTransform</a>(PxIdentity)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
simple method to create a kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the global pose of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the new object's shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the new object's shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>the density of the new object. Must be greater than zero if the object is to participate in simulation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeOffset</em>&nbsp;</td><td>an optional offset for the new shape, defaults to identity</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>unlike PxCreateDynamic, the geometry is not restricted to box, capsule, sphere or convex. However, kinematics of other geometry types may not participate in simulation collision and may be used only for triggers or scene queries of moving objects under animation control. In this case the density parameter will be ignored and the created shape will be set up as a scene query only shape (see <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1abc7ec24b00ed57f3914482f0706c6273" title="The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...).">PxShapeFlag::eSCENE_QUERY_SHAPE</a>)</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new dynamic actor with the <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596bd76e6985e9db78efb7a66148ea4c212" title="Enables kinematic mode for the actor.">PxRigidBodyFlag::eKINEMATIC</a> set, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbbffb883dd38c52aef27f7ea084a1cde"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreatePlane" ref="gbbffb883dd38c52aef27f7ea084a1cde" args="(PxPhysics &amp;sdk, const PxPlane &amp;plane, PxMaterial &amp;material)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a>* PxCreatePlane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxPlane.html">PxPlane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a plane actor. The plane equation is n.x + d = 0 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>plane</em>&nbsp;</td><td>a plane of the form n.x + d = 0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the new object's shape</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new static actor, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5b375e0249df691cb6c9375fe3ce3eda"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreateStatic" ref="g5b375e0249df691cb6c9375fe3ce3eda" args="(PxPhysics &amp;sdk, const PxTransform &amp;transform, PxShape &amp;shape)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> * PxCreateStatic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
simple method to create a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the global pose of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>the new object's shape</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new static actor, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g79da8a82087b6fe978e615f61118f03e"></a><!-- doxytag: member="PxSimpleFactory.h::PxCreateStatic" ref="g79da8a82087b6fe978e615f61118f03e" args="(PxPhysics &amp;sdk, const PxTransform &amp;transform, const PxGeometry &amp;geometry, PxMaterial &amp;material, const PxTransform &amp;shapeOffset=PxTransform(PxIdentity))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRigidStatic.html">PxRigidStatic</a>* PxCreateStatic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sdk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shapeOffset</em> = <code><a class="el" href="classPxTransform.html">PxTransform</a>(PxIdentity)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
simple method to create a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> actor with a single <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sdk</em>&nbsp;</td><td>the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>transform</em>&nbsp;</td><td>the global pose of the new object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the new object's shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the new object's shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeOffset</em>&nbsp;</td><td>an optional offset for the new shape, defaults to identity</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new static actor, or NULL if it could not be constructed</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5d942bf8c3069024e50a8dd2254c390c"></a><!-- doxytag: member="PxD6Joint.h::PxD6JointCreate" ref="g5d942bf8c3069024e50a8dd2254c390c" args="(PxPhysics &amp;physics, PxRigidActor *actor0, const PxTransform &amp;localFrame0, PxRigidActor *actor1, const PxTransform &amp;localFrame1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxD6Joint.html">PxD6Joint</a>* PxD6JointCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a D6 joint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physics</em>&nbsp;</td><td>the physics SDK </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame0</em>&nbsp;</td><td>the position and orientation of the joint relative to actor0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame1</em>&nbsp;</td><td>the position and orientation of the joint relative to actor1</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxD6Joint.html" title="A D6 joint is a general constraint between two actors.">PxD6Joint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g68e9b3c3ee8961234464d8eb0b64d5e3"></a><!-- doxytag: member="PxDefaultCpuDispatcher.h::PxDefaultCpuDispatcherCreate" ref="g68e9b3c3ee8961234464d8eb0b64d5e3" args="(PxU32 numThreads, PxU32 *affinityMasks=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxDefaultCpuDispatcher.html">PxDefaultCpuDispatcher</a>* PxDefaultCpuDispatcherCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>affinityMasks</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create default dispatcher, extensions SDK needs to be initialized first. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numThreads</em>&nbsp;</td><td>Number of worker threads the dispatcher should use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>affinityMasks</em>&nbsp;</td><td>Array with affinity mask for each thread. If not defined, default masks will be used.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>numThreads may be zero in which case no worker thread are initialized and simulation tasks will be executed on the thread that calls <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxDefaultCpuDispatcher.html" title="A default implementation for a CPU task dispatcher.">PxDefaultCpuDispatcher</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g587ba12f90f77543c3e4452abeb0f22f"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxDefaultSimulationFilterShader" ref="g587ba12f90f77543c3e4452abeb0f22f" args="(PxFilterObjectAttributes attributes0, PxFilterData filterData0, PxFilterObjectAttributes attributes1, PxFilterData filterData1, PxPairFlags &amp;pairFlags, const void *constantBlock, PxU32 constantBlockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxFlags.html">PxFilterFlags</a> PxDefaultSimulationFilterShader           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a>&nbsp;</td>
          <td class="paramname"> <em>attributes0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxFilterData.html">PxFilterData</a>&nbsp;</td>
          <td class="paramname"> <em>filterData0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__physics.html#g7b0c5783657e45e3fd752adfe3c1d069">PxFilterObjectAttributes</a>&nbsp;</td>
          <td class="paramname"> <em>attributes1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxFilterData.html">PxFilterData</a>&nbsp;</td>
          <td class="paramname"> <em>filterData1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxPairFlags</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pairFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>constantBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>constantBlockSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of a simple filter shader that emulates PhysX 2.8.x filtering. 
<p>
This shader provides the following logic: <ul>
<li>If one of the two filter objects is a trigger, the pair is acccepted and <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2fcac0202003af4139c16413db81b4a2e7" title="Provided default flag to get commonly used trigger behavior for this collision pair...">PxPairFlag::eTRIGGER_DEFAULT</a> will be used for trigger reports </li>
<li>Else, if the filter mask logic (see further below) discards the pair it will be suppressed (<a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc58083823b175755a63b3e8ad474528f5e1bf6" title="Ignore the collision pair as long as the bounding volumes of the pair objects overlap...">PxFilterFlag::eSUPPRESS</a>) </li>
<li>Else, the pair gets accepted and collision response gets enabled (<a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2ffd2fd2d6bbbf3acc8d3cbe63beabe6fe" title="Provided default flag to do simple contact processing for this collision pair.">PxPairFlag::eCONTACT_DEFAULT</a>)</li>
</ul>
Filter mask logic: Given the two <a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> structures fd0 and fd1 of two collision objects, the pair passes the filter if the following conditions are met:<p>
1) Collision groups of the pair are enabled 2) Collision filtering equation is satisfied<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf7580a5a315137094cb676a7874c978a"></a><!-- doxytag: member="PxDistanceJoint.h::PxDistanceJointCreate" ref="gf7580a5a315137094cb676a7874c978a" args="(PxPhysics &amp;physics, PxRigidActor *actor0, const PxTransform &amp;localFrame0, PxRigidActor *actor1, const PxTransform &amp;localFrame1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxDistanceJoint.html">PxDistanceJoint</a>* PxDistanceJointCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a distance Joint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physics</em>&nbsp;</td><td>the physics SDK </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame0</em>&nbsp;</td><td>the position and orientation of the joint relative to actor0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame1</em>&nbsp;</td><td>the position and orientation of the joint relative to actor1</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxDistanceJoint.html" title="a joint that maintains an upper or lower bound (or both) on the distance between...">PxDistanceJoint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g450abb675b283fd8031caf82e85844e2"></a><!-- doxytag: member="PxConvexMeshExt.h::PxFindFaceIndex" ref="g450abb675b283fd8031caf82e85844e2" args="(const PxConvexMeshGeometry &amp;convexGeom, const PxTransform &amp;geomPose, const PxVec3 &amp;impactPos, const PxVec3 &amp;unitDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxFindFaceIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxConvexMeshGeometry.html">PxConvexMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>convexGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>impactPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes closest polygon of the convex hull geometry for a given impact point and impact direction. When doing sweeps against a scene, one might want to delay the rather expensive computation of the hit face index for convexes until it is clear the information is really needed and then use this method to get the corresponding face index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>convexGeom</em>&nbsp;</td><td>The convex mesh geometry. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geomPose</em>&nbsp;</td><td>Pose for the geometry object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>impactPos</em>&nbsp;</td><td>Impact position. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized impact direction.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Closest face index of the convex geometry.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g17f2eab8a94d35778f2555a85c34ea7f"></a><!-- doxytag: member="PxFixedJoint.h::PxFixedJointCreate" ref="g17f2eab8a94d35778f2555a85c34ea7f" args="(PxPhysics &amp;physics, PxRigidActor *actor0, const PxTransform &amp;localFrame0, PxRigidActor *actor1, const PxTransform &amp;localFrame1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxFixedJoint.html">PxFixedJoint</a>* PxFixedJointCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a fixed joint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physics</em>&nbsp;</td><td>the physics SDK </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame0</em>&nbsp;</td><td>the position and orientation of the joint relative to actor0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame1</em>&nbsp;</td><td>the position and orientation of the joint relative to actor1</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxFixedJoint.html" title="A fixed joint permits no relative movement between two bodies. ie the bodies are...">PxFixedJoint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4ad1c1fb89841e9f9416530aed66170b"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxGetFilterBool" ref="g4ad1c1fb89841e9f9416530aed66170b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PxGetFilterBool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves filtering's boolean value. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>flag Boolean value for filter.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#gf17024df6afd1cbab816914f25b33214" title="Setups filtering&#39;s boolean value. See comments for PxGroupsMask.">PxSetFilterBool</a> <a class="el" href="group__extensions.html#g7f3ed5a3baab55369f7ee35e4e44cfb0" title="Setups filtering&#39;s K0 and K1 value. See comments for PxGroupsMask.">PxSetFilterConstants</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf61e11222319b3a664d8127c8b64bb98"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxGetFilterConstants" ref="gf61e11222319b3a664d8127c8b64bb98" args="(PxGroupsMask &amp;c0, PxGroupsMask &amp;c1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxGetFilterConstants           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets filtering constant K0 and K1. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>c0</em>&nbsp;</td><td>the filtering constants, as a mask. See <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>c1</em>&nbsp;</td><td>the filtering constants, as a mask. See <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g64679ee1d097cd1699fd8d3413ac2932" title="Setups filtering operations. See comments for PxGroupsMask.">PxSetFilterOps</a> <a class="el" href="group__extensions.html#gf17024df6afd1cbab816914f25b33214" title="Setups filtering&#39;s boolean value. See comments for PxGroupsMask.">PxSetFilterBool</a> <a class="el" href="group__extensions.html#g7f3ed5a3baab55369f7ee35e4e44cfb0" title="Setups filtering&#39;s K0 and K1 value. See comments for PxGroupsMask.">PxSetFilterConstants</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb5878e8b784c6c17d26a20bc202c4c0e"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxGetFilterOps" ref="gb5878e8b784c6c17d26a20bc202c4c0e" args="(PxFilterOp::Enum &amp;op0, PxFilterOp::Enum &amp;op1, PxFilterOp::Enum &amp;op2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxGetFilterOps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves filtering operation. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op0</em>&nbsp;</td><td>First filter operator. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op1</em>&nbsp;</td><td>Second filter operator. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op2</em>&nbsp;</td><td>Third filter operator.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g64679ee1d097cd1699fd8d3413ac2932" title="Setups filtering operations. See comments for PxGroupsMask.">PxSetFilterOps</a> <a class="el" href="group__extensions.html#gf17024df6afd1cbab816914f25b33214" title="Setups filtering&#39;s boolean value. See comments for PxGroupsMask.">PxSetFilterBool</a> <a class="el" href="group__extensions.html#g7f3ed5a3baab55369f7ee35e4e44cfb0" title="Setups filtering&#39;s K0 and K1 value. See comments for PxGroupsMask.">PxSetFilterConstants</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0918cc645e6e95c3077a816ba33b42e9"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxGetGroup" ref="g0918cc645e6e95c3077a816ba33b42e9" args="(const PxActor &amp;actor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxU16 PxGetGroup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the value set with <a class="el" href="group__extensions.html#g0f895f83f81c371385418a3284d28070" title="Sets which collision group this actor is part of.">PxSetGroup()</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Collision group is an integer between 0 and 31.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The collision group this actor belongs to</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g0f895f83f81c371385418a3284d28070" title="Sets which collision group this actor is part of.">PxSetGroup</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge13799b44f055e19212220bdff322597"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxGetGroupCollisionFlag" ref="ge13799b44f055e19212220bdff322597" args="(const PxU16 group1, const PxU16 group2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PxGetGroupCollisionFlag           </td>
          <td>(</td>
          <td class="paramtype">const PxU16&nbsp;</td>
          <td class="paramname"> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU16&nbsp;</td>
          <td class="paramname"> <em>group2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if collision detection is performed between a pair of groups. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Collision group is an integer between 0 and 31.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group1</em>&nbsp;</td><td>First Group </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group2</em>&nbsp;</td><td>Second Group</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the groups could collide</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g8ced9dfabbe8811f9c5ea8933e1298f7" title="Specifies if collision should be performed by a pair of groups.">PxSetGroupCollisionFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g13ef0a91d385e0f45c1b73b3ffafa8dc"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxGetGroupsMask" ref="g13ef0a91d385e0f45c1b73b3ffafa8dc" args="(const PxActor &amp;actor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> PxGetGroupsMask           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets 64-bit mask used for collision filtering. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The group mask for the actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g4e9876a60fc230eb433a6b3d77beaae9" title="Sets 64-bit mask used for collision filtering. See comments for PxGroupsMask.">PxSetGroupsMask()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g54f81dd3dbc77a3363357b5150dcba21"></a><!-- doxytag: member="PxExtensionsAPI.h::PxInitExtensions" ref="g54f81dd3dbc77a3363357b5150dcba21" args="(physx::PxPhysics &amp;physics, physx::PxPvd *pvd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT bool PX_CALL_CONV PxInitExtensions           </td>
          <td>(</td>
          <td class="paramtype">physx::PxPhysics &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxPvd *&nbsp;</td>
          <td class="paramname"> <em>pvd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the PhysXExtensions library. 
<p>
This should be called before calling any functions or methods in extensions which may require allocation. <dl class="note" compact><dt><b>Note:</b></dt><dd>This function does not need to be called before creating a <a class="el" href="classPxDefaultAllocator.html" title="default implementation of the allocator interface required by the SDK">PxDefaultAllocator</a> object.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>physics</em>&nbsp;</td><td>a <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pvd</em>&nbsp;</td><td>an <a class="el" href="classPxPvd.html" title="PxPvd is the top-level class for the PVD framework, and the main customer interface...">PxPvd</a> (PhysX Visual Debugger) object</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g574914ae1ef022264d4338d355a50ed8" title="Shut down the PhysXExtensions library.">PxCloseExtensions</a> <a class="el" href="classPxFoundation.html" title="Foundation SDK singleton class.">PxFoundation</a> <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gef94272b3a37bbcce4008c1911a06b5c"></a><!-- doxytag: member="PxPrismaticJoint.h::PxPrismaticJointCreate" ref="gef94272b3a37bbcce4008c1911a06b5c" args="(PxPhysics &amp;physics, PxRigidActor *actor0, const PxTransform &amp;localFrame0, PxRigidActor *actor1, const PxTransform &amp;localFrame1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxPrismaticJoint.html">PxPrismaticJoint</a>* PxPrismaticJointCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a prismatic joint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physics</em>&nbsp;</td><td>the physics SDK </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame0</em>&nbsp;</td><td>the position and orientation of the joint relative to actor0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame1</em>&nbsp;</td><td>the position and orientation of the joint relative to actor1</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPrismaticJoint.html" title="A prismatic joint permits relative translational movement between two bodies along...">PxPrismaticJoint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4aa56f32cb1cb2245d1c0cde99d0af17"></a><!-- doxytag: member="PxRevoluteJoint.h::PxRevoluteJointCreate" ref="g4aa56f32cb1cb2245d1c0cde99d0af17" args="(PxPhysics &amp;physics, PxRigidActor *actor0, const PxTransform &amp;localFrame0, PxRigidActor *actor1, const PxTransform &amp;localFrame1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxRevoluteJoint.html">PxRevoluteJoint</a>* PxRevoluteJointCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a revolute joint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physics</em>&nbsp;</td><td>the physics SDK </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame0</em>&nbsp;</td><td>the position and orientation of the joint relative to actor0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame1</em>&nbsp;</td><td>the position and orientation of the joint relative to actor1</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRevoluteJoint.html" title="A joint which behaves in a similar way to a hinge or axle.">PxRevoluteJoint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g34084817afc2cfd9f1bb9108c5244b08"></a><!-- doxytag: member="PxSimpleFactory.h::PxScaleRigidActor" ref="g34084817afc2cfd9f1bb9108c5244b08" args="(PxRigidActor &amp;actor, PxReal scale, bool scaleMassProps=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxScaleRigidActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>scaleMassProps</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scale a rigid actor by a uniform scale 
<p>
The geometry and relative positions of the actor are multiplied by the given scale value. If the actor is a rigid body or an articulation link and the scaleMassProps value is true, the mass properties are scaled assuming the density is constant: the center of mass is linearly scaled, the mass is multiplied by the cube of the scale, and the inertia tensor by the fifth power of the scale.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>a rigid actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scale</em>&nbsp;</td><td>the scale by which to multiply the actor. Must be &gt;0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scaleMassProps</em>&nbsp;</td><td>whether to scale the mass properties </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf17024df6afd1cbab816914f25b33214"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxSetFilterBool" ref="gf17024df6afd1cbab816914f25b33214" args="(const bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxSetFilterBool           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setups filtering's boolean value. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>Boolean value for filter.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g64679ee1d097cd1699fd8d3413ac2932" title="Setups filtering operations. See comments for PxGroupsMask.">PxSetFilterOps</a> PxSsetFilterConstants </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7f3ed5a3baab55369f7ee35e4e44cfb0"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxSetFilterConstants" ref="g7f3ed5a3baab55369f7ee35e4e44cfb0" args="(const PxGroupsMask &amp;c0, const PxGroupsMask &amp;c1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxSetFilterConstants           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>c1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setups filtering's K0 and K1 value. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>c0</em>&nbsp;</td><td>The new group mask. See <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>c1</em>&nbsp;</td><td>The new group mask. See <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g64679ee1d097cd1699fd8d3413ac2932" title="Setups filtering operations. See comments for PxGroupsMask.">PxSetFilterOps</a> <a class="el" href="group__extensions.html#gf17024df6afd1cbab816914f25b33214" title="Setups filtering&#39;s boolean value. See comments for PxGroupsMask.">PxSetFilterBool</a> <a class="el" href="group__extensions.html#gf61e11222319b3a664d8127c8b64bb98" title="Gets filtering constant K0 and K1. See comments for PxGroupsMask.">PxGetFilterConstants</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g64679ee1d097cd1699fd8d3413ac2932"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxSetFilterOps" ref="g64679ee1d097cd1699fd8d3413ac2932" args="(const PxFilterOp::Enum &amp;op0, const PxFilterOp::Enum &amp;op1, const PxFilterOp::Enum &amp;op2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxSetFilterOps           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterOp.html#bded53995f8e25fd68ee10759a762c8b">PxFilterOp::Enum</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setups filtering operations. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op0</em>&nbsp;</td><td>Filter op 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op1</em>&nbsp;</td><td>Filter op 1. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op2</em>&nbsp;</td><td>Filter op 2.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#gf17024df6afd1cbab816914f25b33214" title="Setups filtering&#39;s boolean value. See comments for PxGroupsMask.">PxSetFilterBool</a> <a class="el" href="group__extensions.html#g7f3ed5a3baab55369f7ee35e4e44cfb0" title="Setups filtering&#39;s K0 and K1 value. See comments for PxGroupsMask.">PxSetFilterConstants</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0f895f83f81c371385418a3284d28070"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxSetGroup" ref="g0f895f83f81c371385418a3284d28070" args="(PxActor &amp;actor, const PxU16 collisionGroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxSetGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU16&nbsp;</td>
          <td class="paramname"> <em>collisionGroup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets which collision group this actor is part of. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Collision group is an integer between 0 and 31.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>collisionGroup</em>&nbsp;</td><td>Collision group this actor belongs to</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g0918cc645e6e95c3077a816ba33b42e9" title="Retrieves the value set with PxSetGroup().">PxGetGroup</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8ced9dfabbe8811f9c5ea8933e1298f7"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxSetGroupCollisionFlag" ref="g8ced9dfabbe8811f9c5ea8933e1298f7" args="(const PxU16 group1, const PxU16 group2, const bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxSetGroupCollisionFlag           </td>
          <td>(</td>
          <td class="paramtype">const PxU16&nbsp;</td>
          <td class="paramname"> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU16&nbsp;</td>
          <td class="paramname"> <em>group2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies if collision should be performed by a pair of groups. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Collision group is an integer between 0 and 31.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group1</em>&nbsp;</td><td>First Group </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group2</em>&nbsp;</td><td>Second Group </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable collision between the groups</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#ge13799b44f055e19212220bdff322597" title="Determines if collision detection is performed between a pair of groups.">PxGetGroupCollisionFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4e9876a60fc230eb433a6b3d77beaae9"></a><!-- doxytag: member="PxDefaultSimulationFilterShader.h::PxSetGroupsMask" ref="g4e9876a60fc230eb433a6b3d77beaae9" args="(PxActor &amp;actor, const PxGroupsMask &amp;mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxSetGroupsMask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGroupsMask.html">PxGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets 64-bit mask used for collision filtering. See comments for <a class="el" href="classPxGroupsMask.html" title="64-bit mask used for collision filtering.">PxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The group mask to set for the actor.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__extensions.html#g13ef0a91d385e0f45c1b73b3ffafa8dc" title="Gets 64-bit mask used for collision filtering. See comments for PxGroupsMask.">PxGetGroupsMask()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g43cc950618f193fd1fdbde2f624e0e52"></a><!-- doxytag: member="PxJoint.h::PxSetJointGlobalFrame" ref="g43cc950618f193fd1fdbde2f624e0e52" args="(physx::PxJoint &amp;joint, const physx::PxVec3 *wsAnchor, const physx::PxVec3 *wsAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT void PX_CALL_CONV PxSetJointGlobalFrame           </td>
          <td>(</td>
          <td class="paramtype">physx::PxJoint &amp;&nbsp;</td>
          <td class="paramname"> <em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const physx::PxVec3 *&nbsp;</td>
          <td class="paramname"> <em>wsAnchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const physx::PxVec3 *&nbsp;</td>
          <td class="paramname"> <em>wsAxis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function to setup a joint's global frame. 
<p>
This replaces the following functions from previous SDK versions:<p>
void NxJointDesc::setGlobalAnchor(const NxVec3&amp; wsAnchor); void NxJointDesc::setGlobalAxis(const NxVec3&amp; wsAxis);<p>
The function sets the joint's localPose using world-space input parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wsAnchor</em>&nbsp;</td><td>Global frame anchor point. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wsAxis</em>&nbsp;</td><td>Global frame axis. <b>Range:</b> direction vector </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>joint</em>&nbsp;</td><td>Joint having its global frame set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g02d8221452498576e374288ef10b8dc9"></a><!-- doxytag: member="PxSphericalJoint.h::PxSphericalJointCreate" ref="g02d8221452498576e374288ef10b8dc9" args="(PxPhysics &amp;physics, PxRigidActor *actor0, const PxTransform &amp;localFrame0, PxRigidActor *actor1, const PxTransform &amp;localFrame1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSphericalJoint.html">PxSphericalJoint</a>* PxSphericalJointCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>physics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localFrame1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a spherical joint. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>physics</em>&nbsp;</td><td>the physics SDK </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame0</em>&nbsp;</td><td>the position and orientation of the joint relative to actor0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>an actor to which the joint is attached. NULL may be used to attach the joint to a specific point in the world frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localFrame1</em>&nbsp;</td><td>the position and orientation of the joint relative to actor1</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSphericalJoint.html" title="A joint which behaves in a similar way to a ball and socket.">PxSphericalJoint</a> </dd></dl>

</div>
</div><p>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
