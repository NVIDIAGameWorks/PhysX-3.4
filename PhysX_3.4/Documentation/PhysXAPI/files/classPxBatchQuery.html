<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxBatchQuery Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxBatchQuery Class Reference<br>
<small>
[<a class="el" href="group__scenequery.html">Scenequery</a>]</small>
</h1><!-- doxytag: class="PxBatchQuery" -->Batched queries object. This is used to perform several queries at the same time.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxBatchQuery_8h-source.html">PxBatchQuery.h</a>&gt;</code>
<p>

<p>
<a href="classPxBatchQuery-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#44d0c3cc22363a3b1cc9f42f64bc51eb">execute</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes batched queries.  <a href="#44d0c3cc22363a3b1cc9f42f64bc51eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b">PxBatchQueryPreFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#5c88db06732dd07d95fe006df755e094">getPreFilterShader</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the prefilter shader in use for this scene query.  <a href="#5c88db06732dd07d95fe006df755e094"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0">PxBatchQueryPostFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#f12d7a7693f8f4101f51cb5582386a08">getPostFilterShader</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the postfilter shader in use for this scene query.  <a href="#f12d7a7693f8f4101f51cb5582386a08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#279f956d9c09cb6d0b59ff5103982c37">getFilterShaderData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the shared global filter data in use for this scene query.  <a href="#279f956d9c09cb6d0b59ff5103982c37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#7213f11f610f088b8d98a075c795d61a">getFilterShaderDataSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>).  <a href="#7213f11f610f088b8d98a075c795d61a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#3f9f6115709370fc445c03c9da06b691">getOwnerClient</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the client specified with <a class="el" href="classPxBatchQueryDesc.html#9bca9313c79171e15a94615958672848" title="client that creates and owns this scene query.">PxBatchQueryDesc::ownerClient</a> at creation time.  <a href="#3f9f6115709370fc445c03c9da06b691"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2">setUserMemory</a> (const <a class="el" href="structPxBatchQueryMemory.html">PxBatchQueryMemory</a> &amp;)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets new user memory pointers.  <a href="#ca7ccdab697074ae572c7d0baf9af3c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="structPxBatchQueryMemory.html">PxBatchQueryMemory</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#edffcfa27e47ef04274bb8180b42e913">getUserMemory</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the user memory pointers.  <a href="#edffcfa27e47ef04274bb8180b42e913"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#623fdf0b33e7d51c1b5ca278d8f19a75">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> from <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>.  <a href="#623fdf0b33e7d51c1b5ca278d8f19a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#39f64da3f122ff78cbaa1a5a83bc9840">raycast</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, PxReal distance=PX_MAX_F32, PxU16 maxTouchHits=0, PxHitFlags hitFlags=PxHitFlag::eDEFAULT, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *cache=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a raycast against objects in the scene, returns results in <a class="el" href="structPxBatchQueryMemory.html#194b1ad50e68760d9499e253151c7d31" title="The pointer to the user-allocated buffer for results of raycast queries in corresponding...">PxBatchQueryMemory::userRaycastResultBuffer</a> specified at <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> creation time or via <a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2" title="Sets new user memory pointers.">PxBatchQuery::setUserMemory</a> call.  <a href="#39f64da3f122ff78cbaa1a5a83bc9840"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#2312bc0c82e54bbf46c16e203f9937e3">overlap</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, PxU16 maxTouchHits=0, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *cache=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs an overlap test of a given geometry against objects in the scene, returns results in <a class="el" href="structPxBatchQueryMemory.html#7c54ac68c7049897accaa4520c418d1e" title="The pointer to the user-allocated buffer for results of overlap queries in corresponding...">PxBatchQueryMemory::userOverlapResultBuffer</a> specified at <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> creation time or via <a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2" title="Sets new user memory pointers.">PxBatchQuery::setUserMemory</a> call.  <a href="#2312bc0c82e54bbf46c16e203f9937e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#bf15206e4dcf2238db75f47565078b49">sweep</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const PxReal distance, PxU16 maxTouchHits=0, PxHitFlags hitFlags=PxHitFlag::eDEFAULT, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *cache=NULL, const PxReal inflation=0.f)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a sweep test against objects in the scene, returns results in <a class="el" href="structPxBatchQueryMemory.html#21e15901b0b7e88fe8f59ea06dcff69e" title="The pointer to the user-allocated buffer for results of sweep queries in corresponding...">PxBatchQueryMemory::userSweepResultBuffer</a> specified at <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> creation time or via <a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2" title="Sets new user memory pointers.">PxBatchQuery::setUserMemory</a> call.  <a href="#bf15206e4dcf2238db75f47565078b49"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#117dd25a3366f03dbb748a5afcf26117">~PxBatchQuery</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Batched queries object. This is used to perform several queries at the same time. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>The batched query feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>, <a class="el" href="classPxScene.html#080866698f34876134941cf42949592b" title="Creates a BatchQuery object.">PxScene.createBatchQuery</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="117dd25a3366f03dbb748a5afcf26117"></a><!-- doxytag: member="PxBatchQuery::~PxBatchQuery" ref="117dd25a3366f03dbb748a5afcf26117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxBatchQuery::~PxBatchQuery           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="44d0c3cc22363a3b1cc9f42f64bc51eb"></a><!-- doxytag: member="PxBatchQuery::execute" ref="44d0c3cc22363a3b1cc9f42f64bc51eb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::execute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes batched queries. 
<p>

</div>
</div><p>
<a class="anchor" name="279f956d9c09cb6d0b59ff5103982c37"></a><!-- doxytag: member="PxBatchQuery::getFilterShaderData" ref="279f956d9c09cb6d0b59ff5103982c37" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* PxBatchQuery::getFilterShaderData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the shared global filter data in use for this scene query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Shared filter data for filter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html#7213f11f610f088b8d98a075c795d61a" title="Gets the size of the shared global filter data (PxSceneDesc.filterShaderData).">getFilterShaderDataSize()</a> <a class="el" href="classPxBatchQueryDesc.html#5f0ec12e1149c7960b9360c53615853c" title="Shared global filter data which will get passed into the filter shader.">PxBatchQueryDesc.filterShaderData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7213f11f610f088b8d98a075c795d61a"></a><!-- doxytag: member="PxBatchQuery::getFilterShaderDataSize" ref="7213f11f610f088b8d98a075c795d61a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxBatchQuery::getFilterShaderDataSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of shared filter data [bytes].</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html#279f956d9c09cb6d0b59ff5103982c37" title="Gets the shared global filter data in use for this scene query.">getFilterShaderData()</a> <a class="el" href="classPxBatchQueryDesc.html#35d9cb33ded71261de0c7695d75ecba9" title="Size (in bytes) of the shared global filter data filterShaderData.">PxBatchQueryDesc.filterShaderDataSize</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f9f6115709370fc445c03c9da06b691"></a><!-- doxytag: member="PxBatchQuery::getOwnerClient" ref="3f9f6115709370fc445c03c9da06b691" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> PxBatchQuery::getOwnerClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the client specified with <a class="el" href="classPxBatchQueryDesc.html#9bca9313c79171e15a94615958672848" title="client that creates and owns this scene query.">PxBatchQueryDesc::ownerClient</a> at creation time. 
<p>
It is not possible to change this value after creating the scene query.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQueryDesc.html#9bca9313c79171e15a94615958672848" title="client that creates and owns this scene query.">PxBatchQueryDesc::ownerClient</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f12d7a7693f8f4101f51cb5582386a08"></a><!-- doxytag: member="PxBatchQuery::getPostFilterShader" ref="f12d7a7693f8f4101f51cb5582386a08" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0">PxBatchQueryPostFilterShader</a> PxBatchQuery::getPostFilterShader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the postfilter shader in use for this scene query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Postfilter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxBatchQueryDesc.preFilterShade <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c88db06732dd07d95fe006df755e094"></a><!-- doxytag: member="PxBatchQuery::getPreFilterShader" ref="5c88db06732dd07d95fe006df755e094" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b">PxBatchQueryPreFilterShader</a> PxBatchQuery::getPreFilterShader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the prefilter shader in use for this scene query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Prefilter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxBatchQueryDesc.preFilterShade <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="edffcfa27e47ef04274bb8180b42e913"></a><!-- doxytag: member="PxBatchQuery::getUserMemory" ref="edffcfa27e47ef04274bb8180b42e913" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structPxBatchQueryMemory.html">PxBatchQueryMemory</a>&amp; PxBatchQuery::getUserMemory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the user memory pointers. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2312bc0c82e54bbf46c16e203f9937e3"></a><!-- doxytag: member="PxBatchQuery::overlap" ref="2312bc0c82e54bbf46c16e203f9937e3" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, PxU16 maxTouchHits=0, const PxQueryFilterData &amp;filterData=PxQueryFilterData(), void *userData=NULL, const PxQueryCache *cache=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::overlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&nbsp;</td>
          <td class="paramname"> <em>maxTouchHits</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs an overlap test of a given geometry against objects in the scene, returns results in <a class="el" href="structPxBatchQueryMemory.html#7c54ac68c7049897accaa4520c418d1e" title="The pointer to the user-allocated buffer for results of overlap queries in corresponding...">PxBatchQueryMemory::userOverlapResultBuffer</a> specified at <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> creation time or via <a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2" title="Sets new user memory pointers.">PxBatchQuery::setUserMemory</a> call. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see <a class="el" href="structPxQueryHitType.html" title="Classification of scene query hits (intersections).">PxQueryHitType</a>).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxTouchHits</em>&nbsp;</td><td>Maximum number of hits to record in the touch buffer for this query. Default=0 reports a single blocking hit. If maxTouchHits is set to 0 all hits are treated as blocking by default. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. See <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>User can pass any value in this argument, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Query is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>eBLOCK should not be returned from user filters for <a class="el" href="classPxBatchQuery.html#2312bc0c82e54bbf46c16e203f9937e3" title="Performs an overlap test of a given geometry against objects in the scene, returns...">overlap()</a>. Doing so will result in undefined behavior, and a warning will be issued. <p>
If the <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f98467f45e717fa0f52652f52b0ff9798">PxQueryFlag::eNO_BLOCK</a> flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed. <p>
This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="39f64da3f122ff78cbaa1a5a83bc9840"></a><!-- doxytag: member="PxBatchQuery::raycast" ref="39f64da3f122ff78cbaa1a5a83bc9840" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, PxReal distance=PX_MAX_F32, PxU16 maxTouchHits=0, PxHitFlags hitFlags=PxHitFlag::eDEFAULT, const PxQueryFilterData &amp;filterData=PxQueryFilterData(), void *userData=NULL, const PxQueryCache *cache=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::raycast           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>PX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&nbsp;</td>
          <td class="paramname"> <em>maxTouchHits</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&nbsp;</td>
          <td class="paramname"> <em>hitFlags</em> = <code>PxHitFlag::eDEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a raycast against objects in the scene, returns results in <a class="el" href="structPxBatchQueryMemory.html#194b1ad50e68760d9499e253151c7d31" title="The pointer to the user-allocated buffer for results of raycast queries in corresponding...">PxBatchQueryMemory::userRaycastResultBuffer</a> specified at <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> creation time or via <a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2" title="Sets new user memory pointers.">PxBatchQuery::setUserMemory</a> call. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered. <p>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxTouchHits</em>&nbsp;</td><td>Maximum number of hits to record in the touch buffer for this query. Default=0 reports a single blocking hit. If maxTouchHits is set to 0 all hits are treated as blocking by default. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitFlags</em>&nbsp;</td><td>Specifies which properties per hit should be computed and returned in hit array and blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data passed to the filer shader. See <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>User can pass any value in this argument, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Query is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxRaycastHit.html" title="Stores results of raycast queries.">PxRaycastHit</a> <a class="el" href="classPxScene.html#7d7dcd877cee092f8b57c67d79982b50" title="Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer...">PxScene::raycast</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="623fdf0b33e7d51c1b5ca278d8f19a75"></a><!-- doxytag: member="PxBatchQuery::release" ref="623fdf0b33e7d51c1b5ca278d8f19a75" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> from <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>, <a class="el" href="classPxScene.html#080866698f34876134941cf42949592b" title="Creates a BatchQuery object.">PxScene.createBatchQuery</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca7ccdab697074ae572c7d0baf9af3c2"></a><!-- doxytag: member="PxBatchQuery::setUserMemory" ref="ca7ccdab697074ae572c7d0baf9af3c2" args="(const PxBatchQueryMemory &amp;)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::setUserMemory           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxBatchQueryMemory.html">PxBatchQueryMemory</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets new user memory pointers. 
<p>
It is not possible to change the memory during query execute.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf15206e4dcf2238db75f47565078b49"></a><!-- doxytag: member="PxBatchQuery::sweep" ref="bf15206e4dcf2238db75f47565078b49" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxU16 maxTouchHits=0, PxHitFlags hitFlags=PxHitFlag::eDEFAULT, const PxQueryFilterData &amp;filterData=PxQueryFilterData(), void *userData=NULL, const PxQueryCache *cache=NULL, const PxReal inflation=0.f)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::sweep           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&nbsp;</td>
          <td class="paramname"> <em>maxTouchHits</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&nbsp;</td>
          <td class="paramname"> <em>hitFlags</em> = <code>PxHitFlag::eDEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>inflation</em> = <code>0.f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a sweep test against objects in the scene, returns results in <a class="el" href="structPxBatchQueryMemory.html#21e15901b0b7e88fe8f59ea06dcff69e" title="The pointer to the user-allocated buffer for results of sweep queries in corresponding...">PxBatchQueryMemory::userSweepResultBuffer</a> specified at <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> creation time or via <a class="el" href="classPxBatchQuery.html#ca7ccdab697074ae572c7d0baf9af3c2" title="Sets new user memory pointers.">PxBatchQuery::setUserMemory</a> call. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered. <p>
If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxTouchHits</em>&nbsp;</td><td>Maximum number of hits to record in the touch buffer for this query. Default=0 reports a single blocking hit. If maxTouchHits is set to 0 all hits are treated as blocking by default. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitFlags</em>&nbsp;</td><td>Specifies which properties per hit should be computed and returned in hit array and blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. See <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>User can pass any value in this argument, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Query is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inflation</em>&nbsp;</td><td>This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal. Note: ePRECISE_SWEEP doesn't support inflation. Therefore the sweep will be performed with zero inflation.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxHitFlags <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxSweepHit.html" title="Stores results of sweep queries.">PxSweepHit</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxBatchQuery_8h-source.html">PxBatchQuery.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
