<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxRigidActor Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxRigidActor Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxRigidActor" --><!-- doxytag: inherits="PxActor" --><a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> represents a base class shared between dynamic and static rigid bodies in the physics SDK.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxRigidActor_8h-source.html">PxRigidActor.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxRigidActor:</div>
<div class="dynsection">
<p><center><img src="classPxRigidActor__inherit__graph.png" border="0" usemap="#PxRigidActor__inherit__map" alt="Inheritance graph"></center>
<map name="PxRigidActor__inherit__map">
<area shape="rect" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects." alt="PxRigidBody" coords="84,224,169,245"><area shape="rect" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK..." alt="PxRigidStatic" coords="193,224,279,245"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="PxActor" coords="155,85,208,107"><area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="153,16,209,37"><area shape="rect" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body" alt="PxArticulationLink" coords="7,293,116,315"><area shape="rect" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK." alt="PxRigidDynamic" coords="140,293,244,315"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidActor:</div>
<div class="dynsection">
<p><center><img src="classPxRigidActor__coll__graph.png" border="0" usemap="#PxRigidActor__coll__map" alt="Collaboration graph"></center>
<map name="PxRigidActor__coll__map">
<area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="PxActor" coords="99,178,152,200"><area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="97,106,153,128"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" alt="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" coords="7,16,244,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxRigidActor-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the rigid actor object.  <a href="#1130f92afcba590b04b1e51b86f5377a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global Pose Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#6eb5e3d590e6087c930f8141d40de722">getGlobalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actors world space transform.  <a href="#6eb5e3d590e6087c930f8141d40de722"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#26994d9594ed9a04bd412bdeb2a55f3e">setGlobalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for setting an actor's pose in the world.  <a href="#26994d9594ed9a04bd412bdeb2a55f3e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Shapes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#428112f88e7d3ee8abdf378cb70511f8">createShape</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, <a class="el" href="classPxMaterial.html">PxMaterial</a> *const *materials, PxU16 materialCount, <a class="el" href="classPxFlags.html">PxShapeFlags</a> shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor.  <a href="#428112f88e7d3ee8abdf378cb70511f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_DEPRECATED PX_FORCE_INLINE <br class="typebreak">
<a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#d72a72f5131a3ca166d31c435c22bb8c">createShape</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material, <a class="el" href="classPxFlags.html">PxShapeFlags</a> shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new shape with default properties and a single material adds it to the list of shapes of this actor.  <a href="#d72a72f5131a3ca166d31c435c22bb8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#17c7ab7d692e4b3b8239216aa0d6eeb7">attachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#467f9dc1517978b8d517936a475d3c4c">detachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape, bool wakeOnLostTouch=true)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#e5c3534de94642c5980d29f4c49bc112">getNbShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <a href="#e5c3534de94642c5980d29f4c49bc112"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#22ef86619d7a6de688b9ef2b0ad7bcec">getShapes</a> (<a class="el" href="classPxShape.html">PxShape</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the shape pointers belonging to the actor.  <a href="#22ef86619d7a6de688b9ef2b0ad7bcec"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Constraints</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#d941cfa63351e7ff6095a4afbe2d9172">getNbConstraints</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of constraint shaders attached to the actor.  <a href="#d941cfa63351e7ff6095a4afbe2d9172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#c88777d5457f87247f5625094eb2be57">getConstraints</a> (<a class="el" href="classPxConstraint.html">PxConstraint</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the constraint shader pointers belonging to the actor.  <a href="#c88777d5457f87247f5625094eb2be57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ea61d8192d25e64cefbbdc5f6d68a39b">PxRigidActor</a> (<a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#bc3690608611b90d1efd033e804fd774">PxRigidActor</a> (<a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#aa01a5b7ff077d01da077a5c8163609f">~PxRigidActor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#e644382039f621f73ca7db7aa9d2e0cf">isKindOf</a> (const char *name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#e644382039f621f73ca7db7aa9d2e0cf"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> represents a base class shared between dynamic and static rigid bodies in the physics SDK. 
<p>
<a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> objects specify the geometry of the object by defining a set of attached shapes (see <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>, <a class="el" href="classPxRigidActor.html#428112f88e7d3ee8abdf378cb70511f8" title="Creates a new shape with default properties and a list of materials and adds it to...">createShape()</a>).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ea61d8192d25e64cefbbdc5f6d68a39b"></a><!-- doxytag: member="PxRigidActor::PxRigidActor" ref="ea61d8192d25e64cefbbdc5f6d68a39b" args="(PxType concreteType, PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidActor::PxRigidActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a>&nbsp;</td>
          <td class="paramname"> <em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bc3690608611b90d1efd033e804fd774"></a><!-- doxytag: member="PxRigidActor::PxRigidActor" ref="bc3690608611b90d1efd033e804fd774" args="(PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidActor::PxRigidActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aa01a5b7ff077d01da077a5c8163609f"></a><!-- doxytag: member="PxRigidActor::~PxRigidActor" ref="aa01a5b7ff077d01da077a5c8163609f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidActor::~PxRigidActor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="17c7ab7d692e4b3b8239216aa0d6eeb7"></a><!-- doxytag: member="PxRigidActor::attachShape" ref="17c7ab7d692e4b3b8239216aa0d6eeb7" args="(PxShape &amp;shape)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidActor::attachShape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
attach a shared shape to an actor<p>
This call will increment the reference count of the shape.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Mass properties of dynamic rigid actors will not automatically be recomputed to reflect the new mass distribution implied by the shape. Follow this call with a call to the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#769be90cdb138897ce426aa04ac0a1e7" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a> to do that.</dd></dl>
Attaching a triangle mesh, heightfield or plane geometry shape configured as eSIMULATION_SHAPE is not supported for non-kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> instances.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>the shape to attach. </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="PxRigidActorExt_8h-source.html#l00086">PxRigidActorExt::createExclusiveShape()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d72a72f5131a3ca166d31c435c22bb8c"></a><!-- doxytag: member="PxRigidActor::createShape" ref="d72a72f5131a3ca166d31c435c22bb8c" args="(const PxGeometry &amp;geometry, const PxMaterial &amp;material, PxShapeFlags shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_DEPRECATED PX_FORCE_INLINE <a class="el" href="classPxShape.html">PxShape</a>* PxRigidActor::createShape           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>shapeFlags</em> = <code>PxShapeFlag::eVISUALIZATION&nbsp;|&nbsp;PxShapeFlag::eSCENE_QUERY_SHAPE&nbsp;|&nbsp;PxShapeFlag::eSIMULATION_SHAPE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new shape with default properties and a single material adds it to the list of shapes of this actor. 
<p>
This is equivalent to the following<p>
PxShape* shape(...) = <a class="el" href="group__physics.html#g824f991be62d7c28eadf32316562408f" title="Retrieves the Physics SDK after it has been created.">PxGetPhysics()</a>.createShape(...); // reference count is 1 actor-&gt;attachShape(shape); // increments reference count shape-&gt;<a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object.">release()</a>; // releases user reference, leaving reference count at 1<p>
As a consequence, <a class="el" href="classPxRigidActor.html#467f9dc1517978b8d517936a475d3c4c">detachShape()</a> will result in the release of the last reference, and the shape will be deleted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>). Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for non-kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> instances.<p>
Creating compounds with a very large number of shapes may adversely affect performance and stability.</dd></dl>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeFlags</em>&nbsp;</td><td>optional PxShapeFlags</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The newly created shape.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this method is <b>deprecated</b>, please use <a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics::createShape()</a> and <a class="el" href="classPxRigidActor.html#17c7ab7d692e4b3b8239216aa0d6eeb7">PxRigidActor::attachShape()</a> or <a class="el" href="classPxRigidActorExt.html#e708f5ca3fc5f1ce3db14032a89f62b9" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActorExt::createExclusiveShape()</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Decrements the reference count of a shape and releases it if the new reference count...">PxShape::release()</a>, <a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics::createShape()</a>, <a class="el" href="classPxRigidActor.html#17c7ab7d692e4b3b8239216aa0d6eeb7">PxRigidActor::attachShape()</a>, <a class="el" href="classPxRigidActorExt.html#e708f5ca3fc5f1ce3db14032a89f62b9" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActorExt::createExclusiveShape()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="428112f88e7d3ee8abdf378cb70511f8"></a><!-- doxytag: member="PxRigidActor::createShape" ref="428112f88e7d3ee8abdf378cb70511f8" args="(const PxGeometry &amp;geometry, PxMaterial *const *materials, PxU16 materialCount, PxShapeFlags shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxShape.html">PxShape</a>* PxRigidActor::createShape           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> *const *&nbsp;</td>
          <td class="paramname"> <em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&nbsp;</td>
          <td class="paramname"> <em>materialCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>shapeFlags</em> = <code>PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor. 
<p>
This is equivalent to the following<p>
PxShape* shape(...) = <a class="el" href="group__physics.html#g824f991be62d7c28eadf32316562408f" title="Retrieves the Physics SDK after it has been created.">PxGetPhysics()</a>.createShape(...); // reference count is 1 actor-&gt;attachShape(shape); // increments reference count shape-&gt;<a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object.">release()</a>; // releases user reference, leaving reference count at 1<p>
As a consequence, <a class="el" href="classPxRigidActor.html#467f9dc1517978b8d517936a475d3c4c">detachShape()</a> will result in the release of the last reference, and the shape will be deleted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>). Triangle mesh, heightfield or plane geometry shapes configured as eSIMULATION_SHAPE are not supported for non-kinematic <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> instances.<p>
Creating compounds with a very large number of shapes may adversely affect performance and stability.</dd></dl>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materials</em>&nbsp;</td><td>a pointer to an array of material pointers </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materialCount</em>&nbsp;</td><td>the count of materials </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeFlags</em>&nbsp;</td><td>optional PxShapeFlags</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The newly created shape.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this method is <b>deprecated</b>, please use <a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics::createShape()</a> and <a class="el" href="classPxRigidActor.html#17c7ab7d692e4b3b8239216aa0d6eeb7">PxRigidActor::attachShape()</a> or <a class="el" href="classPxRigidActorExt.html#e708f5ca3fc5f1ce3db14032a89f62b9" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActorExt::createExclusiveShape()</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Decrements the reference count of a shape and releases it if the new reference count...">PxShape::release()</a>, <a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics::createShape()</a>, <a class="el" href="classPxRigidActor.html#17c7ab7d692e4b3b8239216aa0d6eeb7">PxRigidActor::attachShape()</a>, <a class="el" href="classPxRigidActorExt.html#e708f5ca3fc5f1ce3db14032a89f62b9" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActorExt::createExclusiveShape()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="467f9dc1517978b8d517936a475d3c4c"></a><!-- doxytag: member="PxRigidActor::detachShape" ref="467f9dc1517978b8d517936a475d3c4c" args="(PxShape &amp;shape, bool wakeOnLostTouch=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidActor::detachShape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeOnLostTouch</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
detach a shape from an actor.<p>
This will also decrement the reference count of the <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>, and if the reference count is zero, will cause it to be deleted.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>the shape to detach. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeOnLostTouch</em>&nbsp;</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> and <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> types. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c88777d5457f87247f5625094eb2be57"></a><!-- doxytag: member="PxRigidActor::getConstraints" ref="c88777d5457f87247f5625094eb2be57" args="(PxConstraint **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxRigidActor::getConstraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConstraint.html">PxConstraint</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the constraint shader pointers belonging to the actor. 
<p>
You can retrieve the number of constraint shader pointers by calling <a class="el" href="classPxRigidActor.html#d941cfa63351e7ff6095a4afbe2d9172" title="Returns the number of constraint shaders attached to the actor.">getNbConstraints()</a><p>
Note: Removing constraint shaders with <a class="el" href="classPxConstraint.html#8153c211d21fff49565e7e06e475d5cc" title="Releases a PxConstraint instance.">PxConstraint::release()</a> will invalidate the pointer of the released constraint.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the constraint shader pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first constraint pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of constraint shader pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> <a class="el" href="classPxRigidActor.html#d941cfa63351e7ff6095a4afbe2d9172" title="Returns the number of constraint shaders attached to the actor.">getNbConstraints()</a> <a class="el" href="classPxConstraint.html#8153c211d21fff49565e7e06e475d5cc" title="Releases a PxConstraint instance.">PxConstraint::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6eb5e3d590e6087c930f8141d40de722"></a><!-- doxytag: member="PxRigidActor::getGlobalPose" ref="6eb5e3d590e6087c930f8141d40de722" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxRigidActor::getGlobalPose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the actors world space transform. 
<p>
The <a class="el" href="classPxRigidActor.html#6eb5e3d590e6087c930f8141d40de722" title="Retrieves the actors world space transform.">getGlobalPose()</a> method retrieves the actor's current actor space to world space transformation.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Global pose of object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#26994d9594ed9a04bd412bdeb2a55f3e" title="Method for setting an actor&#39;s pose in the world.">PxRigidDynamic.setGlobalPose()</a> <a class="el" href="classPxRigidActor.html#26994d9594ed9a04bd412bdeb2a55f3e" title="Method for setting an actor&#39;s pose in the world.">PxRigidStatic.setGlobalPose()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxShapeExt_8h-source.html#l00065">PxShapeExt::getGlobalPose()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d941cfa63351e7ff6095a4afbe2d9172"></a><!-- doxytag: member="PxRigidActor::getNbConstraints" ref="d941cfa63351e7ff6095a4afbe2d9172" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxRigidActor::getNbConstraints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of constraint shaders attached to the actor. 
<p>
You can use <a class="el" href="classPxRigidActor.html#c88777d5457f87247f5625094eb2be57" title="Retrieve all the constraint shader pointers belonging to the actor.">getConstraints()</a> to retrieve the constraint shader pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of constraint shaders attached to this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> <a class="el" href="classPxRigidActor.html#c88777d5457f87247f5625094eb2be57" title="Retrieve all the constraint shader pointers belonging to the actor.">getConstraints()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5c3534de94642c5980d29f4c49bc112"></a><!-- doxytag: member="PxRigidActor::getNbShapes" ref="e5c3534de94642c5980d29f4c49bc112" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxRigidActor::getNbShapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of shapes assigned to the actor. 
<p>
You can use <a class="el" href="classPxRigidActor.html#22ef86619d7a6de688b9ef2b0ad7bcec" title="Retrieve all the shape pointers belonging to the actor.">getShapes()</a> to retrieve the shape pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of shapes associated with this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxRigidActor.html#22ef86619d7a6de688b9ef2b0ad7bcec" title="Retrieve all the shape pointers belonging to the actor.">getShapes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="22ef86619d7a6de688b9ef2b0ad7bcec"></a><!-- doxytag: member="PxRigidActor::getShapes" ref="22ef86619d7a6de688b9ef2b0ad7bcec" args="(PxShape **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxRigidActor::getShapes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the shape pointers belonging to the actor. 
<p>
These are the shapes used by the actor for collision detection.<p>
You can retrieve the number of shape pointers by calling <a class="el" href="classPxRigidActor.html#e5c3534de94642c5980d29f4c49bc112" title="Returns the number of shapes assigned to the actor.">getNbShapes()</a><p>
Note: Removing shapes with <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Decrements the reference count of a shape and releases it if the new reference count...">PxShape::release()</a> will invalidate the pointer of the released shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the shape pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first shape pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of shape pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxRigidActor.html#e5c3534de94642c5980d29f4c49bc112" title="Returns the number of shapes assigned to the actor.">getNbShapes()</a> <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Decrements the reference count of a shape and releases it if the new reference count...">PxShape::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e644382039f621f73ca7db7aa9d2e0cf"></a><!-- doxytag: member="PxRigidActor::isKindOf" ref="e644382039f621f73ca7db7aa9d2e0cf" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidActor::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>superClass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a given type name matches with the type of this instance. 
<p>

<p>Reimplemented from <a class="el" href="classPxActor.html#fe6ddb3480f61350f60496c2e903c5c7">PxActor</a>.</p>

<p>Reimplemented in <a class="el" href="classPxArticulationLink.html#45d7a988876af31572acca1376401c18">PxArticulationLink</a>, <a class="el" href="classPxRigidBody.html#d2e17e08871d8a2f492aee495550a0a0">PxRigidBody</a>, <a class="el" href="classPxRigidDynamic.html#0ed60c0a05771d8679069a46b778f8f8">PxRigidDynamic</a>, and <a class="el" href="classPxRigidStatic.html#b8f40a26cecf625a44d573d611e20842">PxRigidStatic</a>.</p>

<p>References <a class="el" href="PxActor_8h-source.html#l00377">PxActor::isKindOf()</a>.</p>

<p>Referenced by <a class="el" href="PxRigidStatic_8h-source.html#l00068">PxRigidStatic::isKindOf()</a>, and <a class="el" href="PxRigidBody_8h-source.html#l00562">PxRigidBody::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1130f92afcba590b04b1e51b86f5377a"></a><!-- doxytag: member="PxRigidActor::release" ref="1130f92afcba590b04b1e51b86f5377a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidActor::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the rigid actor object. 
<p>
Also releases any shapes associated with the actor.<p>
Releasing an actor will affect any objects that are connected to the actor (constraint shaders like joints etc.). Such connected objects will be deleted upon scene deletion, or explicitly by the user by calling <a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object.">release()</a> on these objects. It is recommended to always remove all objects that reference actors before the actors themselves are removed. It is not possible to retrieve list of dead connected objects.<p>
<b>Sleeping:</b> This call will awaken any sleeping actors contacting the deleted actor (directly or indirectly).<p>
Calls <a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762" title="Deletes the actor.">PxActor::release()</a> so you might want to check the documentation of that method as well.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762" title="Deletes the actor.">PxActor::release()</a> </dd></dl>

<p>Implements <a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762">PxActor</a>.</p>

<p>Implemented in <a class="el" href="classPxArticulationLink.html#ec08ba9942f441a813bdd07547d9b695">PxArticulationLink</a>.</p>

</div>
</div><p>
<a class="anchor" name="26994d9594ed9a04bd412bdeb2a55f3e"></a><!-- doxytag: member="PxRigidActor::setGlobalPose" ref="26994d9594ed9a04bd412bdeb2a55f3e" args="(const PxTransform &amp;pose, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidActor::setGlobalPose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for setting an actor's pose in the world. 
<p>
This method instantaneously changes the actor space to world space transformation.<p>
This method is mainly for dynamic rigid bodies (see <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>). Calling this method on static actors is likely to result in a performance penalty, since internal optimization structures for static actors may need to be recomputed. In addition, moving static actors will not interact correctly with dynamic actors or joints.<p>
To directly control an actor's position and have it correctly interact with dynamic bodies and joints, create a dynamic body with the <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596bd76e6985e9db78efb7a66148ea4c212" title="Enables kinematic mode for the actor.">PxRigidBodyFlag::eKINEMATIC</a> flag, then use the setKinematicTarget() commands to define its path.<p>
Even when moving dynamic actors, exercise restraint in making use of this method. Where possible, avoid:<p>
<ul>
<li>moving actors into other actors, thus causing overlap (an invalid physical state)</li>
</ul>
<ul>
<li>moving an actor that is connected by a joint to another away from the other (thus causing joint error)</li>
</ul>
<b>Sleeping:</b> This call wakes dynamic actors if they are sleeping and the autowake parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Transformation from the actors local frame to the global frame. <b>Range:</b> rigid body transform. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>whether to wake the object if it is dynamic. This parameter has no effect for static or kinematic actors. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#6eb5e3d590e6087c930f8141d40de722" title="Retrieves the actors world space transform.">getGlobalPose()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidActor_8h-source.html">PxRigidActor.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
