<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxSimulationEventCallback Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxSimulationEventCallback Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxSimulationEventCallback" -->An interface class that the user can implement in order to receive simulation events.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxSimulationEventCallback_8h-source.html">PxSimulationEventCallback.h</a>&gt;</code>
<p>

<p>
<a href="classPxSimulationEventCallback-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#67c6553ee9090481ece8b041502eb948">onConstraintBreak</a> (<a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a> *constraints, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called when a breakable constraint breaks.  <a href="#67c6553ee9090481ece8b041502eb948"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#37e6f45b530cfb8536bc2ff14f38e2fe">onWake</a> (<a class="el" href="classPxActor.html">PxActor</a> **actors, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called with the actors which have just been woken up.  <a href="#37e6f45b530cfb8536bc2ff14f38e2fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#614256e6c2570e24cf45e974d6087d38">onSleep</a> (<a class="el" href="classPxActor.html">PxActor</a> **actors, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called with the actors which have just been put to sleep.  <a href="#614256e6c2570e24cf45e974d6087d38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#4dc1da28643ccf9f77c8432b5eb2fd32">onContact</a> (const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> &amp;pairHeader, const <a class="el" href="structPxContactPair.html">PxContactPair</a> *pairs, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbPairs)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called when certain contact events occur.  <a href="#4dc1da28643ccf9f77c8432b5eb2fd32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#768b2ee9fe28736da3fcdc6a0eae9733">onTrigger</a> (<a class="el" href="structPxTriggerPair.html">PxTriggerPair</a> *pairs, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called with the current trigger pair events.  <a href="#768b2ee9fe28736da3fcdc6a0eae9733"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#86cd9bd80e504054d075fda24498756b">onAdvance</a> (const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> *const *bodyBuffer, const <a class="el" href="classPxTransform.html">PxTransform</a> *poseBuffer, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides early access to the new pose of moving rigid bodies.  <a href="#86cd9bd80e504054d075fda24498756b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSimulationEventCallback.html#e97f7e6f3dbccaeef1e3fa1578862e88">~PxSimulationEventCallback</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An interface class that the user can implement in order to receive simulation events. 
<p>
With the exception of <a class="el" href="classPxSimulationEventCallback.html#86cd9bd80e504054d075fda24498756b" title="Provides early access to the new pose of moving rigid bodies.">onAdvance()</a>, the events get sent during the call to either <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> or <a class="el" href="classPxScene.html#b557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory.">PxScene::flushSimulation()</a> with sendPendingReports=true. <a class="el" href="classPxSimulationEventCallback.html#86cd9bd80e504054d075fda24498756b" title="Provides early access to the new pose of moving rigid bodies.">onAdvance()</a> gets called while the simulation is running (that is between <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>/advance() and <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a>).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>SDK state should not be modified from within the callbacks. In particular objects should not be created or destroyed. If state modification is needed then the changes should be stored to a buffer and performed after the simulation step.</dd></dl>
<b>Threading:</b> With the exception of <a class="el" href="classPxSimulationEventCallback.html#86cd9bd80e504054d075fda24498756b" title="Provides early access to the new pose of moving rigid bodies.">onAdvance()</a>, it is not necessary to make these callbacks thread safe as they will only be called in the context of the user thread.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxScene.html#1eb6366fd80f5a8f6a9154a412c33436" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback()...">PxScene.getSimulationEventCallback()</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e97f7e6f3dbccaeef1e3fa1578862e88"></a><!-- doxytag: member="PxSimulationEventCallback::~PxSimulationEventCallback" ref="e97f7e6f3dbccaeef1e3fa1578862e88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxSimulationEventCallback::~PxSimulationEventCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="86cd9bd80e504054d075fda24498756b"></a><!-- doxytag: member="PxSimulationEventCallback::onAdvance" ref="86cd9bd80e504054d075fda24498756b" args="(const PxRigidBody *const *bodyBuffer, const PxTransform *poseBuffer, const PxU32 count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onAdvance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> *const *&nbsp;</td>
          <td class="paramname"> <em>bodyBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>poseBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides early access to the new pose of moving rigid bodies. 
<p>
When this call occurs, rigid bodies having the <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596c89b33b0290d667f6f2ae69298631d01" title="Register a rigid body for reporting pose changes by the simulation at an early stage...">PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW</a> flag set, were moved by the simulation and their new poses can be accessed through the provided buffers.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The provided buffers are valid and can be read until the next call to <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a> or <a class="el" href="classPxScene.html#17c3863f711ef79c08c6054b69fd430c" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>.<p>
Buffered user changes to the rigid body pose will not yet be reflected in the provided data. More important, the provided data might contain bodies that have been deleted while the simulation was running. It is the user's responsibility to detect and avoid dereferencing such bodies.<p>
This callback gets triggered while the simulation is running. If the provided rigid body references are used to read properties of the object, then the callback has to guarantee no other thread is writing to the same body at the same time.<p>
The code in this callback should be lightweight as it can block the simulation, that is, the <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> call.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bodyBuffer</em>&nbsp;</td><td>The rigid bodies that moved and requested early pose reporting. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poseBuffer</em>&nbsp;</td><td>The integrated rigid body poses of the bodies listed in bodyBuffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The number of entries in the provided buffers.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596c89b33b0290d667f6f2ae69298631d01" title="Register a rigid body for reporting pose changes by the simulation at an early stage...">PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="67c6553ee9090481ece8b041502eb948"></a><!-- doxytag: member="PxSimulationEventCallback::onConstraintBreak" ref="67c6553ee9090481ece8b041502eb948" args="(PxConstraintInfo *constraints, PxU32 count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onConstraintBreak           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxConstraintInfo.html">PxConstraintInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called when a breakable constraint breaks. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The user should not release the constraint shader inside this call!<p>
No event will get reported if the constraint breaks but gets deleted while the time step is still being simulated.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constraints</em>&nbsp;</td><td>- The constraints which have been broken. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>- The number of constraints</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> PxConstraintDesc.linearBreakForce PxConstraintDesc.angularBreakForce </dd></dl>

</div>
</div><p>
<a class="anchor" name="4dc1da28643ccf9f77c8432b5eb2fd32"></a><!-- doxytag: member="PxSimulationEventCallback::onContact" ref="4dc1da28643ccf9f77c8432b5eb2fd32" args="(const PxContactPairHeader &amp;pairHeader, const PxContactPair *pairs, PxU32 nbPairs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onContact           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pairHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxContactPair.html">PxContactPair</a> *&nbsp;</td>
          <td class="paramname"> <em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbPairs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called when certain contact events occur. 
<p>
The method will be called for a pair of actors if one of the colliding shape pairs requested contact notification. You request which events are reported using the filter shader/callback mechanism (see <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a>, <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a>, <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>).<p>
Do not keep references to the passed objects, as they will be invalid after this function returns.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pairHeader</em>&nbsp;</td><td>Information on the two actors whose shapes triggered a contact report. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pairs</em>&nbsp;</td><td>The contact pairs of two actors for which contact reports have been requested. See <a class="el" href="structPxContactPair.html" title="Contact report pair information.">PxContactPair</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbPairs</em>&nbsp;</td><td>The number of provided contact pairs.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxContactPair.html" title="Contact report pair information.">PxContactPair</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="614256e6c2570e24cf45e974d6087d38"></a><!-- doxytag: member="PxSimulationEventCallback::onSleep" ref="614256e6c2570e24cf45e974d6087d38" args="(PxActor **actors, PxU32 count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onSleep           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td>
          <td class="paramname"> <em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called with the actors which have just been put to sleep. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only supported by rigid bodies yet. <p>
Only called on actors for which the <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> eSEND_SLEEP_NOTIFIES has been set. <p>
Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is asleep, then A-&gt;wakeUp() gets called, then later A-&gt;putToSleep() gets called. At the next simulate/fetchResults() step only an <a class="el" href="classPxSimulationEventCallback.html#614256e6c2570e24cf45e974d6087d38" title="This is called with the actors which have just been put to sleep.">onSleep()</a> event will get triggered because that was the last transition (assuming the simulation does not wake the actor up). <p>
If an actor gets newly added to a scene with properties such that it is asleep and the sleep state does not get changed by the user or simulation, then an <a class="el" href="classPxSimulationEventCallback.html#614256e6c2570e24cf45e974d6087d38" title="This is called with the actors which have just been put to sleep.">onSleep()</a> event will get sent at the next simulate/fetchResults() step.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actors</em>&nbsp;</td><td>- The actors which have just been put to sleep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>- The number of actors</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> <a class="el" href="classPxActor.html#e24ff3f3ed0cb2a138b382fd0720b94f" title="Raises or clears a particular actor flag.">PxActor.setActorFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="768b2ee9fe28736da3fcdc6a0eae9733"></a><!-- doxytag: member="PxSimulationEventCallback::onTrigger" ref="768b2ee9fe28736da3fcdc6a0eae9733" args="(PxTriggerPair *pairs, PxU32 count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onTrigger           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxTriggerPair.html">PxTriggerPair</a> *&nbsp;</td>
          <td class="paramname"> <em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called with the current trigger pair events. 
<p>
Shapes which have been marked as triggers using <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1aef2b90024dc86be72b68bbaf94a5821d" title="The shape is a trigger which can send reports whenever other shapes enter/leave its...">PxShapeFlag::eTRIGGER_SHAPE</a> will send events according to the pair flag specification in the filter shader (see <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>, <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a>).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Trigger shapes will no longer send notification events for interactions with other trigger shapes. For PhysX 3.4 there is the option to re-enable the reports by raising <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c531d29a32a585c1463b30332ee8e328cad" title="Enable legacy behavior to get trigger reports for interactions between two trigger...">PxSceneFlag::eDEPRECATED_TRIGGER_TRIGGER_REPORTS</a>. In PhysX 3.5 there will be no support for these reports any longer. See the 3.4 migration guide for more information.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pairs</em>&nbsp;</td><td>- The trigger pair events. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>- The number of trigger pair events.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#3c879df184ef40514589c5aa3d1f2a33" title="Sets shape flags.">PxShape.setFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="37e6f45b530cfb8536bc2ff14f38e2fe"></a><!-- doxytag: member="PxSimulationEventCallback::onWake" ref="37e6f45b530cfb8536bc2ff14f38e2fe" args="(PxActor **actors, PxU32 count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxSimulationEventCallback::onWake           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td>
          <td class="paramname"> <em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called with the actors which have just been woken up. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only supported by rigid bodies yet. <p>
Only called on actors for which the <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> eSEND_SLEEP_NOTIFIES has been set. <p>
Only the latest sleep state transition happening between fetchResults() of the previous frame and fetchResults() of the current frame will get reported. For example, let us assume actor A is awake, then A-&gt;putToSleep() gets called, then later A-&gt;wakeUp() gets called. At the next simulate/fetchResults() step only an <a class="el" href="classPxSimulationEventCallback.html#37e6f45b530cfb8536bc2ff14f38e2fe" title="This is called with the actors which have just been woken up.">onWake()</a> event will get triggered because that was the last transition. <p>
If an actor gets newly added to a scene with properties such that it is awake and the sleep state does not get changed by the user or simulation, then an <a class="el" href="classPxSimulationEventCallback.html#37e6f45b530cfb8536bc2ff14f38e2fe" title="This is called with the actors which have just been woken up.">onWake()</a> event will get sent at the next simulate/fetchResults() step.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actors</em>&nbsp;</td><td>- The actors which just woke up. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>- The number of actors</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941" title="Possible notification callback.">PxSceneDesc.simulationEventCallback</a> <a class="el" href="structPxActorFlag.html" title="Flags which control the behavior of an actor.">PxActorFlag</a> <a class="el" href="classPxActor.html#e24ff3f3ed0cb2a138b382fd0720b94f" title="Raises or clears a particular actor flag.">PxActor.setActorFlag()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxSimulationEventCallback_8h-source.html">PxSimulationEventCallback.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
