<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxPhysics Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxPhysics Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxPhysics" -->Abstract singleton factory class used for instancing objects in the Physics SDK.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxPhysics_8h-source.html">PxPhysics.h</a>&gt;</code>
<p>

<p>
<a href="classPxPhysics-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Basics</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#5d2cea62dd20865d8c13b8d07bd6fb60">~PxPhysics</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#795e11d0e5ed6ac50af9c656f6a67e37">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the instance it is called on.  <a href="#795e11d0e5ed6ac50af9c656f6a67e37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFoundation.html">PxFoundation</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1c2899065d7b3d9367a409b0207848cc">getFoundation</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the Foundation instance.  <a href="#1c2899065d7b3d9367a409b0207848cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#4209ffb5ab43cd7d9c6a59e4139c1993">createAggregate</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxSize, bool enableSelfCollision)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an aggregate with the specified maximum size and selfCollision property.  <a href="#4209ffb5ab43cd7d9c6a59e4139c1993"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#e6b06e75ab03222d301a15e14c5ac467">getTolerancesScale</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the simulation tolerance parameters.  <a href="#e6b06e75ab03222d301a15e14c5ac467"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Meshes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd">createTriangleMesh</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a triangle mesh object.  <a href="#29dcbbe128cef11eaf4ce5696c216dfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#91183bc0ffba9000a0f76bf4d9bf5fa2">getNbTriangleMeshes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of triangle meshes that currently exist.  <a href="#91183bc0ffba9000a0f76bf4d9bf5fa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#a781fee3bcd9ea28cfaa45717c4a8738">getTriangleMeshes</a> (<a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of triangle mesh pointers to a user buffer.  <a href="#a781fee3bcd9ea28cfaa45717c4a8738"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1806546c22306e8d44b7ff7719fbcc99">createHeightField</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a heightfield object from previously cooked stream.  <a href="#1806546c22306e8d44b7ff7719fbcc99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#92275b36165ce356aa217d17fbb3ac2c">getNbHeightFields</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of heightfields that currently exist.  <a href="#92275b36165ce356aa217d17fbb3ac2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#d2470ec4f7a3b36664f92d08c3b42ba7">getHeightFields</a> (<a class="el" href="classPxHeightField.html">PxHeightField</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of heightfield pointers to a user buffer.  <a href="#d2470ec4f7a3b36664f92d08c3b42ba7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#54fc5f8b0884977ccfd45ea829392a52">createConvexMesh</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a convex mesh object.  <a href="#54fc5f8b0884977ccfd45ea829392a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#372b961576ee45702d02618933e8db0d">getNbConvexMeshes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of convex meshes that currently exist.  <a href="#372b961576ee45702d02618933e8db0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#f842c37b9e11bf180465452e8dacfc06">getConvexMeshes</a> (<a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of convex mesh pointers to a user buffer.  <a href="#f842c37b9e11bf180465452e8dacfc06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxClothFabric.html">PxClothFabric</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#aff72c208eb0bb4faa418c1f258707d9">createClothFabric</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a cloth fabric object.  <a href="#aff72c208eb0bb4faa418c1f258707d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxClothFabric.html">PxClothFabric</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#b8e37d6f27087b93515e8a39d4ad7179">createClothFabric</a> (const <a class="el" href="classPxClothFabricDesc.html">PxClothFabricDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a cloth fabric object from particle connectivity and restlength information.  <a href="#b8e37d6f27087b93515e8a39d4ad7179"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#5c0990eef79ed840ea0cc88d0f952111">getNbClothFabrics</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of cloth fabrics that currently exist.  <a href="#5c0990eef79ed840ea0cc88d0f952111"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#b66ea589cfffdd5948771b885f2121ad">getClothFabrics</a> (<a class="el" href="classPxClothFabric.html">PxClothFabric</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of cloth fabrics to a user buffer.  <a href="#b66ea589cfffdd5948771b885f2121ad"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scenes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1">createScene</a> (const <a class="el" href="classPxSceneDesc.html">PxSceneDesc</a> &amp;sceneDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a scene.  <a href="#6dcded7be00c17004432a04a78569db1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#f6181c2f379b52712bece3f7639fab1e">getNbScenes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets number of created scenes.  <a href="#f6181c2f379b52712bece3f7639fab1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1ecd80a6f7c5239bd6cc50c5ea76156d">getScenes</a> (<a class="el" href="classPxScene.html">PxScene</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of scene pointers to a user buffer.  <a href="#1ecd80a6f7c5239bd6cc50c5ea76156d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Actors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#82949b1375677a8c58d64c7cd47b7f4b">createRigidStatic</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a static rigid actor with the specified pose and all other fields initialized to their default values.  <a href="#82949b1375677a8c58d64c7cd47b7f4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#58d338d214918182945c8fcb99325e20">createRigidDynamic</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a dynamic rigid actor with the specified pose and all other fields initialized to their default values.  <a href="#58d338d214918182945c8fcb99325e20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxParticleSystem.html">PxParticleSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#fc569d866211bc45d7ab01002a0dadca">createParticleSystem</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxParticles, bool perParticleRestOffset=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a particle system. (deprecated).  <a href="#fc569d866211bc45d7ab01002a0dadca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxParticleFluid.html">PxParticleFluid</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#ea19c431d479c76fe44f64291c872744">createParticleFluid</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxParticles, bool perParticleRestOffset=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a particle fluid. (deprecated).  <a href="#ea19c431d479c76fe44f64291c872744"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <a class="el" href="classPxCloth.html">PxCloth</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1aa15d80d32aa15a3fdcd9c26fb3f3eb">createCloth</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;globalPose, <a class="el" href="classPxClothFabric.html">PxClothFabric</a> &amp;fabric, const <a class="el" href="structPxClothParticle.html">PxClothParticle</a> *particles, <a class="el" href="classPxFlags.html">PxClothFlags</a> flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a cloth.  <a href="#1aa15d80d32aa15a3fdcd9c26fb3f3eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxPruningStructure.html">PxPruningStructure</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#5c62ebf74c105e7ecf3eaba6949a42fa">createPruningStructure</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *const *actors, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbActors)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a pruning structure from actors.  <a href="#5c62ebf74c105e7ecf3eaba6949a42fa"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Shapes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_FORCE_INLINE <a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe">createShape</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material, bool isExclusive=false, <a class="el" href="classPxFlags.html">PxShapeFlags</a> shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a shape which may be attached to multiple actors.  <a href="#bc564607f208cbc1944880172a3d62fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#fde7d3527975abe62c8b4951d9e69978">createShape</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, <a class="el" href="classPxMaterial.html">PxMaterial</a> *const *materials, PxU16 materialCount, bool isExclusive=false, <a class="el" href="classPxFlags.html">PxShapeFlags</a> shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a shape which may be attached to multiple actors.  <a href="#fde7d3527975abe62c8b4951d9e69978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#084ff8d2b32c74056f95580cbb2a0cb3">getNbShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of shapes that currently exist.  <a href="#084ff8d2b32c74056f95580cbb2a0cb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#f8a7ab6d85ff7232e622a7127f5e2528">getShapes</a> (<a class="el" href="classPxShape.html">PxShape</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of shape pointers to a user buffer.  <a href="#f8a7ab6d85ff7232e622a7127f5e2528"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraints and Articulations</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxConstraint.html">PxConstraint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1126f3f545ebe183be1753f62d1efc7d">createConstraint</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, <a class="el" href="classPxConstraintConnector.html">PxConstraintConnector</a> &amp;connector, const <a class="el" href="structPxConstraintShaderTable.html">PxConstraintShaderTable</a> &amp;shaders, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> dataSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a constraint shader.  <a href="#1126f3f545ebe183be1753f62d1efc7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxArticulation.html">PxArticulation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#a65bf245c40886f007b7cda86dee9f3f">createArticulation</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an articulation with all fields initialized to their default values.  <a href="#a65bf245c40886f007b7cda86dee9f3f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Materials</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#35c1965ae47b24e119c6a2d8ce25477e">createMaterial</a> (PxReal staticFriction, PxReal dynamicFriction, PxReal restitution)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new material with default properties.  <a href="#35c1965ae47b24e119c6a2d8ce25477e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#051662877c0f3346ac7fa4f1bf4bcd95">getNbMaterials</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of materials that currently exist.  <a href="#051662877c0f3346ac7fa4f1bf4bcd95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1a9cabf0c8c0f11d7eb7e948be2e32b0">getMaterials</a> (<a class="el" href="classPxMaterial.html">PxMaterial</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of material pointers to a user buffer.  <a href="#1a9cabf0c8c0f11d7eb7e948be2e32b0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Deletion Listeners</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#3eabed665fe069eed00fca73da25ae2b">registerDeletionListener</a> (<a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;observer, const <a class="el" href="classPxFlags.html">PxDeletionEventFlags</a> &amp;deletionEvents, bool restrictedObjectSet=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a deletion listener. Listeners will be called whenever an object is deleted.  <a href="#3eabed665fe069eed00fca73da25ae2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#2a54be70acbcce6d2efe6130a4e94e8a">unregisterDeletionListener</a> (<a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;observer)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a deletion listener.  <a href="#2a54be70acbcce6d2efe6130a4e94e8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#df5fc0714a1ad19e0a2b2723ee4b1714">registerDeletionListenerObjects</a> (<a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;observer, const <a class="el" href="classPxBase.html">PxBase</a> *const *observables, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> observableCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register specific objects for deletion events.  <a href="#df5fc0714a1ad19e0a2b2723ee4b1714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#ad319213709679f7ecddca5a97db29a4">unregisterDeletionListenerObjects</a> (<a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;observer, const <a class="el" href="classPxBase.html">PxBase</a> *const *observables, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> observableCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister specific objects for deletion events.  <a href="#ad319213709679f7ecddca5a97db29a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#7a4588fd79b87766cb81fae3ddd4f074">getPhysicsInsertionCallback</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object insertion interface.  <a href="#7a4588fd79b87766cb81fae3ddd4f074"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract singleton factory class used for instancing objects in the Physics SDK. 
<p>
In addition you can use <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> to set global parameters which will effect all scenes and create objects that can be shared across multiple scenes.<p>
You can get an instance of this class by calling <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> or <a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> with pre-registered modules.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> <a class="el" href="group__physics.html#gd63c429157f9c8c87fcd0ea2f9b79f66" title="Creates an instance of the physics SDK with minimal additional components registered...">PxCreateBasePhysics()</a> <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5d2cea62dd20865d8c13b8d07bd6fb60"></a><!-- doxytag: member="PxPhysics::~PxPhysics" ref="5d2cea62dd20865d8c13b8d07bd6fb60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxPhysics::~PxPhysics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="4209ffb5ab43cd7d9c6a59e4139c1993"></a><!-- doxytag: member="PxPhysics::createAggregate" ref="4209ffb5ab43cd7d9c6a59e4139c1993" args="(PxU32 maxSize, bool enableSelfCollision)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a>* PxPhysics::createAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enableSelfCollision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an aggregate with the specified maximum size and selfCollision property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxSize</em>&nbsp;</td><td>the maximum number of actors that may be placed in the aggregate. This value must not exceed 128, otherwise NULL will be returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enableSelfCollision</em>&nbsp;</td><td>whether the aggregate supports self-collision </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new aggregate.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a65bf245c40886f007b7cda86dee9f3f"></a><!-- doxytag: member="PxPhysics::createArticulation" ref="a65bf245c40886f007b7cda86dee9f3f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxArticulation.html">PxArticulation</a>* PxPhysics::createArticulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an articulation with all fields initialized to their default values. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new articulation</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a>, <a class="el" href="group__physics.html#g92144d0904f8a696f85737c576b88d9f" title="Enables the usage of the articulations feature. This function is called automatically...">PxRegisterArticulations</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1aa15d80d32aa15a3fdcd9c26fb3f3eb"></a><!-- doxytag: member="PxPhysics::createCloth" ref="1aa15d80d32aa15a3fdcd9c26fb3f3eb" args="(const PxTransform &amp;globalPose, PxClothFabric &amp;fabric, const PxClothParticle *particles, PxClothFlags flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxCloth.html">PxCloth</a>* PxPhysics::createCloth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>globalPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxClothFabric.html">PxClothFabric</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fabric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxClothParticle.html">PxClothParticle</a> *&nbsp;</td>
          <td class="paramname"> <em>particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxClothFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cloth. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>globalPose</em>&nbsp;</td><td>The world space transform of the cloth. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fabric</em>&nbsp;</td><td>The fabric the cloth should use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>particles</em>&nbsp;</td><td>Particle definition buffer. The size of the buffer has to match fabric.getNbParticles(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Cloth flags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new cloth.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> <a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> <a class="el" href="group__cloth.html#g2be4311f196add0112bf7148caa36151">PxClothFlags</a> <a class="el" href="group__physics.html#ge2faa96309a4fb0cbfcd512d2431fc82" title="Enables the usage of the cloth feature. This function is called automatically inside...">PxRegisterCloth</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8e37d6f27087b93515e8a39d4ad7179"></a><!-- doxytag: member="PxPhysics::createClothFabric" ref="b8e37d6f27087b93515e8a39d4ad7179" args="(const PxClothFabricDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxClothFabric.html">PxClothFabric</a>* PxPhysics::createClothFabric           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxClothFabricDesc.html">PxClothFabricDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cloth fabric object from particle connectivity and restlength information. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The particle connectivity can be created using <a class="el" href="classPxClothFabricCooker.html">PxClothFabricCooker</a> in extensions.</dd></dl>
This can then be instanced into <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Fabric descriptor, see <a class="el" href="classPxClothFabricDesc.html" title="References all the data required to create a fabric.">PxClothFabricDesc</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new cloth fabric.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> <a class="el" href="classPxClothFabric.html#7e8a7516cc7cb1777c790bc82cab2eac" title="Decrements the cloth fabric&#39;s reference count, and releases it if the new reference...">PxClothFabric.release()</a> <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="aff72c208eb0bb4faa418c1f258707d9"></a><!-- doxytag: member="PxPhysics::createClothFabric" ref="aff72c208eb0bb4faa418c1f258707d9" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxClothFabric.html">PxClothFabric</a>* PxPhysics::createClothFabric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cloth fabric object. 
<p>
This can then be instanced into <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The stream to load the cloth fabric from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new cloth fabric.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> <a class="el" href="classPxClothFabric.html#7e8a7516cc7cb1777c790bc82cab2eac" title="Decrements the cloth fabric&#39;s reference count, and releases it if the new reference...">PxClothFabric.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> <a class="el" href="group__physics.html#ge2faa96309a4fb0cbfcd512d2431fc82" title="Enables the usage of the cloth feature. This function is called automatically inside...">PxRegisterCloth</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1126f3f545ebe183be1753f62d1efc7d"></a><!-- doxytag: member="PxPhysics::createConstraint" ref="1126f3f545ebe183be1753f62d1efc7d" args="(PxRigidActor *actor0, PxRigidActor *actor1, PxConstraintConnector &amp;connector, const PxConstraintShaderTable &amp;shaders, PxU32 dataSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConstraint.html">PxConstraint</a>* PxPhysics::createConstraint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxConstraintConnector.html">PxConstraintConnector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxConstraintShaderTable.html">PxConstraintShaderTable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>dataSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a constraint shader. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A constraint shader will get added automatically to the scene the two linked actors belong to. Either, but not both, of actor0 and actor1 may be NULL to denote attachment to the world.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>the first actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>the second actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td>the connector object, which the SDK uses to communicate with the infrastructure for the constraint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shaders</em>&nbsp;</td><td>the shader functions for the constraint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataSize</em>&nbsp;</td><td>the size of the data block for the shader</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="54fc5f8b0884977ccfd45ea829392a52"></a><!-- doxytag: member="PxPhysics::createConvexMesh" ref="54fc5f8b0884977ccfd45ea829392a52" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a>* PxPhysics::createConvexMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a convex mesh object. 
<p>
This can then be instanced into <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The stream to load the convex mesh from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new convex mesh.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> <a class="el" href="classPxConvexMesh.html#6d2ce602a2383f40a3eb7d79e0c990d8" title="Decrements the reference count of a convex mesh and releases it if the new reference...">PxConvexMesh.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">createTriangleMesh()</a> <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a> <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1806546c22306e8d44b7ff7719fbcc99"></a><!-- doxytag: member="PxPhysics::createHeightField" ref="1806546c22306e8d44b7ff7719fbcc99" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a>* PxPhysics::createHeightField           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a heightfield object from previously cooked stream. 
<p>
This can then be instanced into <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The heightfield mesh stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new heightfield.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> <a class="el" href="classPxHeightField.html#6b35bf964920daa991d6b509cbc02744" title="Decrements the reference count of a height field and releases it if the new reference...">PxHeightField.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> <a class="el" href="group__physics.html#ge3a84455caaa6a7de67513ea29a315e1" title="Enables the usage of the heightfield feature.">PxRegisterHeightFields</a> <a class="el" href="group__physics.html#g6adbba7aad2d451e684110269dddd720" title="Enables the usage of the unified heightfield feature.">PxRegisterUnifiedHeightFields</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35c1965ae47b24e119c6a2d8ce25477e"></a><!-- doxytag: member="PxPhysics::createMaterial" ref="35c1965ae47b24e119c6a2d8ce25477e" args="(PxReal staticFriction, PxReal dynamicFriction, PxReal restitution)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a>* PxPhysics::createMaterial           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>staticFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>dynamicFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>restitution</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new material with default properties. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new material.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>staticFriction</em>&nbsp;</td><td>the coefficient of static friction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dynamicFriction</em>&nbsp;</td><td>the coefficient of dynamic friction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>restitution</em>&nbsp;</td><td>the coefficient of restitution</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea19c431d479c76fe44f64291c872744"></a><!-- doxytag: member="PxPhysics::createParticleFluid" ref="ea19c431d479c76fe44f64291c872744" args="(PxU32 maxParticles, bool perParticleRestOffset=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxParticleFluid.html">PxParticleFluid</a>* PxPhysics::createParticleFluid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>perParticleRestOffset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a particle fluid. (deprecated). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxParticles</em>&nbsp;</td><td>the maximum number of particles that may be placed in the particle fluid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perParticleRestOffset</em>&nbsp;</td><td>whether the ParticleFluid supports perParticleRestOffset </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new particle fluid.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>The PhysX particle feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxParticleFluid.html" title="The particle fluid class represents the main module for particle based fluid simulation...">PxParticleFluid</a> <a class="el" href="group__physics.html#g197726c3bfa1abc6fbe43875c2483b38" title="Enables the usage of the particles feature. This function is called automatically...">PxRegisterParticles</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc569d866211bc45d7ab01002a0dadca"></a><!-- doxytag: member="PxPhysics::createParticleSystem" ref="fc569d866211bc45d7ab01002a0dadca" args="(PxU32 maxParticles, bool perParticleRestOffset=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxParticleSystem.html">PxParticleSystem</a>* PxPhysics::createParticleSystem           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>perParticleRestOffset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a particle system. (deprecated). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxParticles</em>&nbsp;</td><td>the maximum number of particles that may be placed in the particle system </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perParticleRestOffset</em>&nbsp;</td><td>whether the ParticleSystem supports perParticleRestOffset </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new particle system.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>The PhysX particle feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxParticleSystem.html" title="The particle system class represents the main module for particle based simulation...">PxParticleSystem</a> <a class="el" href="group__physics.html#g197726c3bfa1abc6fbe43875c2483b38" title="Enables the usage of the particles feature. This function is called automatically...">PxRegisterParticles</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c62ebf74c105e7ecf3eaba6949a42fa"></a><!-- doxytag: member="PxPhysics::createPruningStructure" ref="5c62ebf74c105e7ecf3eaba6949a42fa" args="(PxRigidActor *const *actors, PxU32 nbActors)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxPruningStructure.html">PxPruningStructure</a>* PxPhysics::createPruningStructure           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *const *&nbsp;</td>
          <td class="paramname"> <em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbActors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a pruning structure from actors. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Every provided actor needs at least one shape with the eSCENE_QUERY_SHAPE flag set. <p>
Both static and dynamic actors can be provided. <p>
It is not allowed to pass in actors which are already part of a scene. <p>
Articulation links cannot be provided.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actors</em>&nbsp;</td><td>Array of actors to add to the pruning structure. Must be non NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbActors</em>&nbsp;</td><td>Number of actors in the array. Must be &gt;0. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pruning structure created from given actors, or NULL if any of the actors did not comply with the above requirements. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> <a class="el" href="classPxPruningStructure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors...">PxPruningStructure</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="58d338d214918182945c8fcb99325e20"></a><!-- doxytag: member="PxPhysics::createRigidDynamic" ref="58d338d214918182945c8fcb99325e20" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxPhysics::createRigidDynamic           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a dynamic rigid actor with the specified pose and all other fields initialized to their default values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>the initial pose of the actor. Must be a valid transform</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="82949b1375677a8c58d64c7cd47b7f4b"></a><!-- doxytag: member="PxPhysics::createRigidStatic" ref="82949b1375677a8c58d64c7cd47b7f4b" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxRigidStatic.html">PxRigidStatic</a>* PxPhysics::createRigidStatic           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a static rigid actor with the specified pose and all other fields initialized to their default values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>the initial pose of the actor. Must be a valid transform</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6dcded7be00c17004432a04a78569db1"></a><!-- doxytag: member="PxPhysics::createScene" ref="6dcded7be00c17004432a04a78569db1" args="(const PxSceneDesc &amp;sceneDesc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxScene.html">PxScene</a>* PxPhysics::createScene           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxSceneDesc.html">PxSceneDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sceneDesc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Every scene uses a Thread Local Storage slot. This imposes a platform specific limit on the number of scenes that can be created.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sceneDesc</em>&nbsp;</td><td>Scene descriptor. See <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new scene object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> <a class="el" href="classPxScene.html#61f68a8c516aea477cc5328b00c976ed" title="Deletes the scene.">PxScene.release()</a> <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fde7d3527975abe62c8b4951d9e69978"></a><!-- doxytag: member="PxPhysics::createShape" ref="fde7d3527975abe62c8b4951d9e69978" args="(const PxGeometry &amp;geometry, PxMaterial *const *materials, PxU16 materialCount, bool isExclusive=false, PxShapeFlags shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxShape.html">PxShape</a>* PxPhysics::createShape           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> *const *&nbsp;</td>
          <td class="paramname"> <em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&nbsp;</td>
          <td class="paramname"> <em>materialCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isExclusive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>shapeFlags</em> = <code>PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a shape which may be attached to multiple actors. 
<p>
The shape will be created with a reference count of 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry for the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materials</em>&nbsp;</td><td>the materials for the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materialCount</em>&nbsp;</td><td>the number of materials </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isExclusive</em>&nbsp;</td><td>whether this shape is exclusive to a single actor or may be shared </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeFlags</em>&nbsp;</td><td>the PxShapeFlags to be set</td></tr>
  </table>
</dl>
Shared shapes are not mutable when they are attached to an actor<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc564607f208cbc1944880172a3d62fe"></a><!-- doxytag: member="PxPhysics::createShape" ref="bc564607f208cbc1944880172a3d62fe" args="(const PxGeometry &amp;geometry, const PxMaterial &amp;material, bool isExclusive=false, PxShapeFlags shapeFlags=PxShapeFlag::eVISUALIZATION|PxShapeFlag::eSCENE_QUERY_SHAPE|PxShapeFlag::eSIMULATION_SHAPE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_FORCE_INLINE <a class="el" href="classPxShape.html">PxShape</a>* PxPhysics::createShape           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isExclusive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>shapeFlags</em> = <code>PxShapeFlag::eVISUALIZATION&nbsp;|&nbsp;PxShapeFlag::eSCENE_QUERY_SHAPE&nbsp;|&nbsp;PxShapeFlag::eSIMULATION_SHAPE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a shape which may be attached to multiple actors. 
<p>
The shape will be created with a reference count of 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry for the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isExclusive</em>&nbsp;</td><td>whether this shape is exclusive to a single actor or maybe be shared </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeFlags</em>&nbsp;</td><td>the PxShapeFlags to be set</td></tr>
  </table>
</dl>
Shared shapes are not mutable when they are attached to an actor<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="29dcbbe128cef11eaf4ce5696c216dfd"></a><!-- doxytag: member="PxPhysics::createTriangleMesh" ref="29dcbbe128cef11eaf4ce5696c216dfd" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a>* PxPhysics::createTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a triangle mesh object. 
<p>
This can then be instanced into <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The triangle mesh stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new triangle mesh.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> <a class="el" href="structPxMeshPreprocessingFlag.html" title="Enum for the set of mesh pre-processing parameters.">PxMeshPreprocessingFlag</a> <a class="el" href="classPxTriangleMesh.html#168cc0000372c63857d128d04f1d32fa" title="Decrements the reference count of a triangle mesh and releases it if the new reference...">PxTriangleMesh.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> <a class="el" href="structPxTriangleMeshFlag.html" title="Flags for the mesh geometry properties.">PxTriangleMeshFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b66ea589cfffdd5948771b885f2121ad"></a><!-- doxytag: member="PxPhysics::getClothFabrics" ref="b66ea589cfffdd5948771b885f2121ad" args="(PxClothFabric **userBuffer, PxU32 bufferSize) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getClothFabrics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxClothFabric.html">PxClothFabric</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of cloth fabrics to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the cloth fabrics in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive cloth fabric pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of cloth fabric pointers which can be stored in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of cloth fabric pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#5c0990eef79ed840ea0cc88d0f952111" title="Return the number of cloth fabrics that currently exist.">getNbClothFabrics()</a> <a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f842c37b9e11bf180465452e8dacfc06"></a><!-- doxytag: member="PxPhysics::getConvexMeshes" ref="f842c37b9e11bf180465452e8dacfc06" args="(PxConvexMesh **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getConvexMeshes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of convex mesh pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the convex meshes in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive convex mesh pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of convex mesh pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first convex mesh pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of convex mesh pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#372b961576ee45702d02618933e8db0d" title="Return the number of convex meshes that currently exist.">getNbConvexMeshes()</a> <a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c2899065d7b3d9367a409b0207848cc"></a><!-- doxytag: member="PxPhysics::getFoundation" ref="1c2899065d7b3d9367a409b0207848cc" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFoundation.html">PxFoundation</a>&amp; PxPhysics::getFoundation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the Foundation instance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the Foundation object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2470ec4f7a3b36664f92d08c3b42ba7"></a><!-- doxytag: member="PxPhysics::getHeightFields" ref="d2470ec4f7a3b36664f92d08c3b42ba7" args="(PxHeightField **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getHeightFields           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxHeightField.html">PxHeightField</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of heightfield pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the heightfields in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive heightfield pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of heightfield pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first heightfield pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of heightfield pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#92275b36165ce356aa217d17fbb3ac2c" title="Return the number of heightfields that currently exist.">getNbHeightFields()</a> <a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a9cabf0c8c0f11d7eb7e948be2e32b0"></a><!-- doxytag: member="PxPhysics::getMaterials" ref="1a9cabf0c8c0f11d7eb7e948be2e32b0" args="(PxMaterial **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of material pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the materials in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive material pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of material pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first material pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of material pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#051662877c0f3346ac7fa4f1bf4bcd95" title="Return the number of materials that currently exist.">getNbMaterials()</a> <a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c0990eef79ed840ea0cc88d0f952111"></a><!-- doxytag: member="PxPhysics::getNbClothFabrics" ref="5c0990eef79ed840ea0cc88d0f952111" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbClothFabrics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of cloth fabrics that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of cloth fabrics.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#b66ea589cfffdd5948771b885f2121ad" title="Writes the array of cloth fabrics to a user buffer.">getClothFabrics()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="372b961576ee45702d02618933e8db0d"></a><!-- doxytag: member="PxPhysics::getNbConvexMeshes" ref="372b961576ee45702d02618933e8db0d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbConvexMeshes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of convex meshes that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of convex meshes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#f842c37b9e11bf180465452e8dacfc06" title="Writes the array of convex mesh pointers to a user buffer.">getConvexMeshes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="92275b36165ce356aa217d17fbb3ac2c"></a><!-- doxytag: member="PxPhysics::getNbHeightFields" ref="92275b36165ce356aa217d17fbb3ac2c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbHeightFields           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of heightfields that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of heightfields.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#d2470ec4f7a3b36664f92d08c3b42ba7" title="Writes the array of heightfield pointers to a user buffer.">getHeightFields()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="051662877c0f3346ac7fa4f1bf4bcd95"></a><!-- doxytag: member="PxPhysics::getNbMaterials" ref="051662877c0f3346ac7fa4f1bf4bcd95" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbMaterials           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of materials that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of materials.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#1a9cabf0c8c0f11d7eb7e948be2e32b0" title="Writes the array of material pointers to a user buffer.">getMaterials()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6181c2f379b52712bece3f7639fab1e"></a><!-- doxytag: member="PxPhysics::getNbScenes" ref="f6181c2f379b52712bece3f7639fab1e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbScenes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets number of created scenes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of scenes created.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getScene() </dd></dl>

</div>
</div><p>
<a class="anchor" name="084ff8d2b32c74056f95580cbb2a0cb3"></a><!-- doxytag: member="PxPhysics::getNbShapes" ref="084ff8d2b32c74056f95580cbb2a0cb3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbShapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of shapes that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of shapes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#f8a7ab6d85ff7232e622a7127f5e2528" title="Writes the array of shape pointers to a user buffer.">getShapes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="91183bc0ffba9000a0f76bf4d9bf5fa2"></a><!-- doxytag: member="PxPhysics::getNbTriangleMeshes" ref="91183bc0ffba9000a0f76bf4d9bf5fa2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getNbTriangleMeshes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of triangle meshes that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of triangle meshes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#a781fee3bcd9ea28cfaa45717c4a8738" title="Writes the array of triangle mesh pointers to a user buffer.">getTriangleMeshes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a4588fd79b87766cb81fae3ddd4f074"></a><!-- doxytag: member="PxPhysics::getPhysicsInsertionCallback" ref="7a4588fd79b87766cb81fae3ddd4f074" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxPhysicsInsertionCallback.html">PxPhysicsInsertionCallback</a>&amp; PxPhysics::getPhysicsInsertionCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object insertion interface. 
<p>
The insertion interface is needed ie. for <a class="el" href="classPxCooking.html#227e676ba5b15b9cf292fd457427b13b" title="Cooks and creates a triangle mesh and inserts it into PxPhysics.">PxCooking::createTriangleMesh</a>, this allows runtime mesh creation. This is not advised to do, please use offline cooking if possible.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCooking.html#227e676ba5b15b9cf292fd457427b13b" title="Cooks and creates a triangle mesh and inserts it into PxPhysics.">PxCooking::createTriangleMesh</a> PxCooking::createHeightfield </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ecd80a6f7c5239bd6cc50c5ea76156d"></a><!-- doxytag: member="PxPhysics::getScenes" ref="1ecd80a6f7c5239bd6cc50c5ea76156d" args="(PxScene **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getScenes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxScene.html">PxScene</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of scene pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the scene pointers in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive scene pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of scene pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first scene pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of scene pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#f6181c2f379b52712bece3f7639fab1e" title="Gets number of created scenes.">getNbScenes()</a> <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8a7ab6d85ff7232e622a7127f5e2528"></a><!-- doxytag: member="PxPhysics::getShapes" ref="f8a7ab6d85ff7232e622a7127f5e2528" args="(PxShape **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getShapes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of shape pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the shapes in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive shape pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of shape pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first shape pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of shape pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#084ff8d2b32c74056f95580cbb2a0cb3" title="Return the number of shapes that currently exist.">getNbShapes()</a> <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6b06e75ab03222d301a15e14c5ac467"></a><!-- doxytag: member="PxPhysics::getTolerancesScale" ref="e6b06e75ab03222d301a15e14c5ac467" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a>&amp; PxPhysics::getTolerancesScale           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the simulation tolerance parameters. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current simulation tolerance parameters. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a781fee3bcd9ea28cfaa45717c4a8738"></a><!-- doxytag: member="PxPhysics::getTriangleMeshes" ref="a781fee3bcd9ea28cfaa45717c4a8738" args="(PxTriangleMesh **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxPhysics::getTriangleMeshes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of triangle mesh pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the triangle meshes in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive triangle mesh pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of triangle mesh pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first mesh pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of triangle mesh pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#91183bc0ffba9000a0f76bf4d9bf5fa2" title="Return the number of triangle meshes that currently exist.">getNbTriangleMeshes()</a> <a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3eabed665fe069eed00fca73da25ae2b"></a><!-- doxytag: member="PxPhysics::registerDeletionListener" ref="3eabed665fe069eed00fca73da25ae2b" args="(PxDeletionListener &amp;observer, const PxDeletionEventFlags &amp;deletionEvents, bool restrictedObjectSet=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::registerDeletionListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxFlags.html">PxDeletionEventFlags</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>deletionEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>restrictedObjectSet</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a deletion listener. Listeners will be called whenever an object is deleted. 
<p>
It is illegal to register or unregister a deletion listener while deletions are being processed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>By default a registered listener will receive events from all objects. Set the restrictedObjectSet parameter to true on registration and use <a class="el" href="classPxPhysics.html#df5fc0714a1ad19e0a2b2723ee4b1714" title="Register specific objects for deletion events.">registerDeletionListenerObjects</a> to restrict the received events to specific objects.<p>
The deletion events are only supported on core PhysX objects. In general, objects in extension modules do not provide this functionality, however, in the case of <a class="el" href="classPxJoint.html" title="a base interface providing common functionality for PhysX joints">PxJoint</a> objects, the underlying <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> will send the events.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observer</em>&nbsp;</td><td>Observer object to send notifications to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>deletionEvents</em>&nbsp;</td><td>The deletion event types to get notified of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restrictedObjectSet</em>&nbsp;</td><td>If false, the deletion listener will get events from all objects, else the objects to receive events from have to be specified explicitly through <a class="el" href="classPxPhysics.html#df5fc0714a1ad19e0a2b2723ee4b1714" title="Register specific objects for deletion events.">registerDeletionListenerObjects</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxDeletionListener.html" title="interface to get notification on object deletion">PxDeletionListener</a> <a class="el" href="classPxPhysics.html#2a54be70acbcce6d2efe6130a4e94e8a" title="Unregister a deletion listener.">unregisterDeletionListener</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="df5fc0714a1ad19e0a2b2723ee4b1714"></a><!-- doxytag: member="PxPhysics::registerDeletionListenerObjects" ref="df5fc0714a1ad19e0a2b2723ee4b1714" args="(PxDeletionListener &amp;observer, const PxBase *const *observables, PxU32 observableCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::registerDeletionListenerObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxBase.html">PxBase</a> *const *&nbsp;</td>
          <td class="paramname"> <em>observables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>observableCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register specific objects for deletion events. 
<p>
This method allows for a deletion listener to limit deletion events to specific objects only.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is illegal to register or unregister objects while deletions are being processed.<p>
The deletion listener has to be registered through <a class="el" href="classPxPhysics.html#3eabed665fe069eed00fca73da25ae2b" title="Register a deletion listener. Listeners will be called whenever an object is deleted...">registerDeletionListener()</a> and configured to support restricted objects sets prior to this method being used.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observer</em>&nbsp;</td><td>Observer object to send notifications to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observables</em>&nbsp;</td><td>List of objects for which to receive deletion events. Only PhysX core objects are supported. In the case of <a class="el" href="classPxJoint.html" title="a base interface providing common functionality for PhysX joints">PxJoint</a> objects, the underlying <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> can be used to get the events. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observableCount</em>&nbsp;</td><td>Size of the observables list.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxDeletionListener.html" title="interface to get notification on object deletion">PxDeletionListener</a> <a class="el" href="classPxPhysics.html#ad319213709679f7ecddca5a97db29a4" title="Unregister specific objects for deletion events.">unregisterDeletionListenerObjects</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="795e11d0e5ed6ac50af9c656f6a67e37"></a><!-- doxytag: member="PxPhysics::release" ref="795e11d0e5ed6ac50af9c656f6a67e37" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the instance it is called on. 
<p>
Use this release method to destroy an instance of this class. Be sure to not keep a reference to this object after calling release. Avoid release calls while a scene is simulating (in between simulate() and fetchResults() calls).<p>
Note that this must be called once for each prior call to PxCreatePhysics, as there is a reference counter. Also note that you mustn't destroy the allocator or the error callback (if available) until after the reference count reaches 0 and the SDK is actually removed.<p>
Releasing an SDK will also release any scenes, triangle meshes, convex meshes, heightfields and shapes created through it, provided the user hasn't already done so.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function is required to be called to release foundation usage.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g8039bfec65da68b2294a97175ddb2c66" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a54be70acbcce6d2efe6130a4e94e8a"></a><!-- doxytag: member="PxPhysics::unregisterDeletionListener" ref="2a54be70acbcce6d2efe6130a4e94e8a" args="(PxDeletionListener &amp;observer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::unregisterDeletionListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>observer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a deletion listener. 
<p>
It is illegal to register or unregister a deletion listener while deletions are being processed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observer</em>&nbsp;</td><td>Observer object to send notifications to</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxDeletionListener.html" title="interface to get notification on object deletion">PxDeletionListener</a> <a class="el" href="classPxPhysics.html#3eabed665fe069eed00fca73da25ae2b" title="Register a deletion listener. Listeners will be called whenever an object is deleted...">registerDeletionListener</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad319213709679f7ecddca5a97db29a4"></a><!-- doxytag: member="PxPhysics::unregisterDeletionListenerObjects" ref="ad319213709679f7ecddca5a97db29a4" args="(PxDeletionListener &amp;observer, const PxBase *const *observables, PxU32 observableCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::unregisterDeletionListenerObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxDeletionListener.html">PxDeletionListener</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxBase.html">PxBase</a> *const *&nbsp;</td>
          <td class="paramname"> <em>observables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>observableCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister specific objects for deletion events. 
<p>
This method allows to clear previously registered objects for a deletion listener (see <a class="el" href="classPxPhysics.html#df5fc0714a1ad19e0a2b2723ee4b1714" title="Register specific objects for deletion events.">registerDeletionListenerObjects()</a>).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is illegal to register or unregister objects while deletions are being processed.<p>
The deletion listener has to be registered through <a class="el" href="classPxPhysics.html#3eabed665fe069eed00fca73da25ae2b" title="Register a deletion listener. Listeners will be called whenever an object is deleted...">registerDeletionListener()</a> and configured to support restricted objects sets prior to this method being used.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observer</em>&nbsp;</td><td>Observer object to stop sending notifications to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observables</em>&nbsp;</td><td>List of objects for which to not receive deletion events anymore. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observableCount</em>&nbsp;</td><td>Size of the observables list.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxDeletionListener.html" title="interface to get notification on object deletion">PxDeletionListener</a> <a class="el" href="classPxPhysics.html#df5fc0714a1ad19e0a2b2723ee4b1714" title="Register specific objects for deletion events.">registerDeletionListenerObjects</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxPhysics_8h-source.html">PxPhysics.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
