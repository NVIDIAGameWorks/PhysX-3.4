<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxClothGeodesicTetherCooker Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxClothGeodesicTetherCooker Class Reference</h1><!-- doxytag: class="PxClothGeodesicTetherCooker" --><code>#include &lt;<a class="el" href="PxClothTetherCooker_8h-source.html">PxClothTetherCooker.h</a>&gt;</code>
<p>

<p>
<a href="classPxClothGeodesicTetherCooker-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothGeodesicTetherCooker.html#c6ca1841c73fd3b6fe485ac6159cfa1e">PxClothGeodesicTetherCooker</a> (const <a class="el" href="classPxClothMeshDesc.html">PxClothMeshDesc</a> &amp;desc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute tether data from <a class="el" href="classPxClothMeshDesc.html" title="Descriptor class for a cloth mesh.">PxClothMeshDesc</a> using geodesic distance.  <a href="#c6ca1841c73fd3b6fe485ac6159cfa1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothGeodesicTetherCooker.html#1472f7e205c26faa17cf3fae5b4e5596">~PxClothGeodesicTetherCooker</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothGeodesicTetherCooker.html#1f14f389b1608132be8a1e629df57bba">getCookerStatus</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns cooker status.  <a href="#1f14f389b1608132be8a1e629df57bba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothGeodesicTetherCooker.html#d30d42ab8ee044a646683cdd5c1ada87">getNbTethersPerParticle</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of tether anchors per particle.  <a href="#d30d42ab8ee044a646683cdd5c1ada87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothGeodesicTetherCooker.html#d70234a172fc25819b8b5a66c9970058">getTetherData</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *userTetherAnchors, PxReal *userTetherLengths) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns computed tether data.  <a href="#d70234a172fc25819b8b5a66c9970058"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxClothGeodesicTetherCookerImpl *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxClothGeodesicTetherCooker.html#1b2e78b91a4e9ccab30cd8da05527811">mImpl</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c6ca1841c73fd3b6fe485ac6159cfa1e"></a><!-- doxytag: member="PxClothGeodesicTetherCooker::PxClothGeodesicTetherCooker" ref="c6ca1841c73fd3b6fe485ac6159cfa1e" args="(const PxClothMeshDesc &amp;desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxClothGeodesicTetherCooker::PxClothGeodesicTetherCooker           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxClothMeshDesc.html">PxClothMeshDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute tether data from <a class="el" href="classPxClothMeshDesc.html" title="Descriptor class for a cloth mesh.">PxClothMeshDesc</a> using geodesic distance. 
<p>
The tether constraint in <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> requires rest distance and anchor index to be precomputed during cooking time. The provided tether cooker computes optimal tether distance with geodesic distance computation. For curved and complex meshes, geodesic distance provides the best behavior for tether constraints. But the cooking time is slower than the simple cooker. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxClothSimpleTetherCooker.html">PxClothSimpleTetherCooker</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>desc</em>&nbsp;</td><td>The cloth mesh descriptor prepared for cooking </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The geodesic distance is optimized to work for intended use in tether constraint. This is by no means a general purpose geodesic computation code for arbitrary meshes. <p>
The geodesic cooker does not work with non-manifold input such as edges having more than two incident triangles, or adjacent triangles following inconsitent winding order (e.g. clockwise vs counter-clockwise). </dd></dl>

</div>
</div><p>
<a class="anchor" name="1472f7e205c26faa17cf3fae5b4e5596"></a><!-- doxytag: member="PxClothGeodesicTetherCooker::~PxClothGeodesicTetherCooker" ref="1472f7e205c26faa17cf3fae5b4e5596" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxClothGeodesicTetherCooker::~PxClothGeodesicTetherCooker           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1f14f389b1608132be8a1e629df57bba"></a><!-- doxytag: member="PxClothGeodesicTetherCooker::getCookerStatus" ref="1f14f389b1608132be8a1e629df57bba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxClothGeodesicTetherCooker::getCookerStatus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns cooker status. 
<p>
This function returns cooker status after cooker computation is done. A non-zero return value indicates a failure, 1 for non-manifold and 2 for inconsistent winding. 
</div>
</div><p>
<a class="anchor" name="d30d42ab8ee044a646683cdd5c1ada87"></a><!-- doxytag: member="PxClothGeodesicTetherCooker::getNbTethersPerParticle" ref="d30d42ab8ee044a646683cdd5c1ada87" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxClothGeodesicTetherCooker::getNbTethersPerParticle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of tether anchors per particle. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Returned number indicates the maximum anchors. If some particles are assigned fewer anchors, the anchor indices will be PxU32(-1) <p>
If there is no attached point in the input mesh descriptor, this will return 0 and no tether data will be generated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d70234a172fc25819b8b5a66c9970058"></a><!-- doxytag: member="PxClothGeodesicTetherCooker::getTetherData" ref="d70234a172fc25819b8b5a66c9970058" args="(PxU32 *userTetherAnchors, PxReal *userTetherLengths) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PxClothGeodesicTetherCooker::getTetherData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>userTetherAnchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal *&nbsp;</td>
          <td class="paramname"> <em>userTetherLengths</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns computed tether data. 
<p>
This function returns anchor indices for each particle as well as desired distance between the tether anchor and the particle. The user buffers should be at least as large as number of particles * number of tethers per particle. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxClothGeodesicTetherCooker.html#d30d42ab8ee044a646683cdd5c1ada87" title="Returns number of tether anchors per particle.">getNbTethersPerParticle()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="1b2e78b91a4e9ccab30cd8da05527811"></a><!-- doxytag: member="PxClothGeodesicTetherCooker::mImpl" ref="1b2e78b91a4e9ccab30cd8da05527811" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxClothGeodesicTetherCookerImpl* <a class="el" href="classPxClothGeodesicTetherCooker.html#1b2e78b91a4e9ccab30cd8da05527811">PxClothGeodesicTetherCooker::mImpl</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxClothTetherCooker_8h-source.html">PxClothTetherCooker.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
