<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxRigidDynamic Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxRigidDynamic Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxRigidDynamic" --><!-- doxytag: inherits="PxRigidBody" --><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxRigidDynamic_8h-source.html">PxRigidDynamic.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxRigidDynamic:</div>
<div class="dynsection">
<p><center><img src="classPxRigidDynamic__inherit__graph.png" border="0" usemap="#PxRigidDynamic__inherit__map" alt="Inheritance graph"></center>
<map name="PxRigidDynamic__inherit__map">
<area shape="rect" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects." alt="PxRigidBody" coords="16,224,101,245"><area shape="rect" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies..." alt="PxRigidActor" coords="17,155,100,176"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="PxActor" coords="32,85,85,107"><area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="31,16,87,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidDynamic:</div>
<div class="dynsection">
<p><center><img src="classPxRigidDynamic__coll__graph.png" border="0" usemap="#PxRigidDynamic__coll__map" alt="Collaboration graph"></center>
<map name="PxRigidDynamic__coll__map">
<area shape="rect" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects." alt="PxRigidBody" coords="83,322,168,344"><area shape="rect" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies..." alt="PxRigidActor" coords="84,250,167,272"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="PxActor" coords="99,178,152,200"><area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="97,106,153,128"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" alt="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" coords="7,16,244,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxRigidDynamic-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kinematic Actors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#4464d188e7a1e94582c9cf35da9bbc93">setKinematicTarget</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;destination)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves kinematically controlled dynamic actors through the game world.  <a href="#4464d188e7a1e94582c9cf35da9bbc93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#3b6ed86370cfd04958ca7e1c637e310b">getKinematicTarget</a> (<a class="el" href="classPxTransform.html">PxTransform</a> &amp;target) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get target pose of a kinematically controlled dynamic actor.  <a href="#3b6ed86370cfd04958ca7e1c637e310b"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Damping</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#003953e985ace5966375acb0674f7b0b">setLinearDamping</a> (PxReal linDamp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear damping coefficient.  <a href="#003953e985ace5966375acb0674f7b0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#e59cea37df7d70286dc587a4967f5512">getLinearDamping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linear damping coefficient.  <a href="#e59cea37df7d70286dc587a4967f5512"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#5435556860f16008b2c88ae6c36025dd">setAngularDamping</a> (PxReal angDamp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular damping coefficient.  <a href="#5435556860f16008b2c88ae6c36025dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#7a617db7f7c8e887d8e128956e04ba4a">getAngularDamping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the angular damping coefficient.  <a href="#7a617db7f7c8e887d8e128956e04ba4a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#d90b8ba1636cfef0e3e2386bc21dc3f1">setMaxAngularVelocity</a> (PxReal maxAngVel)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lets you set the maximum angular velocity permitted for this actor.  <a href="#d90b8ba1636cfef0e3e2386bc21dc3f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#d977d8dc4858f3d5077e8b78f99fa62a">getMaxAngularVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <a href="#d977d8dc4858f3d5077e8b78f99fa62a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Sleeping</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae">isSleeping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this body is sleeping.  <a href="#af537a84cd9b119ed5f77888c600f2ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#c087213f7360a202eaccfab26e97e644">setSleepThreshold</a> (PxReal threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.  <a href="#c087213f7360a202eaccfab26e97e644"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#1a0232d5a392e204e6b133fd2ab0879e">getSleepThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the mass-normalized kinetic energy below which an actor may go to sleep.  <a href="#1a0232d5a392e204e6b133fd2ab0879e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#59fb22d9402497cffe1b5e54d9ecd62f">setStabilizationThreshold</a> (PxReal threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.  <a href="#59fb22d9402497cffe1b5e54d9ecd62f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#5f9d98c9bd3b9ab0be7ce1b3ec4a4574">getStabilizationThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the mass-normalized kinetic energy below which an actor may participate in stabilization.  <a href="#5f9d98c9bd3b9ab0be7ce1b3ec4a4574"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFlags.html">PxRigidDynamicLockFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#a88e055440d6c1cc846e32dbed017345">getRigidDynamicLockFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> lock flags.  <a href="#a88e055440d6c1cc846e32dbed017345"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#7cf3e84117da3ec5b499262a3a9f5521">setRigidDynamicLockFlag</a> (<a class="el" href="structPxRigidDynamicLockFlag.html#e2e527a7cf32504d4b5c8c6d147280e1">PxRigidDynamicLockFlag::Enum</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raises or clears a particular rigid dynamic lock flag.  <a href="#7cf3e84117da3ec5b499262a3a9f5521"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#16f9f0dfeae6e7877bcebca80df42c92">setRigidDynamicLockFlags</a> (<a class="el" href="classPxFlags.html">PxRigidDynamicLockFlags</a> flags)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#0f7de8c56c76461555219b2b98d5147a">setWakeCounter</a> (PxReal wakeCounterValue)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the wake counter for the actor.  <a href="#0f7de8c56c76461555219b2b98d5147a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#88dc31fa470c5f37e3e9683534ad83aa">getWakeCounter</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wake counter of the actor.  <a href="#88dc31fa470c5f37e3e9683534ad83aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#4f1b9e9f437d8b8f27a6e9c2d9ea22fd">wakeUp</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wakes up the actor if it is sleeping.  <a href="#4f1b9e9f437d8b8f27a6e9c2d9ea22fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#ae00aa2067a2fe268b999aad04f27c28">putToSleep</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the actor to sleep.  <a href="#ae00aa2067a2fe268b999aad04f27c28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#fa68d947962bc2d0f8862caaf3e8b304">setSolverIterationCounts</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> minPositionIters, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> minVelocityIters=1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <a href="#fa68d947962bc2d0f8862caaf3e8b304"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#2fcdafcbc0dd5a691d502b2f7b03a7d7">getSolverIterationCounts</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;minPositionIters, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;minVelocityIters) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the solver iteration counts.  <a href="#2fcdafcbc0dd5a691d502b2f7b03a7d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#cc91baffa652090e523df5e6627686ed">getContactReportThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the force threshold for contact reports.  <a href="#cc91baffa652090e523df5e6627686ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#bfd510964f2287e81fe76a1a9e1725b5">setContactReportThreshold</a> (PxReal threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the force threshold for contact reports.  <a href="#bfd510964f2287e81fe76a1a9e1725b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#8402fd801e4ce9f6ee2a1fb3e80721dc">getConcreteTypeName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns string name of dynamic type.  <a href="#8402fd801e4ce9f6ee2a1fb3e80721dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#b21ed0e4e1be20fc975fcd3ceeb4e064">PxRigidDynamic</a> (<a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#9e63c1ec6872048e16f7d6b744ec3eef">PxRigidDynamic</a> (<a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#9380b2f317161026b39c6a296ba9e273">~PxRigidDynamic</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidDynamic.html#0ed60c0a05771d8679069a46b778f8f8">isKindOf</a> (const char *name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#0ed60c0a05771d8679069a46b778f8f8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK. 
<p>
<h3>Creation</h3>
<p>
Instances of this class are created by calling <a class="el" href="classPxPhysics.html#58d338d214918182945c8fcb99325e20" title="Creates a dynamic rigid actor with the specified pose and all other fields initialized...">PxPhysics::createRigidDynamic()</a> and deleted with <a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object.">release()</a>.<p>
<h3>Visualizations</h3>
<p>
<ul>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb1071d96779e81c1ac240f4cdd8188c55ec" title="Visualize actor axes.">PxVisualizationParameter::eACTOR_AXES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb103e5a40d8a90d56caa62e6c483e00c9cb" title="Visualize a bodies axes.">PxVisualizationParameter::eBODY_AXES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb108e73c99660d921ad7dc81069ff0b2a3c" title="Visualize a body&#39;s mass axes.">PxVisualizationParameter::eBODY_MASS_AXES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb109e57301b7b1ed3722334f04b9bb6f4bc" title="Visualize the bodies linear velocity.">PxVisualizationParameter::eBODY_LIN_VELOCITY</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb100d326f5ea2be6379999dd3b0e80a0552" title="Visualize the bodies angular velocity.">PxVisualizationParameter::eBODY_ANG_VELOCITY</a></li>
</ul>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> <a class="el" href="classPxPhysics.html#58d338d214918182945c8fcb99325e20" title="Creates a dynamic rigid actor with the specified pose and all other fields initialized...">PxPhysics.createRigidDynamic()</a> <a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object.">release()</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b21ed0e4e1be20fc975fcd3ceeb4e064"></a><!-- doxytag: member="PxRigidDynamic::PxRigidDynamic" ref="b21ed0e4e1be20fc975fcd3ceeb4e064" args="(PxType concreteType, PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidDynamic::PxRigidDynamic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a>&nbsp;</td>
          <td class="paramname"> <em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9e63c1ec6872048e16f7d6b744ec3eef"></a><!-- doxytag: member="PxRigidDynamic::PxRigidDynamic" ref="9e63c1ec6872048e16f7d6b744ec3eef" args="(PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidDynamic::PxRigidDynamic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9380b2f317161026b39c6a296ba9e273"></a><!-- doxytag: member="PxRigidDynamic::~PxRigidDynamic" ref="9380b2f317161026b39c6a296ba9e273" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidDynamic::~PxRigidDynamic           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7a617db7f7c8e887d8e128956e04ba4a"></a><!-- doxytag: member="PxRigidDynamic::getAngularDamping" ref="7a617db7f7c8e887d8e128956e04ba4a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getAngularDamping           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the angular damping coefficient. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The angular damping coefficient associated with this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#5435556860f16008b2c88ae6c36025dd" title="Sets the angular damping coefficient.">setAngularDamping()</a> <a class="el" href="classPxRigidDynamic.html#e59cea37df7d70286dc587a4967f5512" title="Retrieves the linear damping coefficient.">getLinearDamping()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8402fd801e4ce9f6ee2a1fb3e80721dc"></a><!-- doxytag: member="PxRigidDynamic::getConcreteTypeName" ref="8402fd801e4ce9f6ee2a1fb3e80721dc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxRigidDynamic::getConcreteTypeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns string name of dynamic type. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Class name of most derived type of this object. </dd></dl>

<p>Implements <a class="el" href="classPxBase.html#67fe206d8897ddce896c371ac8d789a9">PxBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="cc91baffa652090e523df5e6627686ed"></a><!-- doxytag: member="PxRigidDynamic::getContactReportThreshold" ref="cc91baffa652090e523df5e6627686ed" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getContactReportThreshold           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the force threshold for contact reports. 
<p>
The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the contact report threshold flags provided by the filter shader/callback. See <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a>.<p>
The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.<p>
<b>Default:</b> PX_MAX_F32<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Force threshold for contact reports.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#bfd510964f2287e81fe76a1a9e1725b5" title="Sets the force threshold for contact reports.">setContactReportThreshold</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b6ed86370cfd04958ca7e1c637e310b"></a><!-- doxytag: member="PxRigidDynamic::getKinematicTarget" ref="3b6ed86370cfd04958ca7e1c637e310b" args="(PxTransform &amp;target) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidDynamic::getKinematicTarget           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get target pose of a kinematically controlled dynamic actor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Transform to write the target pose to. Only valid if the method returns true. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the actor is a kinematically controlled dynamic and the target has been set, else False.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#4464d188e7a1e94582c9cf35da9bbc93" title="Moves kinematically controlled dynamic actors through the game world.">setKinematicTarget()</a> <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e59cea37df7d70286dc587a4967f5512"></a><!-- doxytag: member="PxRigidDynamic::getLinearDamping" ref="e59cea37df7d70286dc587a4967f5512" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getLinearDamping           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the linear damping coefficient. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The linear damping coefficient associated with this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#003953e985ace5966375acb0674f7b0b" title="Sets the linear damping coefficient.">setLinearDamping()</a> <a class="el" href="classPxRigidDynamic.html#7a617db7f7c8e887d8e128956e04ba4a" title="Retrieves the angular damping coefficient.">getAngularDamping()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d977d8dc4858f3d5077e8b78f99fa62a"></a><!-- doxytag: member="PxRigidDynamic::getMaxAngularVelocity" ref="d977d8dc4858f3d5077e8b78f99fa62a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getMaxAngularVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the maximum angular velocity permitted for this actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum allowed angular velocity for this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#d90b8ba1636cfef0e3e2386bc21dc3f1" title="Lets you set the maximum angular velocity permitted for this actor.">setMaxAngularVelocity</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a88e055440d6c1cc846e32dbed017345"></a><!-- doxytag: member="PxRigidDynamic::getRigidDynamicLockFlags" ref="a88e055440d6c1cc846e32dbed017345" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFlags.html">PxRigidDynamicLockFlags</a> PxRigidDynamic::getRigidDynamicLockFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> lock flags. 
<p>
See the list of flags <a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific...">PxRigidDynamicLockFlag</a><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The values of the PxRigidDynamicLock flags.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific...">PxRigidDynamicLockFlag</a> <a class="el" href="classPxRigidDynamic.html#7cf3e84117da3ec5b499262a3a9f5521" title="Raises or clears a particular rigid dynamic lock flag.">setRigidDynamicLockFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a0232d5a392e204e6b133fd2ab0879e"></a><!-- doxytag: member="PxRigidDynamic::getSleepThreshold" ref="1a0232d5a392e204e6b133fd2ab0879e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getSleepThreshold           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mass-normalized kinetic energy below which an actor may go to sleep. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The energy threshold for sleeping.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping.">wakeUp()</a> <a class="el" href="classPxRigidDynamic.html#ae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep.">putToSleep()</a> <a class="el" href="classPxRigidDynamic.html#c087213f7360a202eaccfab26e97e644" title="Sets the mass-normalized kinetic energy threshold below which an actor may go to...">setSleepThreshold()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fcdafcbc0dd5a691d502b2f7b03a7d7"></a><!-- doxytag: member="PxRigidDynamic::getSolverIterationCounts" ref="2fcdafcbc0dd5a691d502b2f7b03a7d7" args="(PxU32 &amp;minPositionIters, PxU32 &amp;minVelocityIters) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::getSolverIterationCounts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>minVelocityIters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the solver iteration counts. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#fa68d947962bc2d0f8862caaf3e8b304" title="Sets the solver iteration counts for the body.">setSolverIterationCounts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f9d98c9bd3b9ab0be7ce1b3ec4a4574"></a><!-- doxytag: member="PxRigidDynamic::getStabilizationThreshold" ref="5f9d98c9bd3b9ab0be7ce1b3ec4a4574" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getStabilizationThreshold           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mass-normalized kinetic energy below which an actor may participate in stabilization. 
<p>
Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The energy threshold for participating in stabilization.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#59fb22d9402497cffe1b5e54d9ecd62f" title="Sets the mass-normalized kinetic energy threshold below which an actor may participate...">setStabilizationThreshold()</a> <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53909e1cb63ea9c0394e2c2b3a526f47fe" title="Enables additional stabilization pass in solver.">PxSceneFlag::eENABLE_STABILIZATION</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="88dc31fa470c5f37e3e9683534ad83aa"></a><!-- doxytag: member="PxRigidDynamic::getWakeCounter" ref="88dc31fa470c5f37e3e9683534ad83aa" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidDynamic::getWakeCounter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the wake counter of the actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The wake counter of the actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#0f7de8c56c76461555219b2b98d5147a" title="Sets the wake counter for the actor.">setWakeCounter()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ed60c0a05771d8679069a46b778f8f8"></a><!-- doxytag: member="PxRigidDynamic::isKindOf" ref="0ed60c0a05771d8679069a46b778f8f8" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidDynamic::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>superClass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a given type name matches with the type of this instance. 
<p>

<p>Reimplemented from <a class="el" href="classPxRigidBody.html#d2e17e08871d8a2f492aee495550a0a0">PxRigidBody</a>.</p>

<p>References <a class="el" href="PxRigidBody_8h-source.html#l00562">PxRigidBody::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="af537a84cd9b119ed5f77888c600f2ae"></a><!-- doxytag: member="PxRigidDynamic::isSleeping" ref="af537a84cd9b119ed5f77888c600f2ae" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidDynamic::isSleeping           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this body is sleeping. 
<p>
When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.<p>
In general, a dynamic rigid actor is guaranteed to be awake if at least one of the following holds:<p>
<ul>
<li>The wake counter is positive (see <a class="el" href="classPxRigidDynamic.html#0f7de8c56c76461555219b2b98d5147a" title="Sets the wake counter for the actor.">setWakeCounter()</a>). </li>
<li>The linear or angular velocity is non-zero. </li>
<li>A non-zero force or torque has been applied.</li>
</ul>
If a dynamic rigid actor is sleeping, the following state is guaranteed:<p>
<ul>
<li>The wake counter is zero. </li>
<li>The linear and angular velocity is zero. </li>
<li>There is no force update pending.</li>
</ul>
When an actor gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.<p>
If an actor is asleep after the call to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> returns, it is guaranteed that the pose of the actor was not changed. You can use this information to avoid updating the transforms of associated objects.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A kinematic actor is asleep unless a target pose has been set (in which case it will stay awake until the end of the next simulation step where no target pose has been set anymore). The wake counter will get set to zero or to the reset value <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> in the case where a target pose has been set to be consistent with the definitions above.<p>
It is invalid to use this method if the actor has not been added to a scene already.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the actor is sleeping.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping.">wakeUp()</a> <a class="el" href="classPxRigidDynamic.html#ae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep.">putToSleep()</a> <a class="el" href="classPxRigidDynamic.html#1a0232d5a392e204e6b133fd2ab0879e" title="Returns the mass-normalized kinetic energy below which an actor may go to sleep.">getSleepThreshold()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae00aa2067a2fe268b999aad04f27c28"></a><!-- doxytag: member="PxRigidDynamic::putToSleep" ref="ae00aa2067a2fe268b999aad04f27c28" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::putToSleep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the actor to sleep. 
<p>
The actor will stay asleep during the next simulation step if not touched by another non-sleeping actor.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Any applied force will be cleared and the velocity and the wake counter of the actor will be set to 0.<p>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.<p>
It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a>).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping.">wakeUp()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5435556860f16008b2c88ae6c36025dd"></a><!-- doxytag: member="PxRigidDynamic::setAngularDamping" ref="5435556860f16008b2c88ae6c36025dd" args="(PxReal angDamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setAngularDamping           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>angDamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the angular damping coefficient. 
<p>
Zero represents no damping.<p>
The angular damping coefficient must be nonnegative.<p>
<b>Default:</b> 0.05<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angDamp</em>&nbsp;</td><td>Angular damping coefficient. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#7a617db7f7c8e887d8e128956e04ba4a" title="Retrieves the angular damping coefficient.">getAngularDamping()</a> <a class="el" href="classPxRigidDynamic.html#003953e985ace5966375acb0674f7b0b" title="Sets the linear damping coefficient.">setLinearDamping()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfd510964f2287e81fe76a1a9e1725b5"></a><!-- doxytag: member="PxRigidDynamic::setContactReportThreshold" ref="bfd510964f2287e81fe76a1a9e1725b5" args="(PxReal threshold)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setContactReportThreshold           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>threshold</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the force threshold for contact reports. 
<p>
See <a class="el" href="classPxRigidDynamic.html#cc91baffa652090e523df5e6627686ed" title="Retrieves the force threshold for contact reports.">getContactReportThreshold()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Force threshold for contact reports. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#cc91baffa652090e523df5e6627686ed" title="Retrieves the force threshold for contact reports.">getContactReportThreshold</a> <a class="el" href="structPxPairFlag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4464d188e7a1e94582c9cf35da9bbc93"></a><!-- doxytag: member="PxRigidDynamic::setKinematicTarget" ref="4464d188e7a1e94582c9cf35da9bbc93" args="(const PxTransform &amp;destination)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setKinematicTarget           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves kinematically controlled dynamic actors through the game world. 
<p>
You set a dynamic actor to be kinematic using the <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596bd76e6985e9db78efb7a66148ea4c212" title="Enables kinematic mode for the actor.">PxRigidBodyFlag::eKINEMATIC</a> flag with <a class="el" href="classPxRigidBody.html#9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a>.<p>
The move command will result in a velocity that will move the body into the desired pose. After the move is carried out during a single time step, the velocity is returned to zero. Thus, you must continuously call this in every time step for kinematic actors so that they move along a path.<p>
This function simply stores the move destination until the next simulation step is processed, so consecutive calls will simply overwrite the stored target variable.<p>
The motion is always fully carried out.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and will set the wake counter to <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>destination</em>&nbsp;</td><td>The desired pose for the kinematic actor, in the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#3b6ed86370cfd04958ca7e1c637e310b" title="Get target pose of a kinematically controlled dynamic actor.">getKinematicTarget()</a> <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="003953e985ace5966375acb0674f7b0b"></a><!-- doxytag: member="PxRigidDynamic::setLinearDamping" ref="003953e985ace5966375acb0674f7b0b" args="(PxReal linDamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setLinearDamping           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>linDamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the linear damping coefficient. 
<p>
Zero represents no damping. The damping coefficient must be nonnegative.<p>
<b>Default:</b> 0.0<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linDamp</em>&nbsp;</td><td>Linear damping coefficient. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#e59cea37df7d70286dc587a4967f5512" title="Retrieves the linear damping coefficient.">getLinearDamping()</a> <a class="el" href="classPxRigidDynamic.html#5435556860f16008b2c88ae6c36025dd" title="Sets the angular damping coefficient.">setAngularDamping()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d90b8ba1636cfef0e3e2386bc21dc3f1"></a><!-- doxytag: member="PxRigidDynamic::setMaxAngularVelocity" ref="d90b8ba1636cfef0e3e2386bc21dc3f1" args="(PxReal maxAngVel)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setMaxAngularVelocity           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>maxAngVel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lets you set the maximum angular velocity permitted for this actor. 
<p>
For various internal computations, very quickly rotating actors introduce error into the simulation, which leads to undesired results.<p>
With this function, you can set the maximum angular velocity permitted for this rigid body. Higher angular velocities are clamped to this value.<p>
Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.<p>
<b>Default:</b> 7.0<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxAngVel</em>&nbsp;</td><td>Max allowable angular velocity for actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#d977d8dc4858f3d5077e8b78f99fa62a" title="Retrieves the maximum angular velocity permitted for this actor.">getMaxAngularVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7cf3e84117da3ec5b499262a3a9f5521"></a><!-- doxytag: member="PxRigidDynamic::setRigidDynamicLockFlag" ref="7cf3e84117da3ec5b499262a3a9f5521" args="(PxRigidDynamicLockFlag::Enum flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setRigidDynamicLockFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxRigidDynamicLockFlag.html#e2e527a7cf32504d4b5c8c6d147280e1">PxRigidDynamicLockFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raises or clears a particular rigid dynamic lock flag. 
<p>
See the list of flags <a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific...">PxRigidDynamicLockFlag</a><p>
<b>Default:</b> no flags are set<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>The PxRigidDynamicLockBody flag to raise(set) or clear. See <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The new boolean value for the flag.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxRigidDynamicLockFlag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific...">PxRigidDynamicLockFlag</a> <a class="el" href="classPxRigidDynamic.html#a88e055440d6c1cc846e32dbed017345" title="Reads the PxRigidDynamic lock flags.">getRigidDynamicLockFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="16f9f0dfeae6e7877bcebca80df42c92"></a><!-- doxytag: member="PxRigidDynamic::setRigidDynamicLockFlags" ref="16f9f0dfeae6e7877bcebca80df42c92" args="(PxRigidDynamicLockFlags flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setRigidDynamicLockFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxRigidDynamicLockFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c087213f7360a202eaccfab26e97e644"></a><!-- doxytag: member="PxRigidDynamic::setSleepThreshold" ref="c087213f7360a202eaccfab26e97e644" args="(PxReal threshold)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setSleepThreshold           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>threshold</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep. 
<p>
Actors whose kinetic energy divided by their mass is below this threshold will be candidates for sleeping.<p>
<b>Default:</b> 5e-5f * <a class="el" href="classPxTolerancesScale.html#629358a15988697feaa85759d5c57e33">PxTolerancesScale::speed</a> * <a class="el" href="classPxTolerancesScale.html#629358a15988697feaa85759d5c57e33">PxTolerancesScale::speed</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Energy below which an actor may go to sleep. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#1a0232d5a392e204e6b133fd2ab0879e" title="Returns the mass-normalized kinetic energy below which an actor may go to sleep.">getSleepThreshold()</a> <a class="el" href="classPxRigidDynamic.html#4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping.">wakeUp()</a> <a class="el" href="classPxRigidDynamic.html#ae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep.">putToSleep()</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa68d947962bc2d0f8862caaf3e8b304"></a><!-- doxytag: member="PxRigidDynamic::setSolverIterationCounts" ref="fa68d947962bc2d0f8862caaf3e8b304" args="(PxU32 minPositionIters, PxU32 minVelocityIters=1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setSolverIterationCounts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>minVelocityIters</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the solver iteration counts for the body. 
<p>
The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.<p>
If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.<p>
<b>Default:</b> 4 position iterations, 1 velocity iteration<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minPositionIters</em>&nbsp;</td><td>Number of position iterations the solver should perform for this body. <b>Range:</b> [1,255] </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minVelocityIters</em>&nbsp;</td><td>Number of velocity iterations the solver should perform for this body. <b>Range:</b> [1,255]</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#2fcdafcbc0dd5a691d502b2f7b03a7d7" title="Retrieves the solver iteration counts.">getSolverIterationCounts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="59fb22d9402497cffe1b5e54d9ecd62f"></a><!-- doxytag: member="PxRigidDynamic::setStabilizationThreshold" ref="59fb22d9402497cffe1b5e54d9ecd62f" args="(PxReal threshold)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setStabilizationThreshold           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>threshold</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization. 
<p>
Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.<p>
This value has no effect if <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53909e1cb63ea9c0394e2c2b3a526f47fe" title="Enables additional stabilization pass in solver.">PxSceneFlag::eENABLE_STABILIZATION</a> was not enabled on the <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a>.<p>
<b>Default:</b> 1e-5f * <a class="el" href="classPxTolerancesScale.html#629358a15988697feaa85759d5c57e33">PxTolerancesScale::speed</a> * <a class="el" href="classPxTolerancesScale.html#629358a15988697feaa85759d5c57e33">PxTolerancesScale::speed</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Energy below which an actor may participate in stabilization. <b>Range:</b> [0,inf)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#5f9d98c9bd3b9ab0be7ce1b3ec4a4574" title="Returns the mass-normalized kinetic energy below which an actor may participate in...">getStabilizationThreshold()</a> <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53909e1cb63ea9c0394e2c2b3a526f47fe" title="Enables additional stabilization pass in solver.">PxSceneFlag::eENABLE_STABILIZATION</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f7de8c56c76461555219b2b98d5147a"></a><!-- doxytag: member="PxRigidDynamic::setWakeCounter" ref="0f7de8c56c76461555219b2b98d5147a" args="(PxReal wakeCounterValue)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::setWakeCounter           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>wakeCounterValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the wake counter for the actor. 
<p>
The wake counter value determines the minimum amount of time until the body can be put to sleep. Please note that a body will not be put to sleep if the energy is above the specified threshold (see <a class="el" href="classPxRigidDynamic.html#c087213f7360a202eaccfab26e97e644" title="Sets the mass-normalized kinetic energy threshold below which an actor may go to...">setSleepThreshold()</a>) or if other awake bodies are touching it.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Passing in a positive value will wake the actor up automatically.<p>
It is invalid to use this method for kinematic actors since the wake counter for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a>).<p>
It is invalid to use this method if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeCounterValue</em>&nbsp;</td><td>Wake counter value. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#88dc31fa470c5f37e3e9683534ad83aa" title="Returns the wake counter of the actor.">getWakeCounter()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f1b9e9f437d8b8f27a6e9c2d9ea22fd"></a><!-- doxytag: member="PxRigidDynamic::wakeUp" ref="4f1b9e9f437d8b8f27a6e9c2d9ea22fd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidDynamic::wakeUp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wakes up the actor if it is sleeping. 
<p>
The actor will get woken up and might cause other touching actors to wake up as well during the next simulation step.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This will set the wake counter of the actor to the value specified in <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a>.<p>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.<p>
It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a>).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#af537a84cd9b119ed5f77888c600f2ae" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classPxRigidDynamic.html#ae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep.">putToSleep()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidDynamic_8h-source.html">PxRigidDynamic.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
