<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxRigidBody Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxRigidBody Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxRigidBody" --><!-- doxytag: inherits="PxRigidActor" --><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxRigidBody_8h-source.html">PxRigidBody.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxRigidBody:</div>
<div class="dynsection">
<p><center><img src="classPxRigidBody__inherit__graph.png" border="0" usemap="#PxRigidBody__inherit__map" alt="Inheritance graph"></center>
<map name="PxRigidBody__inherit__map">
<area shape="rect" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body" alt="PxArticulationLink" coords="7,293,116,315"><area shape="rect" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK." alt="PxRigidDynamic" coords="140,293,244,315"><area shape="rect" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies..." alt="PxRigidActor" coords="85,155,168,176"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="PxActor" coords="100,85,153,107"><area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="99,16,155,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidBody:</div>
<div class="dynsection">
<p><center><img src="classPxRigidBody__coll__graph.png" border="0" usemap="#PxRigidBody__coll__map" alt="Collaboration graph"></center>
<map name="PxRigidBody__coll__map">
<area shape="rect" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies..." alt="PxRigidActor" coords="84,250,167,272"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="PxActor" coords="99,178,152,200"><area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="97,106,153,128"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" alt="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" coords="7,16,244,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxRigidBody-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mass Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf">setCMassLocalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pose of the center of mass relative to the actor.  <a href="#b152773926fe7b222d61e982c3cb6adf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#afdbdab1865112b15201aeabb23877b4">getCMassLocalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the center of mass pose relative to the actor frame.  <a href="#afdbdab1865112b15201aeabb23877b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35">setMass</a> (PxReal mass)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <a href="#8a697a7a4b9bdd2c83a68e84b9bc3a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#2b1c475ca9cc6aebc168ac58256b7284">getMass</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the mass of the actor.  <a href="#2b1c475ca9cc6aebc168ac58256b7284"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#4c82bd72a216c0460887cf94184560bd">getInvMass</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the inverse mass of the actor.  <a href="#4c82bd72a216c0460887cf94184560bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd">setMassSpaceInertiaTensor</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;m)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <a href="#755d0c8a8d1dd8b29e59d50a6dfda5fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#063cce94190de44d86a15c1b49dd7f71">getMassSpaceInertiaTensor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <a href="#063cce94190de44d86a15c1b49dd7f71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#63830b4cd24cd6e5e9f5bb2d6a1d3dc3">getMassSpaceInvInertiaTensor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  <a href="#63830b4cd24cd6e5e9f5bb2d6a1d3dc3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#04bab22deecb716e2cdd7a64b5cfaee7">getLinearVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <a href="#04bab22deecb716e2cdd7a64b5cfaee7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#0aed51d5ddcf81b09a104ad7f0f30c05">setLinearVelocity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;linVel, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear velocity of the actor.  <a href="#0aed51d5ddcf81b09a104ad7f0f30c05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#f91b92d6fcf47103b148337749aa93e0">getAngularVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <a href="#f91b92d6fcf47103b148337749aa93e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#d49850630db14af26e019d2550ecfd27">setAngularVelocity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;angVel, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular velocity of the actor.  <a href="#d49850630db14af26e019d2550ecfd27"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Forces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c">addForce</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;force, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  <a href="#22b0a1ef0b6c5656a6063c5c38f5679c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79">addTorque</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;torque, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <a href="#cb04ffc816d45afff2d04e93d7446e79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#efe5174aa160a07d488de2a18ba61f94">clearForce</a> (<a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the accumulated forces (sets the accumulated force back to zero).  <a href="#efe5174aa160a07d488de2a18ba61f94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#e251132385cc0b082b612d709aa4375d">clearTorque</a> (<a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the impulsive torque defined in the global coordinate frame to the actor.  <a href="#e251132385cc0b082b612d709aa4375d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#9b23b890404b1010bf0b67a225bd22e7">setRigidBodyFlag</a> (<a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raises or clears a particular rigid body flag.  <a href="#9b23b890404b1010bf0b67a225bd22e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#9e6f3afd71605e037a5de47955d941e0">setRigidBodyFlags</a> (<a class="el" href="classPxFlags.html">PxRigidBodyFlags</a> inFlags)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFlags.html">PxRigidBodyFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#2ef3c66318db72f2dd2c1b0d20513f18">getRigidBodyFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags.  <a href="#2ef3c66318db72f2dd2c1b0d20513f18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#c6f4fe582726801cb09c2381de0c144d">setMinCCDAdvanceCoefficient</a> (PxReal advanceCoefficient)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the CCD minimum advance coefficient.  <a href="#c6f4fe582726801cb09c2381de0c144d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#bae787a717c8468dbf67345dde14ba85">getMinCCDAdvanceCoefficient</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the CCD minimum advance coefficient.  <a href="#bae787a717c8468dbf67345dde14ba85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#261ce18fdc6cb81c0bfb46590db0867d">setMaxDepenetrationVelocity</a> (PxReal biasClamp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <a href="#261ce18fdc6cb81c0bfb46590db0867d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#3304d26a39bbdd99dc0ad51d1d99aec4">getMaxDepenetrationVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <a href="#3304d26a39bbdd99dc0ad51d1d99aec4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#1a3bbe100e644995742f80f19ea8f250">setMaxContactImpulse</a> (PxReal maxImpulse)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.  <a href="#1a3bbe100e644995742f80f19ea8f250"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#2f9e9e7946ab265013229612aad4c3c7">getMaxContactImpulse</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum impulse that may be applied at a contact.  <a href="#2f9e9e7946ab265013229612aad4c3c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#df18dc769f8d1d3da7760097fa699acb">PxRigidBody</a> (<a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#14d4e7068063768f6029a975ff5d41e4">PxRigidBody</a> (<a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#229ff64730b95c9c36b653ffee707e8a">~PxRigidBody</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#d2e17e08871d8a2f492aee495550a0a0">isKindOf</a> (const char *name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#d2e17e08871d8a2f492aee495550a0a0"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="df18dc769f8d1d3da7760097fa699acb"></a><!-- doxytag: member="PxRigidBody::PxRigidBody" ref="df18dc769f8d1d3da7760097fa699acb" args="(PxType concreteType, PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidBody::PxRigidBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a>&nbsp;</td>
          <td class="paramname"> <em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="14d4e7068063768f6029a975ff5d41e4"></a><!-- doxytag: member="PxRigidBody::PxRigidBody" ref="14d4e7068063768f6029a975ff5d41e4" args="(PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidBody::PxRigidBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="229ff64730b95c9c36b653ffee707e8a"></a><!-- doxytag: member="PxRigidBody::~PxRigidBody" ref="229ff64730b95c9c36b653ffee707e8a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidBody::~PxRigidBody           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="22b0a1ef0b6c5656a6063c5c38f5679c"></a><!-- doxytag: member="PxRigidBody::addForce" ref="22b0a1ef0b6c5656a6063c5c38f5679c" args="(const PxVec3 &amp;force, PxForceMode::Enum mode=PxForceMode::eFORCE, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::addForce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass. 
<p>
<b>This will not induce a torque</b>.<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the force is to be conventional or impulsive.<p>
Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545d8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5456e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse mass and then using <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545d8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> respectively.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.<p>
The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.<p>
if this is called on an articulation link, only the link is updated, not the entire articulation.<p>
see <a class="el" href="classPxRigidBodyExt.html#a0684e41c619824229cdedb47e06563a" title="Compute the change to linear and angular velocity that would occur if an impulsive...">PxRigidBodyExt::computeVelocityDeltaFromImpulse</a> for details of how to compute the change in linear velocity that will arise from the application of an impulsive force, where an impulsive force is applied force multiplied by a timestep.</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default) or the force is non-zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/Impulse to apply defined in the global frame. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Specify if the call should wake up the actor if it is currently asleep. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb04ffc816d45afff2d04e93d7446e79"></a><!-- doxytag: member="PxRigidBody::addTorque" ref="cb04ffc816d45afff2d04e93d7446e79" args="(const PxVec3 &amp;torque, PxForceMode::Enum mode=PxForceMode::eFORCE, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::addTorque           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies an impulsive torque defined in the global coordinate frame to the actor. 
<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the torque is to be conventional or impulsive.<p>
Each actor has an angular acceleration and an angular velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545d8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5456e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse inertia and then using <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545d8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> respectively.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.<p>
The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.<p>
if this called on an articulation link, only the link is updated, not the entire articulation.<p>
see <a class="el" href="classPxRigidBodyExt.html#a0684e41c619824229cdedb47e06563a" title="Compute the change to linear and angular velocity that would occur if an impulsive...">PxRigidBodyExt::computeVelocityDeltaFromImpulse</a> for details of how to compute the change in angular velocity that will arise from the application of an impulsive torque, where an impulsive torque is an applied torque multiplied by a timestep.</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default) or the torque is non-zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>torque</em>&nbsp;</td><td>Torque to apply defined in the global frame. <b>Range:</b> torque vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>whether to wake up the object if it is asleep. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor...">addForce()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="efe5174aa160a07d488de2a18ba61f94"></a><!-- doxytag: member="PxRigidBody::clearForce" ref="efe5174aa160a07d488de2a18ba61f94" args="(PxForceMode::Enum mode=PxForceMode::eFORCE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::clearForce           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the accumulated forces (sets the accumulated force back to zero). 
<p>
Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545d8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5456e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> also modify these same accumulators (see <a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor...">PxRigidBody::addForce()</a> for details); therefore the effect of calling clearForce(PxForceMode::eFORCE) is equivalent to calling clearForce(PxForceMode::eACCELERATION), and the effect of calling clearForce(PxForceMode::eIMPULSE) is equivalent to calling clearForce(PxForceMode::eVELOCITY_CHANGE).<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the cleared force is to be conventional or impulsive.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.<p>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when clearing the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor...">addForce</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e251132385cc0b082b612d709aa4375d"></a><!-- doxytag: member="PxRigidBody::clearTorque" ref="e251132385cc0b082b612d709aa4375d" args="(PxForceMode::Enum mode=PxForceMode::eFORCE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::clearTorque           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the impulsive torque defined in the global coordinate frame to the actor. 
<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the cleared torque is to be conventional or impulsive.<p>
Each actor has an angular acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545d8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5456e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> also modify these same accumulators (see <a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">PxRigidBody::addTorque()</a> for details); therefore the effect of calling clearTorque(PxForceMode::eFORCE) is equivalent to calling clearTorque(PxForceMode::eACCELERATION), and the effect of calling clearTorque(PxForceMode::eIMPULSE) is equivalent to calling clearTorque(PxForceMode::eVELOCITY_CHANGE).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.<p>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when clearing the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>).</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f91b92d6fcf47103b148337749aa93e0"></a><!-- doxytag: member="PxRigidBody::getAngularVelocity" ref="f91b92d6fcf47103b148337749aa93e0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getAngularVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the angular velocity of the actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The angular velocity of the actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#d49850630db14af26e019d2550ecfd27" title="Sets the angular velocity of the actor.">PxRigidDynamic.setAngularVelocity()</a> <a class="el" href="classPxRigidBody.html#04bab22deecb716e2cdd7a64b5cfaee7" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="afdbdab1865112b15201aeabb23877b4"></a><!-- doxytag: member="PxRigidBody::getCMassLocalPose" ref="afdbdab1865112b15201aeabb23877b4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxRigidBody::getCMassLocalPose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the center of mass pose relative to the actor frame. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The center of mass pose relative to the actor frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c82bd72a216c0460887cf94184560bd"></a><!-- doxytag: member="PxRigidBody::getInvMass" ref="4c82bd72a216c0460887cf94184560bd" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getInvMass           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the inverse mass of the actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The inverse mass of this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="04bab22deecb716e2cdd7a64b5cfaee7"></a><!-- doxytag: member="PxRigidBody::getLinearVelocity" ref="04bab22deecb716e2cdd7a64b5cfaee7" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getLinearVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the linear velocity of an actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The linear velocity of the actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#0aed51d5ddcf81b09a104ad7f0f30c05" title="Sets the linear velocity of the actor.">PxRigidDynamic.setLinearVelocity()</a> <a class="el" href="classPxRigidBody.html#f91b92d6fcf47103b148337749aa93e0" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b1c475ca9cc6aebc168ac58256b7284"></a><!-- doxytag: member="PxRigidBody::getMass" ref="2b1c475ca9cc6aebc168ac58256b7284" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMass           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the mass of the actor. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A value of 0 is interpreted as infinite mass.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The mass of this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="063cce94190de44d86a15c1b49dd7f71"></a><!-- doxytag: member="PxRigidBody::getMassSpaceInertiaTensor" ref="063cce94190de44d86a15c1b49dd7f71" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getMassSpaceInertiaTensor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame. 
<p>
This method retrieves a mass frame inertia vector.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The mass space inertia tensor of this actor.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="63830b4cd24cd6e5e9f5bb2d6a1d3dc3"></a><!-- doxytag: member="PxRigidBody::getMassSpaceInvInertiaTensor" ref="63830b4cd24cd6e5e9f5bb2d6a1d3dc3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getMassSpaceInvInertiaTensor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame. 
<p>
This method retrieves a mass frame inverse inertia vector.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The mass space inverse inertia tensor of this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f9e9e7946ab265013229612aad4c3c7"></a><!-- doxytag: member="PxRigidBody::getMaxContactImpulse" ref="2f9e9e7946ab265013229612aad4c3c7" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMaxContactImpulse           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the maximum impulse that may be applied at a contact. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum impulse that may be applied at a contact</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#1a3bbe100e644995742f80f19ea8f250" title="Sets a limit on the impulse that may be applied at a contact. The maximum impulse...">setMaxContactImpulse</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3304d26a39bbdd99dc0ad51d1d99aec4"></a><!-- doxytag: member="PxRigidBody::getMaxDepenetrationVelocity" ref="3304d26a39bbdd99dc0ad51d1d99aec4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMaxDepenetrationVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum penetration bias applied by the solver. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bae787a717c8468dbf67345dde14ba85"></a><!-- doxytag: member="PxRigidBody::getMinCCDAdvanceCoefficient" ref="bae787a717c8468dbf67345dde14ba85" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMinCCDAdvanceCoefficient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the CCD minimum advance coefficient. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the CCD min advance coefficient.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#c6f4fe582726801cb09c2381de0c144d" title="Sets the CCD minimum advance coefficient.">setMinCCDAdvanceCoefficient</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ef3c66318db72f2dd2c1b0d20513f18"></a><!-- doxytag: member="PxRigidBody::getRigidBodyFlags" ref="2ef3c66318db72f2dd2c1b0d20513f18" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFlags.html">PxRigidBodyFlags</a> PxRigidBody::getRigidBodyFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags. 
<p>
See the list of flags <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The values of the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2e17e08871d8a2f492aee495550a0a0"></a><!-- doxytag: member="PxRigidBody::isKindOf" ref="d2e17e08871d8a2f492aee495550a0a0" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidBody::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>superClass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a given type name matches with the type of this instance. 
<p>

<p>Reimplemented from <a class="el" href="classPxRigidActor.html#e644382039f621f73ca7db7aa9d2e0cf">PxRigidActor</a>.</p>

<p>Reimplemented in <a class="el" href="classPxArticulationLink.html#45d7a988876af31572acca1376401c18">PxArticulationLink</a>, and <a class="el" href="classPxRigidDynamic.html#0ed60c0a05771d8679069a46b778f8f8">PxRigidDynamic</a>.</p>

<p>References <a class="el" href="PxRigidActor_8h-source.html#l00295">PxRigidActor::isKindOf()</a>.</p>

<p>Referenced by <a class="el" href="PxRigidDynamic_8h-source.html#l00461">PxRigidDynamic::isKindOf()</a>, and <a class="el" href="PxArticulationLink_8h-source.html#l00113">PxArticulationLink::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d49850630db14af26e019d2550ecfd27"></a><!-- doxytag: member="PxRigidBody::setAngularVelocity" ref="d49850630db14af26e019d2550ecfd27" args="(const PxVec3 &amp;angVel, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setAngularVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the angular velocity of the actor. 
<p>
Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.<p>
<b>Default:</b> (0.0, 0.0, 0.0)<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping, the autowake parameter is true (default) or the new velocity is non-zero<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is invalid to use this method if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angVel</em>&nbsp;</td><td>New angular velocity of actor. <b>Range:</b> angular velocity vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Whether to wake the object up if it is asleep and the velocity is non-zero. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#f91b92d6fcf47103b148337749aa93e0" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> <a class="el" href="classPxRigidBody.html#0aed51d5ddcf81b09a104ad7f0f30c05" title="Sets the linear velocity of the actor.">setLinearVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b152773926fe7b222d61e982c3cb6adf"></a><!-- doxytag: member="PxRigidBody::setCMassLocalPose" ref="b152773926fe7b222d61e982c3cb6adf" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setCMassLocalPose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the pose of the center of mass relative to the actor. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Changing this transform will not move the actor in the world!<p>
Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<b>Default:</b> the identity transform<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Mass frame offset transform relative to the actor frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#afdbdab1865112b15201aeabb23877b4" title="Retrieves the center of mass pose relative to the actor frame.">getCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div><p>
<a class="anchor" name="0aed51d5ddcf81b09a104ad7f0f30c05"></a><!-- doxytag: member="PxRigidBody::setLinearVelocity" ref="0aed51d5ddcf81b09a104ad7f0f30c05" args="(const PxVec3 &amp;linVel, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setLinearVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>linVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the linear velocity of the actor. 
<p>
Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.<p>
<b>Default:</b> (0.0, 0.0, 0.0)<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping, the autowake parameter is true (default) or the new velocity is non-zero<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is invalid to use this method if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linVel</em>&nbsp;</td><td>New linear velocity of actor. <b>Range:</b> velocity vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Whether to wake the object up if it is asleep and the velocity is non-zero. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#04bab22deecb716e2cdd7a64b5cfaee7" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> <a class="el" href="classPxRigidBody.html#d49850630db14af26e019d2550ecfd27" title="Sets the angular velocity of the actor.">setAngularVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a697a7a4b9bdd2c83a68e84b9bc3a35"></a><!-- doxytag: member="PxRigidBody::setMass" ref="8a697a7a4b9bdd2c83a68e84b9bc3a35" args="(PxReal mass)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMass           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>mass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mass of a dynamic actor. 
<p>
The mass must be non-negative.<p>
<a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> does not update the inertial properties of the body, to change the inertia tensor use <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> or the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#769be90cdb138897ce426aa04ac0a1e7" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A value of 0 is interpreted as infinite mass. <p>
Values of 0 are not permitted for instances of <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a> but are permitted for instances of <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.</dd></dl>
<b>Default:</b> 1.0<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mass</em>&nbsp;</td><td>New mass value for the actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#2b1c475ca9cc6aebc168ac58256b7284" title="Retrieves the mass of the actor.">getMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="755d0c8a8d1dd8b29e59d50a6dfda5fd"></a><!-- doxytag: member="PxRigidBody::setMassSpaceInertiaTensor" ref="755d0c8a8d1dd8b29e59d50a6dfda5fd" args="(const PxVec3 &amp;m)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMassSpaceInertiaTensor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the inertia tensor, using a parameter specified in mass space coordinates. 
<p>
Note that such matrices are diagonal -- the passed vector is the diagonal.<p>
If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a>.<p>
The inertia tensor elements must be non-negative.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis. <p>
Values of 0 are not permitted for instances of <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a> but are permitted for instances of <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.</dd></dl>
<b>Default:</b> (1.0, 1.0, 1.0)<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>New mass space inertia tensor for the actor.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBodyDesc.massSpaceInertia getMassSpaceInertia() <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a3bbe100e644995742f80f19ea8f250"></a><!-- doxytag: member="PxRigidBody::setMaxContactImpulse" ref="1a3bbe100e644995742f80f19ea8f250" args="(PxReal maxImpulse)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMaxContactImpulse           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>maxImpulse</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body. 
<p>
This value is not used in CCD unless <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596b2bb4cc4246807076a2103d72bd69e00" title="Permit CCD to limit maxContactImpulse. This is useful for use-cases like a destruction...">PxRigidBodyFlag::eENABLE_CCD_MAX_CONTACT_IMPULSE</a> is raised on the body.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxImpulse</em>&nbsp;</td><td>the maximum contact impulse. <b>Range:</b> [0, PX_MAX_F32] <b>Default:</b> PX_MAX_F32</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#2f9e9e7946ab265013229612aad4c3c7" title="Returns the maximum impulse that may be applied at a contact.">getMaxContactImpulse</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="261ce18fdc6cb81c0bfb46590db0867d"></a><!-- doxytag: member="PxRigidBody::setMaxDepenetrationVelocity" ref="261ce18fdc6cb81c0bfb46590db0867d" args="(PxReal biasClamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMaxDepenetrationVelocity           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>biasClamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>biasClamp</em>&nbsp;</td><td>The maximum velocity to de-penetrate by <b>Range:</b> (0, PX_MAX_F32]. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c6f4fe582726801cb09c2381de0c144d"></a><!-- doxytag: member="PxRigidBody::setMinCCDAdvanceCoefficient" ref="c6f4fe582726801cb09c2381de0c144d" args="(PxReal advanceCoefficient)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMinCCDAdvanceCoefficient           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>advanceCoefficient</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the CCD minimum advance coefficient. 
<p>
The CCD minimum advance coefficient is a value in the range [0, 1] that is used to control the minimum amount of time a body is integrated when it has a CCD contact. The actual minimum amount of time that is integrated depends on various properties, including the relative speed and collision shapes of the bodies involved in the contact. From these properties, a numeric value is calculated that determines the maximum distance (and therefore maximum time) which these bodies could be integrated forwards that would ensure that these bodies did not pass through each-other. This value is then scaled by CCD minimum advance coefficient to determine the amount of time that will be consumed in the CCD pass.<p>
<b>Things to consider:</b> A large value (approaching 1) ensures that the objects will always advance some time. However, larger values increase the chances of objects gently drifting through each-other in scenes which the constraint solver can't converge, e.g. scenes where an object is being dragged through a wall with a constraint. A value of 0 ensures that the pair of objects stop at the exact time-of-impact and will not gently drift through each-other. However, with very small/thin objects initially in contact, this can lead to a large amount of time being dropped and increases the chances of jamming. Jamming occurs when the an object is persistently in contact with an object such that the time-of-impact is 0, which results in no time being advanced for those objects in that CCD pass.<p>
The chances of jamming can be reduced by increasing the number of CCD mass <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#65aa4ceefbbd6aebd75ea879d7c385f9" title="Maximum number of CCD passes.">PxSceneDesc.ccdMaxPasses</a>. However, increasing this number increases the CCD overhead.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>advanceCoefficient</em>&nbsp;</td><td>The CCD min advance coefficient. <b>Range:</b> [0, 1] <b>Default:</b> 0.15 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b23b890404b1010bf0b67a225bd22e7"></a><!-- doxytag: member="PxRigidBody::setRigidBodyFlag" ref="9b23b890404b1010bf0b67a225bd22e7" args="(PxRigidBodyFlag::Enum flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setRigidBodyFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raises or clears a particular rigid body flag. 
<p>
See the list of flags <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a><p>
<b>Default:</b> no flags are set<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>The <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flag to raise(set) or clear. See <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The new boolean value for the flag.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#2ef3c66318db72f2dd2c1b0d20513f18" title="Reads the PxRigidBody flags.">getRigidBodyFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e6f3afd71605e037a5de47955d941e0"></a><!-- doxytag: member="PxRigidBody::setRigidBodyFlags" ref="9e6f3afd71605e037a5de47955d941e0" args="(PxRigidBodyFlags inFlags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setRigidBodyFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxRigidBodyFlags</a>&nbsp;</td>
          <td class="paramname"> <em>inFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidBody_8h-source.html">PxRigidBody.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
