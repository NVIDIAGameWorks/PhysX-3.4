<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxDeletionListener Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxDeletionListener Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxDeletionListener" -->interface to get notification on object deletion  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxDeletionListener_8h-source.html">PxDeletionListener.h</a>&gt;</code>
<p>

<p>
<a href="classPxDeletionListener-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDeletionListener.html#76fa5705a41d0996d0f31c591f4f049c">onRelease</a> (const <a class="el" href="classPxBase.html">PxBase</a> *observed, void *userData, <a class="el" href="structPxDeletionEventFlag.html#77bf8900dd0107b612cdc7d86cb796f6">PxDeletionEventFlag::Enum</a> deletionEvent)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notification if an object or its memory gets released.  <a href="#76fa5705a41d0996d0f31c591f4f049c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDeletionListener.html#fc09e12240bd133f30d23fd73adb62d2">PxDeletionListener</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxDeletionListener.html#7c42c11dd067fbabe73b818a5d476bce">~PxDeletionListener</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
interface to get notification on object deletion <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fc09e12240bd133f30d23fd73adb62d2"></a><!-- doxytag: member="PxDeletionListener::PxDeletionListener" ref="fc09e12240bd133f30d23fd73adb62d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxDeletionListener::PxDeletionListener           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7c42c11dd067fbabe73b818a5d476bce"></a><!-- doxytag: member="PxDeletionListener::~PxDeletionListener" ref="7c42c11dd067fbabe73b818a5d476bce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxDeletionListener::~PxDeletionListener           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="76fa5705a41d0996d0f31c591f4f049c"></a><!-- doxytag: member="PxDeletionListener::onRelease" ref="76fa5705a41d0996d0f31c591f4f049c" args="(const PxBase *observed, void *userData, PxDeletionEventFlag::Enum deletionEvent)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxDeletionListener::onRelease           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBase.html">PxBase</a> *&nbsp;</td>
          <td class="paramname"> <em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxDeletionEventFlag.html#77bf8900dd0107b612cdc7d86cb796f6">PxDeletionEventFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>deletionEvent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notification if an object or its memory gets released. 
<p>
If release() gets called on a <a class="el" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> object, an eUSER_RELEASE event will get fired immediately. The object state can be queried in the callback but it is not allowed to change the state. Furthermore, when reading from the object it is the user's responsibility to make sure that no other thread is writing at the same time to the object (this includes the simulation itself, i.e., <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> must not get called at the same time).<p>
Calling release() on a <a class="el" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> object does not necessarily trigger its destructor immediately. For example, the object can be shared and might still be referenced by other objects or the simulation might still be running and accessing the object state. In such cases the destructor will be called as soon as it is safe to do so. After the destruction of the object and its memory, an eMEMORY_RELEASE event will get fired. In this case it is not allowed to dereference the object pointer in the callback.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>observed</em>&nbsp;</td><td>The object for which the deletion event gets fired. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data pointer of the object for which the deletion event gets fired. Not available for all object types in which case it will be set to 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>deletionEvent</em>&nbsp;</td><td>The type of deletion event. Do not dereference the object pointer argument if the event is eMEMORY_RELEASE. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxDeletionListener_8h-source.html">PxDeletionListener.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
