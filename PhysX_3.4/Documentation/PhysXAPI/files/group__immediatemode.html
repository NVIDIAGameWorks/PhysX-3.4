<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: Immediatemode</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>Immediatemode</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxRigidBodyData.html">PxRigidBodyData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to store rigid body properties.  <a href="structPxRigidBodyData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxContactRecorder.html">PxContactRecorder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback class to record contact points produced by <a class="el" href="group__immediatemode.html#g43ee6393438e91aa05bb2790559104b7">immediate::PxGenerateContacts</a>.  <a href="classPxContactRecorder.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#g56e360f21e02eeed788a58782e77316a">PxConstructSolverBodies</a> (const <a class="el" href="structPxRigidBodyData.html">PxRigidBodyData</a> *inRigidData, PxSolverBodyData *outSolverBodyData, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbBodies, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;gravity, const PxReal dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a PxSolverBodyData structure based on rigid body properties. Applies gravity, damping and clamps maximum velocity.  <a href="#g56e360f21e02eeed788a58782e77316a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#gb1ff672bf5a0569d6cc5f137142b1c1d">PxConstructStaticSolverBody</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;globalPose, PxSolverBodyData &amp;solverBodyData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a PxSolverBodyData structure for a static body at a given pose.  <a href="#gb1ff672bf5a0569d6cc5f137142b1c1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#g06ca05e94083ad8df2c5377cf692b4bf">PxBatchConstraints</a> (PxSolverConstraintDesc *solverConstraintDescs, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbConstraints, PxSolverBody *solverBodies, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbBodies, PxConstraintBatchHeader *outBatchHeaders, PxSolverConstraintDesc *outOrderedConstraintDescs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Groups together sets of independent PxSolverConstraintDesc objects to be solved using SIMD SOA approach.  <a href="#g06ca05e94083ad8df2c5377cf692b4bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#g3dc6c7ca660d5352b3da3198ab5036c8">PxCreateContactConstraints</a> (PxConstraintBatchHeader *batchHeader, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbHeaders, PxSolverContactDesc *contactDescs, PxConstraintAllocator &amp;allocator, PxReal invDt, PxReal bounceThreshold, PxReal frictionOffsetThreshold, PxReal correlationDistance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a set of contact constraint blocks. Note that, depending the results of PxBatchConstraints, each batchHeader may refer to up to 4 solverConstraintDescs. This function will allocate both constraint and friction patch data via the PxConstraintAllocator provided. Constraint data is only valid until PxSolveConstraints has completed. Friction data is to be retained and provided by the application for friction correlation.  <a href="#g3dc6c7ca660d5352b3da3198ab5036c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#gc016be640f563f4ec9acd6b33fecba1e">PxCreateJointConstraints</a> (PxConstraintBatchHeader *batchHeader, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbHeaders, PxSolverConstraintPrepDesc *jointDescs, PxConstraintAllocator &amp;allocator, PxReal dt, PxReal invDt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a set of joint constraint blocks. Note that, depending the results of PxBatchConstraints, the batchHeader may refer to up to 4 solverConstraintDescs.  <a href="#gc016be640f563f4ec9acd6b33fecba1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#g730ffbd6f8687f7909131b37b1cc0c05">PxCreateJointConstraintsWithShaders</a> (PxConstraintBatchHeader *batchHeader, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbBatchHeaders, <a class="el" href="classPxConstraint.html">PxConstraint</a> **constraints, PxSolverConstraintPrepDesc *jointDescs, PxConstraintAllocator &amp;allocator, PxReal dt, PxReal invDt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a set of joint constraint blocks. This function runs joint shaders defined inside PxConstraint** param, fills in joint row information in jointDescs and then calls PxCreateJointConstraints.  <a href="#g730ffbd6f8687f7909131b37b1cc0c05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#gf5de05898680bb26c7b24012acb0336d">PxSolveConstraints</a> (PxConstraintBatchHeader *batchHeaders, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbBatchHeaders, PxSolverConstraintDesc *solverConstraintDescs, PxSolverBody *solverBodies, <a class="el" href="classPxVec3.html">PxVec3</a> *linearMotionVelocity, <a class="el" href="classPxVec3.html">PxVec3</a> *angularMotionVelocity, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbSolverBodies, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbPositionIterations, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbVelocityIterations)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iteratively solves the set of constraints defined by the provided PxConstraintBatchHeader and PxSolverConstraintDesc structures. Updates deltaVelocities inside the PxSolverBody structures. Produces resulting linear and angular motion velocities.  <a href="#gf5de05898680bb26c7b24012acb0336d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#gbda17f364d0771bc7c0613ca0761cb73">PxIntegrateSolverBodies</a> (PxSolverBodyData *solverBodyData, PxSolverBody *solverBody, const <a class="el" href="classPxVec3.html">PxVec3</a> *linearMotionVelocity, const <a class="el" href="classPxVec3.html">PxVec3</a> *angularMotionState, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbBodiesToIntegrate, PxReal dt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integrates a rigid body, returning the new velocities and transforms. After this function has been called, solverBodyData stores all the body's velocity data.  <a href="#gbda17f364d0771bc7c0613ca0761cb73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_C_EXPORT PX_PHYSX_CORE_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__immediatemode.html#g43ee6393438e91aa05bb2790559104b7">PxGenerateContacts</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> *const *geom0, const <a class="el" href="classPxGeometry.html">PxGeometry</a> *const *geom1, const <a class="el" href="classPxTransform.html">PxTransform</a> *pose0, const <a class="el" href="classPxTransform.html">PxTransform</a> *pose1, PxCache *contactCache, const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbPairs, <a class="el" href="classPxContactRecorder.html">PxContactRecorder</a> &amp;contactRecorder, const PxReal contactDistance, const PxReal meshContactMargin, const PxReal toleranceLength, PxCacheAllocator &amp;allocator)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g06ca05e94083ad8df2c5377cf692b4bf"></a><!-- doxytag: member="PxImmediateMode.h::PxBatchConstraints" ref="g06ca05e94083ad8df2c5377cf692b4bf" args="(PxSolverConstraintDesc *solverConstraintDescs, const PxU32 nbConstraints, PxSolverBody *solverBodies, PxU32 nbBodies, PxConstraintBatchHeader *outBatchHeaders, PxSolverConstraintDesc *outOrderedConstraintDescs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxBatchConstraints           </td>
          <td>(</td>
          <td class="paramtype">PxSolverConstraintDesc *&nbsp;</td>
          <td class="paramname"> <em>solverConstraintDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverBody *&nbsp;</td>
          <td class="paramname"> <em>solverBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxConstraintBatchHeader *&nbsp;</td>
          <td class="paramname"> <em>outBatchHeaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverConstraintDesc *&nbsp;</td>
          <td class="paramname"> <em>outOrderedConstraintDescs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Groups together sets of independent PxSolverConstraintDesc objects to be solved using SIMD SOA approach. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>solverConstraintDescs</em>&nbsp;</td><td>the set of solver constraint descs to batch </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbConstraints</em>&nbsp;</td><td>The number of constraints to batch </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>solverBodies</em>&nbsp;</td><td>The array of solver bodies that the constraints reference. Some fields in these structures are written to as scratch memory for the batching. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbBodies</em>&nbsp;</td><td>The number of bodies </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outBatchHeaders</em>&nbsp;</td><td>The batch headers produced by this batching process. This array must have at least 1 entry per input constraint </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outOrderedConstraintDescs</em>&nbsp;</td><td>A reordered copy of the constraint descs. This array is referenced by the constraint batches. This array must have at least 1 entry per input constraint. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The total number of batches produced. This should be less than or equal to nbConstraints.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method considers all bodies within the range [0, nbBodies-1] to be valid dynamic bodies. A given dynamic body can only be referenced in a batch once. Static or kinematic bodies can be referenced multiple times within a batch safely because constraints do not affect their velocities. The batching will implicitly consider any bodies outside of the range [0, nbBodies-1] to be infinite mass (static or kinematic). This means that either appending static/kinematic to the end of the array of bodies or placing static/kinematic bodies at before the start body pointer will ensure that the minimum number of batches are produced. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g56e360f21e02eeed788a58782e77316a"></a><!-- doxytag: member="PxImmediateMode.h::PxConstructSolverBodies" ref="g56e360f21e02eeed788a58782e77316a" args="(const PxRigidBodyData *inRigidData, PxSolverBodyData *outSolverBodyData, const PxU32 nbBodies, const PxVec3 &amp;gravity, const PxReal dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API void PxConstructSolverBodies           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxRigidBodyData.html">PxRigidBodyData</a> *&nbsp;</td>
          <td class="paramname"> <em>inRigidData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverBodyData *&nbsp;</td>
          <td class="paramname"> <em>outSolverBodyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gravity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a PxSolverBodyData structure based on rigid body properties. Applies gravity, damping and clamps maximum velocity. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inRigidData</em>&nbsp;</td><td>The array rigid body properties </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outSolverBodyData</em>&nbsp;</td><td>The array of solverBodyData produced to repreent these bodies </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbBodies</em>&nbsp;</td><td>The total number of solver bodies to create </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gravity</em>&nbsp;</td><td>The gravity vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>The timestep </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb1ff672bf5a0569d6cc5f137142b1c1d"></a><!-- doxytag: member="PxImmediateMode.h::PxConstructStaticSolverBody" ref="gb1ff672bf5a0569d6cc5f137142b1c1d" args="(const PxTransform &amp;globalPose, PxSolverBodyData &amp;solverBodyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API void PxConstructStaticSolverBody           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>globalPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverBodyData &amp;&nbsp;</td>
          <td class="paramname"> <em>solverBodyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a PxSolverBodyData structure for a static body at a given pose. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>globalPose</em>&nbsp;</td><td>The pose of this static actor </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>solverBodyData</em>&nbsp;</td><td>The solver body representation of this static actor </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3dc6c7ca660d5352b3da3198ab5036c8"></a><!-- doxytag: member="PxImmediateMode.h::PxCreateContactConstraints" ref="g3dc6c7ca660d5352b3da3198ab5036c8" args="(PxConstraintBatchHeader *batchHeader, const PxU32 nbHeaders, PxSolverContactDesc *contactDescs, PxConstraintAllocator &amp;allocator, PxReal invDt, PxReal bounceThreshold, PxReal frictionOffsetThreshold, PxReal correlationDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API bool PxCreateContactConstraints           </td>
          <td>(</td>
          <td class="paramtype">PxConstraintBatchHeader *&nbsp;</td>
          <td class="paramname"> <em>batchHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbHeaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverContactDesc *&nbsp;</td>
          <td class="paramname"> <em>contactDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxConstraintAllocator &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>invDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>bounceThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>frictionOffsetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>correlationDistance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a set of contact constraint blocks. Note that, depending the results of PxBatchConstraints, each batchHeader may refer to up to 4 solverConstraintDescs. This function will allocate both constraint and friction patch data via the PxConstraintAllocator provided. Constraint data is only valid until PxSolveConstraints has completed. Friction data is to be retained and provided by the application for friction correlation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batchHeader</em>&nbsp;</td><td>Array of batch headers to process </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbHeaders</em>&nbsp;</td><td>The total number of headers </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contactDescs</em>&nbsp;</td><td>An array of contact descs defining the pair and contact properties of each respective contacting pair </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allocator</em>&nbsp;</td><td>An allocator callback to allocate constraint and friction memory </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>invDt</em>&nbsp;</td><td>The inverse timestep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bounceThreshold</em>&nbsp;</td><td>The bounce threshold. Relative velocities below this will be solved by bias only. Relative velocities above this will be solved by restitution. If restitution is zero then these pairs will always be solved by bias. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>frictionOffsetThreshold</em>&nbsp;</td><td>The friction offset threshold. Contacts whose separations are below this threshold can generate friction constraints. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>correlationDistance</em>&nbsp;</td><td>The correlation distance used by friction correlation to identify whether a friction patch is broken on the grounds of relation separation.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a boolean to define if this method was successful or not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc016be640f563f4ec9acd6b33fecba1e"></a><!-- doxytag: member="PxImmediateMode.h::PxCreateJointConstraints" ref="gc016be640f563f4ec9acd6b33fecba1e" args="(PxConstraintBatchHeader *batchHeader, const PxU32 nbHeaders, PxSolverConstraintPrepDesc *jointDescs, PxConstraintAllocator &amp;allocator, PxReal dt, PxReal invDt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API bool PxCreateJointConstraints           </td>
          <td>(</td>
          <td class="paramtype">PxConstraintBatchHeader *&nbsp;</td>
          <td class="paramname"> <em>batchHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbHeaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverConstraintPrepDesc *&nbsp;</td>
          <td class="paramname"> <em>jointDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxConstraintAllocator &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>invDt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a set of joint constraint blocks. Note that, depending the results of PxBatchConstraints, the batchHeader may refer to up to 4 solverConstraintDescs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batchHeader</em>&nbsp;</td><td>The array of batch headers to be processed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbHeaders</em>&nbsp;</td><td>The total number of batch headers to process </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jointDescs</em>&nbsp;</td><td>An array of constraint prep descs defining the properties of the constraints being created </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allocator</em>&nbsp;</td><td>An allocator callback to allocate constraint data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>The timestep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>invDt</em>&nbsp;</td><td>The inverse timestep </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a boolean indicating if this method was successful or not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g730ffbd6f8687f7909131b37b1cc0c05"></a><!-- doxytag: member="PxImmediateMode.h::PxCreateJointConstraintsWithShaders" ref="g730ffbd6f8687f7909131b37b1cc0c05" args="(PxConstraintBatchHeader *batchHeader, const PxU32 nbBatchHeaders, PxConstraint **constraints, PxSolverConstraintPrepDesc *jointDescs, PxConstraintAllocator &amp;allocator, PxReal dt, PxReal invDt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API bool PxCreateJointConstraintsWithShaders           </td>
          <td>(</td>
          <td class="paramtype">PxConstraintBatchHeader *&nbsp;</td>
          <td class="paramname"> <em>batchHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbBatchHeaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxConstraint.html">PxConstraint</a> **&nbsp;</td>
          <td class="paramname"> <em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverConstraintPrepDesc *&nbsp;</td>
          <td class="paramname"> <em>jointDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxConstraintAllocator &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>invDt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a set of joint constraint blocks. This function runs joint shaders defined inside PxConstraint** param, fills in joint row information in jointDescs and then calls PxCreateJointConstraints. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batchHeader</em>&nbsp;</td><td>The set of batchHeaders to be processed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbBatchHeaders</em>&nbsp;</td><td>The number of batch headers to process. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constraints</em>&nbsp;</td><td>The set of constraints to be used to produce constraint rows </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>jointDescs</em>&nbsp;</td><td>An array of constraint prep descs defining the properties of the constraints being created </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allocator</em>&nbsp;</td><td>An allocator callback to allocate constraint data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>The timestep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>invDt</em>&nbsp;</td><td>The inverse timestep </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a boolean indicating if this method was successful or not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g43ee6393438e91aa05bb2790559104b7"></a><!-- doxytag: member="PxImmediateMode.h::PxGenerateContacts" ref="g43ee6393438e91aa05bb2790559104b7" args="(const PxGeometry *const *geom0, const PxGeometry *const *geom1, const PxTransform *pose0, const PxTransform *pose1, PxCache *contactCache, const PxU32 nbPairs, PxContactRecorder &amp;contactRecorder, const PxReal contactDistance, const PxReal meshContactMargin, const PxReal toleranceLength, PxCacheAllocator &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API bool PxGenerateContacts           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> *const *&nbsp;</td>
          <td class="paramname"> <em>geom0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> *const *&nbsp;</td>
          <td class="paramname"> <em>geom1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>pose0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>pose1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxCache *&nbsp;</td>
          <td class="paramname"> <em>contactCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxContactRecorder.html">PxContactRecorder</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>contactRecorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>contactDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>meshContactMargin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>toleranceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxCacheAllocator &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
abrief Performs contact generation for a given pair of geometries at the specified poses. Produced contacts are stored in the provided Gu::ContactBuffer. Information is cached in PxCache structure to accelerate future contact generation between pairs. This cache data is valid only as long as the memory provided by PxCacheAllocator has not been released/re-used. Recommendation is to retain that data for a single simulation frame, discarding cached data after 2 frames. If the cached memory has been released/re-used prior to the corresponding pair having contact generation performed again, it is the application's responsibility to reset the PxCache.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geom0</em>&nbsp;</td><td>Array of geometries to perform collision detection on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geom1</em>&nbsp;</td><td>Array of geometries to perform collision detection on </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose0</em>&nbsp;</td><td>Array of poses associated with the corresponding entry in the geom0 array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose1</em>&nbsp;</td><td>Array of poses associated with the corresponding entry in the geom1 array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>contactCache</em>&nbsp;</td><td>Array of contact caches associated with each pair geom0[i] + geom1[i] </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbPairs</em>&nbsp;</td><td>The total number of pairs to process </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contactRecorder</em>&nbsp;</td><td>A callback that is called to record contacts for each pair that detects contacts </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contactDistance</em>&nbsp;</td><td>The distance at which contacts begin to be generated between the pairs </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>meshContactMargin</em>&nbsp;</td><td>The mesh contact margin. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>toleranceLength</em>&nbsp;</td><td>The toleranceLength. Used for scaling distance-based thresholds internally to produce appropriate results given simulations in different units </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allocator</em>&nbsp;</td><td>A callback to allocate memory for the contact cache</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a boolean indicating if the function was successful or not. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbda17f364d0771bc7c0613ca0761cb73"></a><!-- doxytag: member="PxImmediateMode.h::PxIntegrateSolverBodies" ref="gbda17f364d0771bc7c0613ca0761cb73" args="(PxSolverBodyData *solverBodyData, PxSolverBody *solverBody, const PxVec3 *linearMotionVelocity, const PxVec3 *angularMotionState, const PxU32 nbBodiesToIntegrate, PxReal dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API void PxIntegrateSolverBodies           </td>
          <td>(</td>
          <td class="paramtype">PxSolverBodyData *&nbsp;</td>
          <td class="paramname"> <em>solverBodyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverBody *&nbsp;</td>
          <td class="paramname"> <em>solverBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>linearMotionVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>angularMotionState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbBodiesToIntegrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>dt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Integrates a rigid body, returning the new velocities and transforms. After this function has been called, solverBodyData stores all the body's velocity data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>solverBodyData</em>&nbsp;</td><td>The array of solver body data to be integrated </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>solverBody</em>&nbsp;</td><td>The bodies' linear and angular velocities </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linearMotionVelocity</em>&nbsp;</td><td>The bodies' linear motion velocity array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angularMotionState</em>&nbsp;</td><td>The bodies' angular motion velocity array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbBodiesToIntegrate</em>&nbsp;</td><td>The total number of bodies to integrate </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dt</em>&nbsp;</td><td>The timestep </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf5de05898680bb26c7b24012acb0336d"></a><!-- doxytag: member="PxImmediateMode.h::PxSolveConstraints" ref="gf5de05898680bb26c7b24012acb0336d" args="(PxConstraintBatchHeader *batchHeaders, const PxU32 nbBatchHeaders, PxSolverConstraintDesc *solverConstraintDescs, PxSolverBody *solverBodies, PxVec3 *linearMotionVelocity, PxVec3 *angularMotionVelocity, const PxU32 nbSolverBodies, const PxU32 nbPositionIterations, const PxU32 nbVelocityIterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_C_EXPORT PX_PHYSX_CORE_API void PxSolveConstraints           </td>
          <td>(</td>
          <td class="paramtype">PxConstraintBatchHeader *&nbsp;</td>
          <td class="paramname"> <em>batchHeaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbBatchHeaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverConstraintDesc *&nbsp;</td>
          <td class="paramname"> <em>solverConstraintDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxSolverBody *&nbsp;</td>
          <td class="paramname"> <em>solverBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>linearMotionVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>angularMotionVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbSolverBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbPositionIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbVelocityIterations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iteratively solves the set of constraints defined by the provided PxConstraintBatchHeader and PxSolverConstraintDesc structures. Updates deltaVelocities inside the PxSolverBody structures. Produces resulting linear and angular motion velocities. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batchHeaders</em>&nbsp;</td><td>The set of batch headers to be solved </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbBatchHeaders</em>&nbsp;</td><td>The total number of batch headers to be solved </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>solverConstraintDescs</em>&nbsp;</td><td>The reordererd set of solver constraint descs referenced by the batch headers </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>solverBodies</em>&nbsp;</td><td>The set of solver bodies the bodies reference </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>linearMotionVelocity</em>&nbsp;</td><td>The resulting linear motion velocity </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>angularMotionVelocity</em>&nbsp;</td><td>The resulting angular motion velocity. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbSolverBodies</em>&nbsp;</td><td>The total number of solver bodies </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbPositionIterations</em>&nbsp;</td><td>The number of position iterations to run </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbVelocityIterations</em>&nbsp;</td><td>The number of velocity iterations to run </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
