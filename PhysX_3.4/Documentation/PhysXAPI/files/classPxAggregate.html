<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxAggregate Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxAggregate Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxAggregate" --><!-- doxytag: inherits="PxBase" -->Class to aggregate actors into a single broad-phase entry.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxAggregate_8h-source.html">PxAggregate.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxAggregate:</div>
<div class="dynsection">
<p><center><img src="classPxAggregate__inherit__graph.png" border="0" usemap="#PxAggregate__inherit__map" alt="Inheritance graph"></center>
<map name="PxAggregate__inherit__map">
<area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="21,16,77,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxAggregate:</div>
<div class="dynsection">
<p><center><img src="classPxAggregate__coll__graph.png" border="0" usemap="#PxAggregate__coll__map" alt="Collaboration graph"></center>
<map name="PxAggregate__coll__map">
<area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="97,106,153,128"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" alt="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" coords="7,16,244,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxAggregate-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#4e49bed771f4c7804dfac6882c2af273">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the aggregate object.  <a href="#4e49bed771f4c7804dfac6882c2af273"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#5e56d324aa7ab5628df4a1f84a27c59b">addActor</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an actor to the aggregate object.  <a href="#5e56d324aa7ab5628df4a1f84a27c59b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#70b1868fc13cbd7675684380cd434613">removeActor</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an actor from the aggregate object.  <a href="#70b1868fc13cbd7675684380cd434613"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#0e6a31ba97bc369e66dd01397b82d71b">addArticulation</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;articulation)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an articulation to the aggregate object.  <a href="#0e6a31ba97bc369e66dd01397b82d71b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#9dc3eee59441d7ad6ad166b9dcefe0a4">removeArticulation</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;articulation)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an articulation from the aggregate object.  <a href="#9dc3eee59441d7ad6ad166b9dcefe0a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#070c8dee88ae92f062417ac5a20a5a64">getNbActors</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of actors contained in the aggregate.  <a href="#070c8dee88ae92f062417ac5a20a5a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#e54ef106d3797674aa08b0d32400c8a3">getMaxNbActors</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves max amount of actors that can be contained in the aggregate.  <a href="#e54ef106d3797674aa08b0d32400c8a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#0e87d0b4af5f03e6323ec3817086b366">getActors</a> (<a class="el" href="classPxActor.html">PxActor</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all actors contained in the aggregate.  <a href="#0e87d0b4af5f03e6323ec3817086b366"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#a70f305e7f2934d99afd74d28b0c0194">getScene</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene which this aggregate belongs to.  <a href="#a70f305e7f2934d99afd74d28b0c0194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#ecc9a58a8966bb5b76fd82b655efb43e">getSelfCollision</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves aggregate's self-collision flag.  <a href="#ecc9a58a8966bb5b76fd82b655efb43e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#d93b769087546b1a96ba0302b6b52cd7">getConcreteTypeName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns string name of dynamic type.  <a href="#d93b769087546b1a96ba0302b6b52cd7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#5a056899bfb00d7165bd04bcb6e0dc52">PxAggregate</a> (<a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#b837e81a00421796a5a7f1f0a3551fe0">PxAggregate</a> (<a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#3eff872c05654d1bea567c091cbee916">~PxAggregate</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxAggregate.html#1e0c26f3a6785c99802e6ef8dd9f7625">isKindOf</a> (const char *name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#1e0c26f3a6785c99802e6ef8dd9f7625"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class to aggregate actors into a single broad-phase entry. 
<p>
A <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> object is a collection of PxActors, which will exist as a single entry in the broad-phase structures. This has 3 main benefits:<p>
1) it reduces "broad phase pollution" by allowing a collection of spatially coherent broad-phase entries to be replaced by a single aggregated entry (e.g. a ragdoll or a single actor with a large number of attached shapes).<p>
2) it reduces broad-phase memory usage<p>
3) filtering can be optimized a lot if self-collisions within an aggregate are not needed. For example if you don't need collisions between ragdoll bones, it's faster to simply disable filtering once and for all, for the aggregate containing the ragdoll, rather than filtering out each bone-bone collision in the filter shader.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classPxPhysics.html#4209ffb5ab43cd7d9c6a59e4139c1993" title="Creates an aggregate with the specified maximum size and selfCollision property.">PxPhysics.createAggregate</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5a056899bfb00d7165bd04bcb6e0dc52"></a><!-- doxytag: member="PxAggregate::PxAggregate" ref="5a056899bfb00d7165bd04bcb6e0dc52" args="(PxType concreteType, PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxAggregate::PxAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a>&nbsp;</td>
          <td class="paramname"> <em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b837e81a00421796a5a7f1f0a3551fe0"></a><!-- doxytag: member="PxAggregate::PxAggregate" ref="b837e81a00421796a5a7f1f0a3551fe0" args="(PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxAggregate::PxAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3eff872c05654d1bea567c091cbee916"></a><!-- doxytag: member="PxAggregate::~PxAggregate" ref="3eff872c05654d1bea567c091cbee916" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxAggregate::~PxAggregate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5e56d324aa7ab5628df4a1f84a27c59b"></a><!-- doxytag: member="PxAggregate::addActor" ref="5e56d324aa7ab5628df4a1f84a27c59b" args="(PxActor &amp;actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxAggregate::addActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an actor to the aggregate object. 
<p>
A warning is output if the total number of actors is reached, or if the incoming actor already belongs to an aggregate.<p>
If the aggregate belongs to a scene, adding an actor to the aggregate also adds the actor to that scene.<p>
If the actor already belongs to a scene, a warning is output and the call is ignored. You need to remove the actor from the scene first, before adding it to the aggregate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor that should be added to the aggregate return true if success </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e6a31ba97bc369e66dd01397b82d71b"></a><!-- doxytag: member="PxAggregate::addArticulation" ref="0e6a31ba97bc369e66dd01397b82d71b" args="(PxArticulation &amp;articulation)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxAggregate::addArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>articulation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an articulation to the aggregate object. 
<p>
A warning is output if the total number of actors is reached (every articulation link counts as an actor), or if the incoming articulation already belongs to an aggregate.<p>
If the aggregate belongs to a scene, adding an articulation to the aggregate also adds the articulation to that scene.<p>
If the articulation already belongs to a scene, a warning is output and the call is ignored. You need to remove the articulation from the scene first, before adding it to the aggregate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>articulation</em>&nbsp;</td><td>The articulation that should be added to the aggregate return true if success </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e87d0b4af5f03e6323ec3817086b366"></a><!-- doxytag: member="PxAggregate::getActors" ref="0e87d0b4af5f03e6323ec3817086b366" args="(PxActor **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxAggregate::getActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all actors contained in the aggregate. 
<p>
You can retrieve the number of actor pointers by calling <a class="el" href="classPxAggregate.html#070c8dee88ae92f062417ac5a20a5a64" title="Returns the number of actors contained in the aggregate.">getNbActors()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the actor pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first actor pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of actor pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> getNbShapes() </dd></dl>

</div>
</div><p>
<a class="anchor" name="d93b769087546b1a96ba0302b6b52cd7"></a><!-- doxytag: member="PxAggregate::getConcreteTypeName" ref="d93b769087546b1a96ba0302b6b52cd7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxAggregate::getConcreteTypeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns string name of dynamic type. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Class name of most derived type of this object. </dd></dl>

<p>Implements <a class="el" href="classPxBase.html#67fe206d8897ddce896c371ac8d789a9">PxBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="e54ef106d3797674aa08b0d32400c8a3"></a><!-- doxytag: member="PxAggregate::getMaxNbActors" ref="e54ef106d3797674aa08b0d32400c8a3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxAggregate::getMaxNbActors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves max amount of actors that can be contained in the aggregate. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Max aggregate size.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#4209ffb5ab43cd7d9c6a59e4139c1993" title="Creates an aggregate with the specified maximum size and selfCollision property.">PxPhysics::createAggregate()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="070c8dee88ae92f062417ac5a20a5a64"></a><!-- doxytag: member="PxAggregate::getNbActors" ref="070c8dee88ae92f062417ac5a20a5a64" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxAggregate::getNbActors           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of actors contained in the aggregate. 
<p>
You can use <a class="el" href="classPxAggregate.html#0e87d0b4af5f03e6323ec3817086b366" title="Retrieve all actors contained in the aggregate.">getActors()</a> to retrieve the actor pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of actors contained in the aggregate.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> <a class="el" href="classPxAggregate.html#0e87d0b4af5f03e6323ec3817086b366" title="Retrieve all actors contained in the aggregate.">getActors()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a70f305e7f2934d99afd74d28b0c0194"></a><!-- doxytag: member="PxAggregate::getScene" ref="a70f305e7f2934d99afd74d28b0c0194" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxScene.html">PxScene</a>* PxAggregate::getScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the scene which this aggregate belongs to. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Owner Scene. NULL if not part of a scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecc9a58a8966bb5b76fd82b655efb43e"></a><!-- doxytag: member="PxAggregate::getSelfCollision" ref="ecc9a58a8966bb5b76fd82b655efb43e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxAggregate::getSelfCollision           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves aggregate's self-collision flag. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>self-collision flag </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e0c26f3a6785c99802e6ef8dd9f7625"></a><!-- doxytag: member="PxAggregate::isKindOf" ref="1e0c26f3a6785c99802e6ef8dd9f7625" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxAggregate::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>superClass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a given type name matches with the type of this instance. 
<p>

<p>Reimplemented from <a class="el" href="classPxBase.html#ae9d444c7cfd1715a101350a1b1226ef">PxBase</a>.</p>

<p>References <a class="el" href="PxBase_8h-source.html#l00178">PxBase::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4e49bed771f4c7804dfac6882c2af273"></a><!-- doxytag: member="PxAggregate::release" ref="4e49bed771f4c7804dfac6882c2af273" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxAggregate::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the aggregate object. 
<p>
Deleting the <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> object does not delete the aggregated actors. If the <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> object belongs to a scene, the aggregated actors are automatically re-inserted in that scene. If you intend to delete both the <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> and its actors, it is best to release the actors first, then release the <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> when it is empty. 
<p>Implements <a class="el" href="classPxBase.html#fe6aedda1df0d6d29b1a28213a5ee25a">PxBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="70b1868fc13cbd7675684380cd434613"></a><!-- doxytag: member="PxAggregate::removeActor" ref="70b1868fc13cbd7675684380cd434613" args="(PxActor &amp;actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxAggregate::removeActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an actor from the aggregate object. 
<p>
A warning is output if the incoming actor does not belong to the aggregate. Otherwise the actor is removed from the aggregate. If the aggregate belongs to a scene, the actor is reinserted in that scene. If you intend to delete the actor, it is best to call <a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762" title="Deletes the actor.">PxActor::release()</a> directly. That way the actor will be automatically removed from its aggregate (if any) and not reinserted in a scene.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor that should be removed from the aggregate return true if success </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9dc3eee59441d7ad6ad166b9dcefe0a4"></a><!-- doxytag: member="PxAggregate::removeArticulation" ref="9dc3eee59441d7ad6ad166b9dcefe0a4" args="(PxArticulation &amp;articulation)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxAggregate::removeArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>articulation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an articulation from the aggregate object. 
<p>
A warning is output if the incoming articulation does not belong to the aggregate. Otherwise the articulation is removed from the aggregate. If the aggregate belongs to a scene, the articulation is reinserted in that scene. If you intend to delete the articulation, it is best to call <a class="el" href="classPxArticulation.html#05473039f1bd3bb20f824be6ae5aa435" title="Deletes the articulation.">PxArticulation::release()</a> directly. That way the articulation will be automatically removed from its aggregate (if any) and not reinserted in a scene.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>articulation</em>&nbsp;</td><td>The articulation that should be removed from the aggregate return true if success </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxAggregate_8h-source.html">PxAggregate.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
