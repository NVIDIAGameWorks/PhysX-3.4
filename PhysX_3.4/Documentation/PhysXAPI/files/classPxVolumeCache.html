<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxVolumeCache Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxVolumeCache Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxVolumeCache" -->Volumetric cache for local collision geometry.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxVolumeCache_8h-source.html">PxVolumeCache.h</a>&gt;</code>
<p>

<p>
<a href="classPxVolumeCache-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPxVolumeCache_1_1Iterator.html">Iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback wrapper class for use with <a class="el" href="classPxVolumeCache.html#e589287aa090d15e8bd13efd7a80285b" title="Iterates over the scene shapes overlapping with the cache volume.">PxVolumeCache::forEach</a> function.  <a href="structPxVolumeCache_1_1Iterator.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5">FillStatus</a> { <br>
&nbsp;&nbsp;<a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f505556701b332b57b8899a95c431d8b56">FILL_OK</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f54a3175a948c5e06d6a2c2f44495a6f95">FILL_OVER_MAX_COUNT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f536f4ffaf326d5f4fc310fd0a8676e6f3">FILL_UNSUPPORTED_GEOMETRY_TYPE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5cbdc57f8bf59feec81f31871969c8c1e">FILL_OUT_OF_MEMORY</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">describes <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> return status.  <a href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5">FillStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17">fill</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;cacheVolume, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the cache with objects intersecting the specified cacheVolume.  <a href="#046b0c5bed6e6f0dad3696cc9b69ed17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#f151c4569e890ee2b36b1c9ad0da348f">isValid</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the cache is valid (not over specified max capacity, for both statics and dynamics) and up-to-date.  <a href="#f151c4569e890ee2b36b1c9ad0da348f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#a5f2d9a1fcd27838188f4da17ae03dd8">invalidate</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidates the cache.  <a href="#a5f2d9a1fcd27838188f4da17ae03dd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#31f69209809698ad305b9ae29b5d2366">getCacheVolume</a> (<a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a> &amp;resultVolume, <a class="el" href="classPxTransform.html">PxTransform</a> &amp;resultPose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the last cached volume geometry.  <a href="#31f69209809698ad305b9ae29b5d2366"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxI32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#cd8687904f29300ec7a27222f8db50bf">getNbCachedShapes</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of cached shapes.  <a href="#cd8687904f29300ec7a27222f8db50bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#5cf192b373fadb356a2c016717852c4d">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases the cache object and its resources.  <a href="#5cf192b373fadb356a2c016717852c4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#e589287aa090d15e8bd13efd7a80285b">forEach</a> (<a class="el" href="structPxVolumeCache_1_1Iterator.html">Iterator</a> &amp;iter)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterates over the scene shapes overlapping with the cache volume.  <a href="#e589287aa090d15e8bd13efd7a80285b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#7c239abc1d93b2dea0cec7ae68d93319">setMaxNbStaticShapes</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the limit on the maximum number of static shapes allowed to be stored in the cache.  <a href="#7c239abc1d93b2dea0cec7ae68d93319"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#30048238aa971768c4bf24c56d186d7c">setMaxNbDynamicShapes</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the limit on the maximum number of dynamic shapes allowed to be stored in the cache.  <a href="#30048238aa971768c4bf24c56d186d7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#daf05a6049d5f282069ab2d666fdc911">getMaxNbStaticShapes</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current maximum number of static cached shapes.  <a href="#daf05a6049d5f282069ab2d666fdc911"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#721bd8c6edc998ad2fd2b113c4acb1a4">getMaxNbDynamicShapes</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current maximum number of dynamic cached shapes.  <a href="#721bd8c6edc998ad2fd2b113c4acb1a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#e9feb4df002ccf6a69f1442689f18186">raycast</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const PxReal distance, <a class="el" href="structPxHitCallback.html">PxRaycastCallback</a> &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raycast against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation.  <a href="#e9feb4df002ccf6a69f1442689f18186"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#86eb361338891b14b27f9d4594b15df8">sweep</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const PxReal distance, <a class="el" href="structPxHitCallback.html">PxSweepCallback</a> &amp;hitCall, PxHitFlags hitFlags=PxHitFlag::eDEFAULT, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=NULL, const PxReal inflation=0.f) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation.  <a href="#86eb361338891b14b27f9d4594b15df8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#d339ef9e688aed817333ef1ac78d868c">overlap</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, <a class="el" href="structPxHitCallback.html">PxOverlapCallback</a> &amp;hitCall, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test overlap between a geometry and objects in the cache.  <a href="#d339ef9e688aed817333ef1ac78d868c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxVolumeCache.html#1fad2b6c49845c49d143151678e01616">~PxVolumeCache</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Volumetric cache for local collision geometry. 
<p>
Provides a mechanism for caching objects within a specified volume and performing raycast, sweep, overlap and forEach queries on the cached objects.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>The volume cache feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b5921a4665caaa38d0e02d9324b77c7c" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume...">PxScene.createVolumeCache()</a> </dd></dl>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="43e58f6fea62f6ec81827e2f251912f5"></a><!-- doxytag: member="PxVolumeCache::FillStatus" ref="43e58f6fea62f6ec81827e2f251912f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5">PxVolumeCache::FillStatus</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
describes <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> return status. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">PxVolumeCache.fill()</a> </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="43e58f6fea62f6ec81827e2f251912f505556701b332b57b8899a95c431d8b56"></a><!-- doxytag: member="FILL_OK" ref="43e58f6fea62f6ec81827e2f251912f505556701b332b57b8899a95c431d8b56" args="" -->FILL_OK</em>&nbsp;</td><td>
Cache <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> operation was successful, the cache is valid and had enough capacity to store all the objects within the specified cacheVolume. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="43e58f6fea62f6ec81827e2f251912f54a3175a948c5e06d6a2c2f44495a6f95"></a><!-- doxytag: member="FILL_OVER_MAX_COUNT" ref="43e58f6fea62f6ec81827e2f251912f54a3175a948c5e06d6a2c2f44495a6f95" args="" -->FILL_OVER_MAX_COUNT</em>&nbsp;</td><td>
Over specified cache capacity. 
<p>
Cache <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> was over max count specified in <a class="el" href="classPxScene.html#b5921a4665caaa38d0e02d9324b77c7c" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume...">PxScene.createVolumeCache()</a> or <a class="el" href="classPxVolumeCache.html#7c239abc1d93b2dea0cec7ae68d93319" title="Sets the limit on the maximum number of static shapes allowed to be stored in the...">setMaxNbStaticShapes()</a> and <a class="el" href="classPxVolumeCache.html#30048238aa971768c4bf24c56d186d7c" title="Sets the limit on the maximum number of dynamic shapes allowed to be stored in the...">setMaxNbDynamicShapes()</a>. If this value is returned the cache will be in invalid state (no caching), but all the queries will still return correct results within the specified cache volume.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b5921a4665caaa38d0e02d9324b77c7c" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume...">PxScene.createVolumeCache()</a> <a class="el" href="classPxVolumeCache.html#7c239abc1d93b2dea0cec7ae68d93319" title="Sets the limit on the maximum number of static shapes allowed to be stored in the...">setMaxNbStaticShapes()</a> <a class="el" href="classPxVolumeCache.html#30048238aa971768c4bf24c56d186d7c" title="Sets the limit on the maximum number of dynamic shapes allowed to be stored in the...">setMaxNbDynamicShapes()</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="43e58f6fea62f6ec81827e2f251912f536f4ffaf326d5f4fc310fd0a8676e6f3"></a><!-- doxytag: member="FILL_UNSUPPORTED_GEOMETRY_TYPE" ref="43e58f6fea62f6ec81827e2f251912f536f4ffaf326d5f4fc310fd0a8676e6f3" args="" -->FILL_UNSUPPORTED_GEOMETRY_TYPE</em>&nbsp;</td><td>
Unsupported geometry type. 
<p>
The geometry type of cacheVolume parameter provided to <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> is not supported. Supported types are sphere, box, capsule. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="43e58f6fea62f6ec81827e2f251912f5cbdc57f8bf59feec81f31871969c8c1e"></a><!-- doxytag: member="FILL_OUT_OF_MEMORY" ref="43e58f6fea62f6ec81827e2f251912f5cbdc57f8bf59feec81f31871969c8c1e" args="" -->FILL_OUT_OF_MEMORY</em>&nbsp;</td><td>
Cache <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> ran out of temporary memory for intermediate results, try reducing the cache size. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1fad2b6c49845c49d143151678e01616"></a><!-- doxytag: member="PxVolumeCache::~PxVolumeCache" ref="1fad2b6c49845c49d143151678e01616" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxVolumeCache::~PxVolumeCache           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="046b0c5bed6e6f0dad3696cc9b69ed17"></a><!-- doxytag: member="PxVolumeCache::fill" ref="046b0c5bed6e6f0dad3696cc9b69ed17" args="(const PxGeometry &amp;cacheVolume, const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5">FillStatus</a> PxVolumeCache::fill           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cacheVolume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the cache with objects intersecting the specified cacheVolume. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cacheVolume</em>&nbsp;</td><td>Geometry of the cached volume (supported types are: sphere, box, capsule). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the cache volume.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5" title="describes fill() return status.">FillStatus</a> enum.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5" title="describes fill() return status.">PxVolumeCache.FillStatus</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e589287aa090d15e8bd13efd7a80285b"></a><!-- doxytag: member="PxVolumeCache::forEach" ref="e589287aa090d15e8bd13efd7a80285b" args="(Iterator &amp;iter)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::forEach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxVolumeCache_1_1Iterator.html">Iterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterates over the scene shapes overlapping with the cache volume. 
<p>
forEach will invoke <a class="el" href="structPxVolumeCache_1_1Iterator.html#865f03b842d2e74a249ed840435d17a9" title="Reports cache contents to the user.">PxVolumeCache::Iterator::processShapes</a> virtual function, returning all overlapping shapes (possibly by issuing multiple callbacks) to the user. The size of reported blocks can change depending on internal SDK implementation. Any pointers to the contents of the buffer are only valid within the scope of a single processShapes() callback function. If forEach is invoked on an invalid cache (empty or out of date), this call will attempt to refill the cache within specified capacity. If the cache is over capacity, an attempt will be made to allocate a temp internal buffer, retrieve the results directly from the scene and return to the user via provided iterator. Results from forEach will be current for the last set cacheVolume provided in <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> even if the cache is invalid and refill fails. If the number of overlapping shapes is so high that the internal temporary allocation fails this call will produce an error and return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td><a class="el" href="structPxVolumeCache_1_1Iterator.html" title="A callback wrapper class for use with PxVolumeCache::forEach function.">Iterator</a> callback. <a class="el" href="classPxVolumeCache.html#e589287aa090d15e8bd13efd7a80285b" title="Iterates over the scene shapes overlapping with the cache volume.">forEach()</a> will invokes iter.shapes() function (possibly multiple times) to return blocks of actor+shape pairs overlapped with cacheVolume to the user. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31f69209809698ad305b9ae29b5d2366"></a><!-- doxytag: member="PxVolumeCache::getCacheVolume" ref="31f69209809698ad305b9ae29b5d2366" args="(PxGeometryHolder &amp;resultVolume, PxTransform &amp;resultPose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::getCacheVolume           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>resultVolume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>resultPose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the last cached volume geometry. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False if the cache wasn't previously filled. True otherwise with cacheVolume from the last <a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> call returned in resultVolume and corresponding transform in resultPose.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxVolumeCache.html#046b0c5bed6e6f0dad3696cc9b69ed17" title="Fills the cache with objects intersecting the specified cacheVolume.">fill()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="721bd8c6edc998ad2fd2b113c4acb1a4"></a><!-- doxytag: member="PxVolumeCache::getMaxNbDynamicShapes" ref="721bd8c6edc998ad2fd2b113c4acb1a4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxVolumeCache::getMaxNbDynamicShapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current maximum number of dynamic cached shapes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The max number of cached dynamics. </dd></dl>

</div>
</div><p>
<a class="anchor" name="daf05a6049d5f282069ab2d666fdc911"></a><!-- doxytag: member="PxVolumeCache::getMaxNbStaticShapes" ref="daf05a6049d5f282069ab2d666fdc911" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxVolumeCache::getMaxNbStaticShapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current maximum number of static cached shapes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The max number of cached statics. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd8687904f29300ec7a27222f8db50bf"></a><!-- doxytag: member="PxVolumeCache::getNbCachedShapes" ref="cd8687904f29300ec7a27222f8db50bf" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxI32 PxVolumeCache::getNbCachedShapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of cached shapes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of shapes stored in the cache (statics+dynamics). Returns -1 if the cache is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5f2d9a1fcd27838188f4da17ae03dd8"></a><!-- doxytag: member="PxVolumeCache::invalidate" ref="a5f2d9a1fcd27838188f4da17ae03dd8" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::invalidate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalidates the cache. 
<p>
Marks the cache as invalid. Subsequent query will attempt to refill the cache from the scene. 
</div>
</div><p>
<a class="anchor" name="f151c4569e890ee2b36b1c9ad0da348f"></a><!-- doxytag: member="PxVolumeCache::isValid" ref="f151c4569e890ee2b36b1c9ad0da348f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::isValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the cache is valid (not over specified max capacity, for both statics and dynamics) and up-to-date. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the cache is valid and up-to-date. Cache can become out-of-date if any statics or dynamics are moved or added or deleted from the scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxVolumeCache.html#43e58f6fea62f6ec81827e2f251912f5" title="describes fill() return status.">PxVolumeCache.FillStatus</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d339ef9e688aed817333ef1ac78d868c"></a><!-- doxytag: member="PxVolumeCache::overlap" ref="d339ef9e688aed817333ef1ac78d868c" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, PxOverlapCallback &amp;hitCall, const PxQueryFilterData &amp;filterData=PxQueryFilterData(), PxQueryFilterCallback *filterCall=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::overlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHitCallback.html">PxOverlapCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test overlap between a geometry and objects in the cache. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: Overlap tests do not distinguish between touching and blocking hit types (see <a class="el" href="structPxQueryHitType.html" title="Classification of scene query hits (intersections).">PxQueryHitType</a>). Both get written to the hit buffer.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitCall</em>&nbsp;</td><td>Overlap hit callback or hit buffer object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to overlap. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found or any hit was found in case <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> flag was specified.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g9baa3a8cad31bbb8ef666fe01b3afeb7" title="Overlap query callback.">PxOverlapCallback</a> <a class="el" href="group__scenequery.html#g54a708942a891f3321c2427d5c160750" title="Overlap query buffer.">PxOverlapBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9feb4df002ccf6a69f1442689f18186"></a><!-- doxytag: member="PxVolumeCache::raycast" ref="e9feb4df002ccf6a69f1442689f18186" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, const PxReal distance, PxRaycastCallback &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const PxQueryFilterData &amp;filterData=PxQueryFilterData(), PxQueryFilterCallback *filterCall=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::raycast           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHitCallback.html">PxRaycastCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&nbsp;</td>
          <td class="paramname"> <em>hitFlags</em> = <code>PxHitFlags(PxHitFlag::eDEFAULT)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raycast against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation. 
<p>
Returns whether any rigid actor is hit along the ray.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in user guide article SceneQuery. User can ignore such objects by employing one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitCall</em>&nbsp;</td><td>Raycast hit callback or hit buffer object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitFlags</em>&nbsp;</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found or any hit was found in case <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> flag was used.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g4dbe8142d799492bd8e7c5ec70bfac41" title="Raycast query callback.">PxRaycastCallback</a> <a class="el" href="group__scenequery.html#gb21a68ce9e5a18aa742111920b75a84c" title="Raycast query buffer.">PxRaycastBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structPxQueryCache.html" title="single hit cache for scene queries.">PxQueryCache</a> <a class="el" href="structPxRaycastHit.html" title="Stores results of raycast queries.">PxRaycastHit</a> <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5cf192b373fadb356a2c016717852c4d"></a><!-- doxytag: member="PxVolumeCache::release" ref="5cf192b373fadb356a2c016717852c4d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the cache object and its resources. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b5921a4665caaa38d0e02d9324b77c7c" title="Creates a volume cache. See the Guide, &quot;Scene Queries&quot; section, &quot;Volume...">PxScene.createVolumeCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="30048238aa971768c4bf24c56d186d7c"></a><!-- doxytag: member="PxVolumeCache::setMaxNbDynamicShapes" ref="30048238aa971768c4bf24c56d186d7c" args="(PxU32 maxCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::setMaxNbDynamicShapes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the limit on the maximum number of dynamic shapes allowed to be stored in the cache. 
<p>
If the number of cached objects goes over this limit, the query functions (forEach/raycast/sweep/overlap) will fall back to scene queries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxCount</em>&nbsp;</td><td>Maximum number of dynamic shapes cached. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7c239abc1d93b2dea0cec7ae68d93319"></a><!-- doxytag: member="PxVolumeCache::setMaxNbStaticShapes" ref="7c239abc1d93b2dea0cec7ae68d93319" args="(PxU32 maxCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxVolumeCache::setMaxNbStaticShapes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the limit on the maximum number of static shapes allowed to be stored in the cache. 
<p>
If the number of cached objects goes over this limit, the query functions (forEach/raycast/sweep/overlap) will fall back to scene queries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxCount</em>&nbsp;</td><td>Maximum number of static shapes cached. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86eb361338891b14b27f9d4594b15df8"></a><!-- doxytag: member="PxVolumeCache::sweep" ref="86eb361338891b14b27f9d4594b15df8" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSweepCallback &amp;hitCall, PxHitFlags hitFlags=PxHitFlag::eDEFAULT, const PxQueryFilterData &amp;filterData=PxQueryFilterData(), PxQueryFilterCallback *filterCall=NULL, const PxReal inflation=0.f) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxVolumeCache::sweep           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHitCallback.html">PxSweepCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&nbsp;</td>
          <td class="paramname"> <em>hitFlags</em> = <code>PxHitFlag::eDEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>inflation</em> = <code>0.f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep against objects in the cache, returning results via PxRaycastCallback callback or PxRaycastBuffer object or a custom user callback implementation. 
<p>
Returns whether any rigid actor is hit along the sweep path.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitCall</em>&nbsp;</td><td>Sweep hit callback or hit buffer object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitFlags</em>&nbsp;</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inflation</em>&nbsp;</td><td>This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found or any hit was found in case <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> flag was specified.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g6f93f556cef747d50f643499928dd865" title="Sweep query callback.">PxSweepCallback</a> <a class="el" href="group__scenequery.html#gecfed2b83a930b922b3d95e22ff30665" title="Sweep query buffer.">PxSweepBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structPxSweepHit.html" title="Stores results of sweep queries.">PxSweepHit</a> <a class="el" href="structPxQueryCache.html" title="single hit cache for scene queries.">PxQueryCache</a> PxHitFlags </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxVolumeCache_8h-source.html">PxVolumeCache.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
