<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxShape Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxShape Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxShape" --><!-- doxytag: inherits="PxBase" -->Abstract class for collision shapes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxShape_8h-source.html">PxShape.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxShape:</div>
<div class="dynsection">
<p><center><img src="classPxShape__inherit__graph.png" border="0" usemap="#PxShape__inherit__map" alt="Inheritance graph"></center>
<map name="PxShape__inherit__map">
<area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="11,16,67,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxShape:</div>
<div class="dynsection">
<p><center><img src="classPxShape__coll__graph.png" border="0" usemap="#PxShape__coll__map" alt="Collaboration graph"></center>
<map name="PxShape__coll__map">
<area shape="rect" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection." alt="PxBase" coords="97,106,153,128"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" alt="PxFlags\&lt; PxBaseFlag::Enum, PxU16 \&gt;" coords="7,16,244,37"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxShape-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrements the reference count of a shape and releases it if the new reference count is zero.  <a href="#165dc6eaf5c58997b90b06176220be37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#46a4aa44d34de7625129c5d449c26e5d">acquireReference</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquires a counted reference to a shape.  <a href="#46a4aa44d34de7625129c5d449c26e5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxGeometryType.html#efc79f72c4c479192ac19d41a6f30ed5">PxGeometryType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20">getGeometryType</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the geometry type of the shape.  <a href="#8365c22a5780649bd890703b3ebc1f20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#c6112e8c0ee9803eb3436bbaf673d98a">setGeometry</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the geometry of the shape.  <a href="#c6112e8c0ee9803eb3436bbaf673d98a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#531b866a02c9dc59131bc9887c065ff8">getGeometry</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the geometry from the shape in a <a class="el" href="classPxGeometryHolder.html" title="Geometry holder class.">PxGeometryHolder</a> wrapper class.  <a href="#531b866a02c9dc59131bc9887c065ff8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#e4fe68bfc7be057dae8d0c3eac5a725c">getBoxGeometry</a> (<a class="el" href="classPxBoxGeometry.html">PxBoxGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#e4fe68bfc7be057dae8d0c3eac5a725c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#d36c41170461ca897fa70433d23268fa">getSphereGeometry</a> (<a class="el" href="classPxSphereGeometry.html">PxSphereGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#d36c41170461ca897fa70433d23268fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#8515335ab379ef0709b083ea09ce0a00">getCapsuleGeometry</a> (<a class="el" href="classPxCapsuleGeometry.html">PxCapsuleGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#8515335ab379ef0709b083ea09ce0a00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#fe05ad6f093d762abaf03e3e0c1de704">getPlaneGeometry</a> (<a class="el" href="classPxPlaneGeometry.html">PxPlaneGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#fe05ad6f093d762abaf03e3e0c1de704"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#80bed1030a3740c7d033f65d97ee2ec4">getConvexMeshGeometry</a> (<a class="el" href="classPxConvexMeshGeometry.html">PxConvexMeshGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#80bed1030a3740c7d033f65d97ee2ec4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#e10e641c3e5d77993440abe64c1446ea">getTriangleMeshGeometry</a> (<a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#e10e641c3e5d77993440abe64c1446ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3709d51079c4c809415d31087ebac65b">getHeightFieldGeometry</a> (<a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#3709d51079c4c809415d31087ebac65b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#4b66c8a3e1de304cc0a98df14ac2cdb3">getActor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actor which this shape is associated with.  <a href="#4b66c8a3e1de304cc0a98df14ac2cdb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#14fbf4de00134d17b85194487d68ff30">setMaterials</a> (<a class="el" href="classPxMaterial.html">PxMaterial</a> *const *materials, PxU16 materialCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns material(s) to the shape.  <a href="#14fbf4de00134d17b85194487d68ff30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxU16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#0166cefbe1d120da68db5f68ddd6ebbc">getNbMaterials</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of materials assigned to the shape.  <a href="#0166cefbe1d120da68db5f68ddd6ebbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#dbaf4b32d62babcbab918fc64d4fcae9">getMaterials</a> (<a class="el" href="classPxMaterial.html">PxMaterial</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the material pointers associated with the shape.  <a href="#dbaf4b32d62babcbab918fc64d4fcae9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#77dcd61c00720726ffcce1fe370f0042">getMaterialFromInternalFaceIndex</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> faceIndex) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve material from given triangle index.  <a href="#77dcd61c00720726ffcce1fe370f0042"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#07c638b68e14de5e284a03dbcc128d27">setContactOffset</a> (PxReal contactOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the contact offset.  <a href="#07c638b68e14de5e284a03dbcc128d27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3f0686821f3f8fe92103e31c293f118b">getContactOffset</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the contact offset.  <a href="#3f0686821f3f8fe92103e31c293f118b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#413afb25b39a7a0cf0981aa01c6d7f8b">setRestOffset</a> (PxReal restOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the rest offset.  <a href="#413afb25b39a7a0cf0981aa01c6d7f8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#060ff01d827d559fc8b11385a161eca0">getRestOffset</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the rest offset.  <a href="#060ff01d827d559fc8b11385a161eca0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3c879df184ef40514589c5aa3d1f2a33">setFlag</a> (<a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a">PxShapeFlag::Enum</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets shape flags.  <a href="#3c879df184ef40514589c5aa3d1f2a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#fc179cb4b2146af98c76623d2fc0db6e">setFlags</a> (<a class="el" href="classPxFlags.html">PxShapeFlags</a> inFlags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets shape flags.  <a href="#fc179cb4b2146af98c76623d2fc0db6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#cd44b1c761c14e6319475797ec4f9715">getFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves shape flags.  <a href="#cd44b1c761c14e6319475797ec4f9715"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#9797f4bf85e72881b3cb90d303a22b91">isExclusive</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the shape is exclusive to an actor.  <a href="#9797f4bf85e72881b3cb90d303a22b91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508">setName</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959" title="retrieves the name string set with setName().">getName()</a>.  <a href="#51a289ac174c48ccc8d0b09d3fd90508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959">getName</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieves the name string set with <a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <a href="#800c362a0a6c6c120525876f56378959"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#534106ef0a978dfb710a6b8e7c9443bd">getConcreteTypeName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns string name of dynamic type.  <a href="#534106ef0a978dfb710a6b8e7c9443bd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Pose Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#9f32c7cea3b5701de3f815cd64c978df">setLocalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pose of the shape in actor space, i.e. relative to the actors to which they are attached.  <a href="#9f32c7cea3b5701de3f815cd64c978df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#f455638230d515adbfb561f1064e70a1">getLocalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by.  <a href="#f455638230d515adbfb561f1064e70a1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Filtering</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#a0c62176ed01c9fb14c26ad7c393963c">setSimulationFilterData</a> (const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;data)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the user definable collision filter data.  <a href="#a0c62176ed01c9fb14c26ad7c393963c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#bfa95e009f300060ba648637fb685686">getSimulationFilterData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the shape's collision filter data.  <a href="#bfa95e009f300060ba648637fb685686"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#c98191c26e55ecebfd9eb4553c969fab">setQueryFilterData</a> (const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;data)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the user definable query filter data.  <a href="#c98191c26e55ecebfd9eb4553c969fab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#b6cbdfa3d01aa384f4d0109a591d1f12">getQueryFilterData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the shape's Query filter data.  <a href="#b6cbdfa3d01aa384f4d0109a591d1f12"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#557b80df942f039122b0ee750d29c552">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#557b80df942f039122b0ee750d29c552"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#74ff05bd6c8ac9db9fcae9be23c08d82">PxShape</a> (<a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#a7a1ba5182584faa6bddb15e4b3465c3">PxShape</a> (<a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="classPxFlags.html">PxBaseFlags</a> baseFlags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#7d037f8803d4dff457564e9903452e94">~PxShape</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#1bcf5d308c093487d38bf773f5e3f1c2">isKindOf</a> (const char *name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#1bcf5d308c093487d38bf773f5e3f1c2"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract class for collision shapes. 
<p>
Shapes are shared, reference counted objects.<p>
An instance can be created by calling the createShape() method of the <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> class, or the createShape() method of the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> class.<p>
<h3>Visualizations</h3>
<p>
<ul>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10714f24bab39d1bbe8b131bd10ef5552b" title="Visualize bounds (AABBs in world space).">PxVisualizationParameter::eCOLLISION_AABBS</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10515f4c3c72ee88d7507b52d6ccd14eab" title="Shape visualization.">PxVisualizationParameter::eCOLLISION_SHAPES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb100ad9dcb10f5f3d6ded3baecfc1e387d3" title="Shape axis visualization.">PxVisualizationParameter::eCOLLISION_AXES</a></li>
</ul>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics.createShape()</a> <a class="el" href="classPxRigidActor.html#428112f88e7d3ee8abdf378cb70511f8" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActor.createShape()</a> <a class="el" href="classPxBoxGeometry.html" title="Class representing the geometry of a box.">PxBoxGeometry</a> <a class="el" href="classPxSphereGeometry.html" title="A class representing the geometry of a sphere.">PxSphereGeometry</a> <a class="el" href="classPxCapsuleGeometry.html" title="Class representing the geometry of a capsule.">PxCapsuleGeometry</a> <a class="el" href="classPxPlaneGeometry.html" title="Class describing a plane geometry.">PxPlaneGeometry</a> <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a> <a class="el" href="classPxTriangleMeshGeometry.html" title="Triangle mesh geometry class.">PxTriangleMeshGeometry</a> <a class="el" href="classPxHeightFieldGeometry.html" title="Height field geometry class.">PxHeightFieldGeometry</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="74ff05bd6c8ac9db9fcae9be23c08d82"></a><!-- doxytag: member="PxShape::PxShape" ref="74ff05bd6c8ac9db9fcae9be23c08d82" args="(PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxShape::PxShape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a7a1ba5182584faa6bddb15e4b3465c3"></a><!-- doxytag: member="PxShape::PxShape" ref="a7a1ba5182584faa6bddb15e4b3465c3" args="(PxType concreteType, PxBaseFlags baseFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxShape::PxShape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a>&nbsp;</td>
          <td class="paramname"> <em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxBaseFlags</a>&nbsp;</td>
          <td class="paramname"> <em>baseFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7d037f8803d4dff457564e9903452e94"></a><!-- doxytag: member="PxShape::~PxShape" ref="7d037f8803d4dff457564e9903452e94" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxShape::~PxShape           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="46a4aa44d34de7625129c5d449c26e5d"></a><!-- doxytag: member="PxShape::acquireReference" ref="46a4aa44d34de7625129c5d449c26e5d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::acquireReference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquires a counted reference to a shape. 
<p>
This method increases the reference count of the shape by 1. Decrement the reference count by calling <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Decrements the reference count of a shape and releases it if the new reference count...">release()</a> 
</div>
</div><p>
<a class="anchor" name="4b66c8a3e1de304cc0a98df14ac2cdb3"></a><!-- doxytag: member="PxShape::getActor" ref="4b66c8a3e1de304cc0a98df14ac2cdb3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxRigidActor.html">PxRigidActor</a>* PxShape::getActor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the actor which this shape is associated with. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The actor this shape is associated with, if it is an exclusive shape, else NULL</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a>, <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>, <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e4fe68bfc7be057dae8d0c3eac5a725c"></a><!-- doxytag: member="PxShape::getBoxGeometry" ref="e4fe68bfc7be057dae8d0c3eac5a725c" args="(PxBoxGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getBoxGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxBoxGeometry.html">PxBoxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8515335ab379ef0709b083ea09ce0a00"></a><!-- doxytag: member="PxShape::getCapsuleGeometry" ref="8515335ab379ef0709b083ea09ce0a00" args="(PxCapsuleGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getCapsuleGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxCapsuleGeometry.html">PxCapsuleGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="534106ef0a978dfb710a6b8e7c9443bd"></a><!-- doxytag: member="PxShape::getConcreteTypeName" ref="534106ef0a978dfb710a6b8e7c9443bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxShape::getConcreteTypeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns string name of dynamic type. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Class name of most derived type of this object. </dd></dl>

<p>Implements <a class="el" href="classPxBase.html#67fe206d8897ddce896c371ac8d789a9">PxBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="3f0686821f3f8fe92103e31c293f118b"></a><!-- doxytag: member="PxShape::getContactOffset" ref="3f0686821f3f8fe92103e31c293f118b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxShape::getContactOffset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the contact offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The contact offset of the shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#07c638b68e14de5e284a03dbcc128d27" title="Sets the contact offset.">setContactOffset()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="80bed1030a3740c7d033f65d97ee2ec4"></a><!-- doxytag: member="PxShape::getConvexMeshGeometry" ref="80bed1030a3740c7d033f65d97ee2ec4" args="(PxConvexMeshGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getConvexMeshGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConvexMeshGeometry.html">PxConvexMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd44b1c761c14e6319475797ec4f9715"></a><!-- doxytag: member="PxShape::getFlags" ref="cd44b1c761c14e6319475797ec4f9715" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFlags.html">PxShapeFlags</a> PxShape::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves shape flags. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The values of the shape flags.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#3c879df184ef40514589c5aa3d1f2a33" title="Sets shape flags.">setFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="531b866a02c9dc59131bc9887c065ff8"></a><!-- doxytag: member="PxShape::getGeometry" ref="531b866a02c9dc59131bc9887c065ff8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a> PxShape::getGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the geometry from the shape in a <a class="el" href="classPxGeometryHolder.html" title="Geometry holder class.">PxGeometryHolder</a> wrapper class. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classPxGeometryHolder.html" title="Geometry holder class.">PxGeometryHolder</a> object containing the geometry;</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> <a class="el" href="classPxShape.html#c6112e8c0ee9803eb3436bbaf673d98a" title="Adjust the geometry of the shape.">setGeometry()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxShapeExt_8h-source.html#l00146">PxShapeExt::getWorldBounds()</a>, <a class="el" href="PxShapeExt_8h-source.html#l00104">PxShapeExt::overlap()</a>, <a class="el" href="PxShapeExt_8h-source.html#l00085">PxShapeExt::raycast()</a>, and <a class="el" href="PxShapeExt_8h-source.html#l00127">PxShapeExt::sweep()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8365c22a5780649bd890703b3ebc1f20"></a><!-- doxytag: member="PxShape::getGeometryType" ref="8365c22a5780649bd890703b3ebc1f20" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxGeometryType.html#efc79f72c4c479192ac19d41a6f30ed5">PxGeometryType::Enum</a> PxShape::getGeometryType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the geometry type of the shape. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Type of shape geometry.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3709d51079c4c809415d31087ebac65b"></a><!-- doxytag: member="PxShape::getHeightFieldGeometry" ref="3709d51079c4c809415d31087ebac65b" args="(PxHeightFieldGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getHeightFieldGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f455638230d515adbfb561f1064e70a1"></a><!-- doxytag: member="PxShape::getLocalPose" ref="f455638230d515adbfb561f1064e70a1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxShape::getLocalPose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by. 
<p>
This transformation is identity by default.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pose of shape relative to the actor's frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#9f32c7cea3b5701de3f815cd64c978df" title="Sets the pose of the shape in actor space, i.e. relative to the actors to which they...">setLocalPose()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxShapeExt_8h-source.html#l00065">PxShapeExt::getGlobalPose()</a>.</p>

</div>
</div><p>
<a class="anchor" name="77dcd61c00720726ffcce1fe370f0042"></a><!-- doxytag: member="PxShape::getMaterialFromInternalFaceIndex" ref="77dcd61c00720726ffcce1fe370f0042" args="(PxU32 faceIndex) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a>* PxShape::getMaterialFromInternalFaceIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>faceIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve material from given triangle index. 
<p>
The input index is the internal triangle index as used inside the SDK. This is the index returned to users by various SDK functions such as raycasts.<p>
This function is only useful for triangle meshes or heightfields, which have per-triangle materials. For other shapes the function returns the single material associated with the shape, regardless of the index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>faceIndex</em>&nbsp;</td><td>The internal triangle index whose material you want to retrieve. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Material from input triangle</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If faceIndex value of 0xFFFFffff is passed as an input for mesh and heightfield shapes, this function will issue a warning and return NULL. <p>
Scene queries set the value of <a class="el" href="structPxQueryHit.html#e3462529024eafa98ed2abe1b3b9146c">PxQueryHit::faceIndex</a> to 0xFFFFffff whenever it is undefined or does not apply.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> <a class="el" href="classPxShape.html#0166cefbe1d120da68db5f68ddd6ebbc" title="Returns the number of materials assigned to the shape.">getNbMaterials()</a> <a class="el" href="classPxMaterial.html#c0635989d3c9a12d55d25fe468e91256" title="Decrements the reference count of a material and releases it if the new reference...">PxMaterial::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbaf4b32d62babcbab918fc64d4fcae9"></a><!-- doxytag: member="PxShape::getMaterials" ref="dbaf4b32d62babcbab918fc64d4fcae9" args="(PxMaterial **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxShape::getMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the material pointers associated with the shape. 
<p>
You can retrieve the number of material pointers by calling <a class="el" href="classPxShape.html#0166cefbe1d120da68db5f68ddd6ebbc" title="Returns the number of materials assigned to the shape.">getNbMaterials()</a><p>
Note: Removing materials with <a class="el" href="classPxMaterial.html#c0635989d3c9a12d55d25fe468e91256" title="Decrements the reference count of a material and releases it if the new reference...">PxMaterial::release()</a> will invalidate the pointer of the released material.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the material pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first material pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of material pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> <a class="el" href="classPxShape.html#0166cefbe1d120da68db5f68ddd6ebbc" title="Returns the number of materials assigned to the shape.">getNbMaterials()</a> <a class="el" href="classPxMaterial.html#c0635989d3c9a12d55d25fe468e91256" title="Decrements the reference count of a material and releases it if the new reference...">PxMaterial::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="800c362a0a6c6c120525876f56378959"></a><!-- doxytag: member="PxShape::getName" ref="800c362a0a6c6c120525876f56378959" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxShape::getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
retrieves the name string set with <a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name associated with the shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508" title="Sets a name string for the object that can be retrieved with getName().">setName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0166cefbe1d120da68db5f68ddd6ebbc"></a><!-- doxytag: member="PxShape::getNbMaterials" ref="0166cefbe1d120da68db5f68ddd6ebbc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU16 PxShape::getNbMaterials           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of materials assigned to the shape. 
<p>
You can use <a class="el" href="classPxShape.html#dbaf4b32d62babcbab918fc64d4fcae9" title="Retrieve all the material pointers associated with the shape.">getMaterials()</a> to retrieve the material pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of materials associated with this shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> <a class="el" href="classPxShape.html#dbaf4b32d62babcbab918fc64d4fcae9" title="Retrieve all the material pointers associated with the shape.">getMaterials()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe05ad6f093d762abaf03e3e0c1de704"></a><!-- doxytag: member="PxShape::getPlaneGeometry" ref="fe05ad6f093d762abaf03e3e0c1de704" args="(PxPlaneGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getPlaneGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPlaneGeometry.html">PxPlaneGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6cbdfa3d01aa384f4d0109a591d1f12"></a><!-- doxytag: member="PxShape::getQueryFilterData" ref="b6cbdfa3d01aa384f4d0109a591d1f12" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a> PxShape::getQueryFilterData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the shape's Query filter data. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#c98191c26e55ecebfd9eb4553c969fab" title="Sets the user definable query filter data.">setQueryFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="060ff01d827d559fc8b11385a161eca0"></a><!-- doxytag: member="PxShape::getRestOffset" ref="060ff01d827d559fc8b11385a161eca0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxShape::getRestOffset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the rest offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The rest offset of the shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#413afb25b39a7a0cf0981aa01c6d7f8b" title="Sets the rest offset.">setRestOffset()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfa95e009f300060ba648637fb685686"></a><!-- doxytag: member="PxShape::getSimulationFilterData" ref="bfa95e009f300060ba648637fb685686" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a> PxShape::getSimulationFilterData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the shape's collision filter data. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#a0c62176ed01c9fb14c26ad7c393963c" title="Sets the user definable collision filter data.">setSimulationFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d36c41170461ca897fa70433d23268fa"></a><!-- doxytag: member="PxShape::getSphereGeometry" ref="d36c41170461ca897fa70433d23268fa" args="(PxSphereGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getSphereGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSphereGeometry.html">PxSphereGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e10e641c3e5d77993440abe64c1446ea"></a><!-- doxytag: member="PxShape::getTriangleMeshGeometry" ref="e10e641c3e5d77993440abe64c1446ea" args="(PxTriangleMeshGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getTriangleMeshGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9797f4bf85e72881b3cb90d303a22b91"></a><!-- doxytag: member="PxShape::isExclusive" ref="9797f4bf85e72881b3cb90d303a22b91" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::isExclusive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the shape is exclusive to an actor. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics::createShape()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1bcf5d308c093487d38bf773f5e3f1c2"></a><!-- doxytag: member="PxShape::isKindOf" ref="1bcf5d308c093487d38bf773f5e3f1c2" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>superClass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a given type name matches with the type of this instance. 
<p>

<p>Reimplemented from <a class="el" href="classPxBase.html#ae9d444c7cfd1715a101350a1b1226ef">PxBase</a>.</p>

<p>References <a class="el" href="PxBase_8h-source.html#l00178">PxBase::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="165dc6eaf5c58997b90b06176220be37"></a><!-- doxytag: member="PxShape::release" ref="165dc6eaf5c58997b90b06176220be37" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decrements the reference count of a shape and releases it if the new reference count is zero. 
<p>
Note that in releases prior to PhysX 3.3 this method did not have reference counting semantics and was used to destroy a shape created with PxActor::createShape(). In PhysX 3.3 and above, this usage is deprecated, instead, use <a class="el" href="classPxRigidActor.html#467f9dc1517978b8d517936a475d3c4c">PxRigidActor::detachShape()</a> to detach a shape from an actor. If the shape to be detached was created with PxActor::createShape(), the actor holds the only counted reference, and so when the shape is detached it will also be destroyed.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#428112f88e7d3ee8abdf378cb70511f8" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActor::createShape()</a> <a class="el" href="classPxPhysics.html#bc564607f208cbc1944880172a3d62fe" title="Creates a shape which may be attached to multiple actors.">PxPhysics::createShape()</a> <a class="el" href="classPxRigidActor.html#17c7ab7d692e4b3b8239216aa0d6eeb7">PxRigidActor::attachShape()</a> <a class="el" href="classPxRigidActor.html#467f9dc1517978b8d517936a475d3c4c">PxRigidActor::detachShape()</a> </dd></dl>

<p>Implements <a class="el" href="classPxBase.html#fe6aedda1df0d6d29b1a28213a5ee25a">PxBase</a>.</p>

<p>Referenced by <a class="el" href="PxRigidActorExt_8h-source.html#l00086">PxRigidActorExt::createExclusiveShape()</a>.</p>

</div>
</div><p>
<a class="anchor" name="07c638b68e14de5e284a03dbcc128d27"></a><!-- doxytag: member="PxShape::setContactOffset" ref="07c638b68e14de5e284a03dbcc128d27" args="(PxReal contactOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setContactOffset           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>contactOffset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the contact offset. 
<p>
Shapes whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive and greater than the rest offset. Having a contactOffset greater than than the restOffset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated. This prevents jitter that would occur if the constraint were enforced only when shapes were within the rest distance.<p>
<b>Default:</b> 0.02f * <a class="el" href="classPxTolerancesScale.html#7d93bf20de0e5b54783eda5bb64effeb">PxTolerancesScale::length</a><p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contactOffset</em>&nbsp;</td><td><b>Range:</b> [maximum(0,restOffset), PX_MAX_F32)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#3f0686821f3f8fe92103e31c293f118b" title="Retrieves the contact offset.">getContactOffset</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> <a class="el" href="classPxShape.html#413afb25b39a7a0cf0981aa01c6d7f8b" title="Sets the rest offset.">setRestOffset</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c879df184ef40514589c5aa3d1f2a33"></a><!-- doxytag: member="PxShape::setFlag" ref="3c879df184ef40514589c5aa3d1f2a33" args="(PxShapeFlag::Enum flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a">PxShapeFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets shape flags. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>The shape flag to enable/disable. See <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>True to set the flag. False to clear the flag specified in flag.</td></tr>
  </table>
</dl>
<b>Default:</b> <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a1b3a6f33eb84ee2dc74eac63aa86f2a4" title="Enable debug renderer for this shape.">PxShapeFlag::eVISUALIZATION</a> | <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a> | <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1abc7ec24b00ed57f3914482f0706c6273" title="The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...).">PxShapeFlag::eSCENE_QUERY_SHAPE</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#cd44b1c761c14e6319475797ec4f9715" title="Retrieves shape flags.">getFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc179cb4b2146af98c76623d2fc0db6e"></a><!-- doxytag: member="PxShape::setFlags" ref="fc179cb4b2146af98c76623d2fc0db6e" args="(PxShapeFlags inFlags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>inFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets shape flags. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#cd44b1c761c14e6319475797ec4f9715" title="Retrieves shape flags.">getFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6112e8c0ee9803eb3436bbaf673d98a"></a><!-- doxytag: member="PxShape::setGeometry" ref="c6112e8c0ee9803eb3436bbaf673d98a" args="(const PxGeometry &amp;geometry)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The type of the passed in geometry must match the geometry type of the shape. <p>
It is not allowed to change the geometry type of a shape. <p>
This function does not guarantee correct/continuous behavior when objects are resting on top of old or new geometry.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>New geometry of the shape.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f32c7cea3b5701de3f815cd64c978df"></a><!-- doxytag: member="PxShape::setLocalPose" ref="9f32c7cea3b5701de3f815cd64c978df" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setLocalPose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the pose of the shape in actor space, i.e. relative to the actors to which they are attached. 
<p>
This transformation is identity by default.<p>
The local pose is an attribute of the shape, and so will apply to all actors to which the shape is attached.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<em>Note:</em> Does not automatically update the inertia properties of the owning actor (if applicable); use the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#769be90cdb138897ce426aa04ac0a1e7" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a> to do this.<p>
<b>Default:</b> the identity transform<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>The new transform from the actor frame to the shape frame. <b>Range:</b> rigid body transform</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#f455638230d515adbfb561f1064e70a1" title="Retrieves the pose of the shape in actor space, i.e. relative to the actor they are...">getLocalPose()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="14fbf4de00134d17b85194487d68ff30"></a><!-- doxytag: member="PxShape::setMaterials" ref="14fbf4de00134d17b85194487d68ff30" args="(PxMaterial *const *materials, PxU16 materialCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> *const *&nbsp;</td>
          <td class="paramname"> <em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&nbsp;</td>
          <td class="paramname"> <em>materialCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns material(s) to the shape. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materials</em>&nbsp;</td><td>List of material pointers to assign to the shape. See <a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materialCount</em>&nbsp;</td><td>The number of materials provided.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#35c1965ae47b24e119c6a2d8ce25477e" title="Creates a new material with default properties.">PxPhysics.createMaterial()</a> <a class="el" href="classPxShape.html#dbaf4b32d62babcbab918fc64d4fcae9" title="Retrieve all the material pointers associated with the shape.">getMaterials()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="51a289ac174c48ccc8d0b09d3fd90508"></a><!-- doxytag: member="PxShape::setName" ref="51a289ac174c48ccc8d0b09d3fd90508" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a name string for the object that can be retrieved with <a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959" title="retrieves the name string set with setName().">getName()</a>. 
<p>
This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.<p>
<b>Default:</b> NULL<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name string to set the objects name to.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959" title="retrieves the name string set with setName().">getName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c98191c26e55ecebfd9eb4553c969fab"></a><!-- doxytag: member="PxShape::setQueryFilterData" ref="c98191c26e55ecebfd9eb4553c969fab" args="(const PxFilterData &amp;data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setQueryFilterData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the user definable query filter data. 
<p>
<b>Default:</b> (0,0,0,0)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#b6cbdfa3d01aa384f4d0109a591d1f12" title="Retrieves the shape&#39;s Query filter data.">getQueryFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="413afb25b39a7a0cf0981aa01c6d7f8b"></a><!-- doxytag: member="PxShape::setRestOffset" ref="413afb25b39a7a0cf0981aa01c6d7f8b" args="(PxReal restOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setRestOffset           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>restOffset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the rest offset. 
<p>
Two shapes will come to rest at a distance equal to the sum of their restOffset values. If the restOffset is 0, they should converge to touching exactly. Having a restOffset greater than zero is useful to have objects slide smoothly, so that they do not get hung up on irregularities of each others' surfaces.<p>
<b>Default:</b> 0.0f<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restOffset</em>&nbsp;</td><td><b>Range:</b> (-PX_MAX_F32, contactOffset)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#060ff01d827d559fc8b11385a161eca0" title="Retrieves the rest offset.">getRestOffset</a> <a class="el" href="classPxShape.html#07c638b68e14de5e284a03dbcc128d27" title="Sets the contact offset.">setContactOffset</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0c62176ed01c9fb14c26ad7c393963c"></a><!-- doxytag: member="PxShape::setSimulationFilterData" ref="a0c62176ed01c9fb14c26ad7c393963c" args="(const PxFilterData &amp;data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setSimulationFilterData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the user definable collision filter data. 
<p>
<b>Sleeping:</b> Does wake up the actor if the filter data change causes a formerly suppressed collision pair to be enabled.<p>
<b>Default:</b> (0,0,0,0)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#bfa95e009f300060ba648637fb685686" title="Retrieves the shape&#39;s collision filter data.">getSimulationFilterData()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="557b80df942f039122b0ee750d29c552"></a><!-- doxytag: member="PxShape::userData" ref="557b80df942f039122b0ee750d29c552" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPxShape.html#557b80df942f039122b0ee750d29c552">PxShape::userData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxShape_8h-source.html">PxShape.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
