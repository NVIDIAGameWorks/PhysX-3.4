<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxSceneDesc Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxSceneDesc Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxSceneDesc" -->Descriptor class for scenes. See <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxSceneDesc_8h-source.html">PxSceneDesc.h</a>&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for PxSceneDesc:</div>
<div class="dynsection">
<p><center><img src="classPxSceneDesc__coll__graph.png" border="0" usemap="#PxSceneDesc__coll__map" alt="Collaboration graph"></center>
<map name="PxSceneDesc__coll__map">
<area shape="rect" href="classPxCCDContactModifyCallback.html" title="An interface class that the user can implement in order to modify CCD contact constraints..." alt="PxCCDContactModifyCallback" coords="239,16,423,37"><area shape="rect" href="structPxgDynamicsMemoryConfig.html" title="Sizes of pre-allocated buffers use for GPU dynamics." alt="PxgDynamicsMemoryConfig" coords="245,85,416,107"><area shape="rect" href="classPxSceneLimits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits..." alt="PxSceneLimits" coords="283,155,379,176"><area shape="rect" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box." alt="PxBounds3" coords="292,283,369,304"><area shape="rect" href="classPxVec3.html" title="3 Element vector class." alt="PxVec3" coords="29,253,83,275"><area shape="rect" href="classPxFlags.html" title="Container for bitfield flag variables associated with a specific enum type." alt="PxFlags\&lt; enumtype, storagetype \&gt;" coords="224,352,437,373"><area shape="rect" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints..." alt="PxContactModifyCallback" coords="253,413,408,435"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxSceneFlag::Enum, PxU32 \&gt;" alt="PxFlags\&lt; PxSceneFlag::Enum, PxU32 \&gt;" coords="209,483,452,504"><area shape="rect" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events..." alt="PxSimulationEventCallback" coords="247,552,415,573"><area shape="rect" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs." alt="PxSimulationFilterCallback" coords="249,621,412,643"><area shape="rect" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events." alt="PxBroadPhaseCallback" coords="257,691,404,712"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxSceneDesc-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g8c083fd86a8c52ff269aa4dd3407127b">PxSceneDesc</a> (const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor sets to default.  <a href="group__physics.html#g8c083fd86a8c52ff269aa4dd3407127b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#ga7375184ba494172fa7677dae44bd9a8">setToDefault</a> (const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;scale)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(re)sets the structure to the default.  <a href="group__physics.html#ga7375184ba494172fa7677dae44bd9a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__physics.html#g67b3ce67bea6cdb19619bed61f9e7641">isValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the descriptor is valid.  <a href="group__physics.html#g67b3ce67bea6cdb19619bed61f9e7641"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#9b0de35c38c43b8aeff6e6f29bf0db20">gravity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gravity vector.  <a href="#9b0de35c38c43b8aeff6e6f29bf0db20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941">simulationEventCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possible notification callback.  <a href="#71a00536a56d40fe031de2ced1834941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#2000ccfa6287d160b88967769de34b90">contactModifyCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possible asynchronous callback for contact modification.  <a href="#2000ccfa6287d160b88967769de34b90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ae577616d3e898347924de90e16188bb">ccdContactModifyCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possible asynchronous callback for contact modification.  <a href="#ae577616d3e898347924de90e16188bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2">filterShaderData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shared global filter data which will get passed into the filter shader.  <a href="#d9ceb142127cc259aa2f5d322a1494e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#710c03915bbaaa9bdf23925d535c3883">filterShaderDataSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size (in bytes) of the shared global filter data <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">filterShaderData</a>.  <a href="#710c03915bbaaa9bdf23925d535c3883"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#9410287c6ea926dad9e2b2374541ad38">filterShader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The custom filter shader to use for collision filtering.  <a href="#9410287c6ea926dad9e2b2374541ad38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#f7b94475075eb9b43ca32650cd169cc1">filterCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A custom collision filter callback which can be used to implement more complex filtering operations which need access to the simulation state, for example.  <a href="#f7b94475075eb9b43ca32650cd169cc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxPairFilteringMode.html#eaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#90e220df7cb1f25852d4cc62cecd8869">kineKineFilteringMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filtering mode for kinematic-kinematic pairs in the broadphase.  <a href="#90e220df7cb1f25852d4cc62cecd8869"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxPairFilteringMode.html#eaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#1ff29795e987f8f9b347545468915de2">staticKineFilteringMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filtering mode for static-kinematic pairs in the broadphase.  <a href="#1ff29795e987f8f9b347545468915de2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxBroadPhaseType.html#c7422f895533bff02d0043d35a2b7dda">PxBroadPhaseType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#3c27c85987bc2be98578f0130f455157">broadPhaseType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects the broad-phase algorithm to use.  <a href="#3c27c85987bc2be98578f0130f455157"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#ee15ebe1d7155c19866972ecf5cbdd91">broadPhaseCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broad-phase callback.  <a href="#ee15ebe1d7155c19866972ecf5cbdd91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxSceneLimits.html">PxSceneLimits</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#b996312333ef4fdf5f77fcc16b84923e">limits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expected scene limits.  <a href="#b996312333ef4fdf5f77fcc16b84923e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#b1f18b0666adb645d92fc2f53373b1e9">frictionType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects the friction algorithm to use for simulation.  <a href="#b1f18b0666adb645d92fc2f53373b1e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#bc7769532392c8e47ec4580677145e34">bounceThresholdVelocity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A contact with a relative velocity below this will not bounce. A typical value for simulation. stability is about 0.2 * gravity.  <a href="#bc7769532392c8e47ec4580677145e34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#f707e0c97624aaf6fa9ab2e82aadbecf">frictionOffsetThreshold</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A threshold of contact separation distance used to decide if a contact point will experience friction forces.  <a href="#f707e0c97624aaf6fa9ab2e82aadbecf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#74dc6e8ebde591ca823a3ea4807fca33">ccdMaxSeparation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the two are used to resolve the contacts.  <a href="#74dc6e8ebde591ca823a3ea4807fca33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#91b6c205bf684c0f41432a23c1323ee2">solverOffsetSlop</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slop value used to zero contact offsets from the body's COM on an axis if the offset along that axis is smaller than this threshold. Can be used to compensate for small numerical errors in contact generation.  <a href="#91b6c205bf684c0f41432a23c1323ee2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxFlags.html">PxSceneFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#9510b1233fb0ab03e9c1d5be44ff5a38">flags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags used to select scene options.  <a href="#9510b1233fb0ab03e9c1d5be44ff5a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxCpuDispatcher *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#c74f5f6c12d72b873716f82c2225b725">cpuDispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The CPU task dispatcher for the scene.  <a href="#c74f5f6c12d72b873716f82c2225b725"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxGpuDispatcher *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#e3e78a948f61b9b2d3cd47c62205bccc">gpuDispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GPU task dispatcher for the scene.  <a href="#e3e78a948f61b9b2d3cd47c62205bccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#00495fa3240d1087d38cf33eebc313a7">staticStructure</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines the structure used to store static objects.  <a href="#00495fa3240d1087d38cf33eebc313a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#038ba820b16315ea55c6e12a3cbe2b7f">dynamicStructure</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines the structure used to store dynamic objects.  <a href="#038ba820b16315ea55c6e12a3cbe2b7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3">dynamicTreeRebuildRateHint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hint for how much work should be done per simulation frame to rebuild the pruning structure.  <a href="#c3270ea72968fc446cacb81a7ce683d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#466c85f090678a01f2c6ee85b9584e7a">sceneQueryUpdateMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines the scene query update mode.  <a href="#466c85f090678a01f2c6ee85b9584e7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#63d40516cfbbe7d167d89e6fe55e3834">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will be copied to <a class="el" href="classPxScene.html#64fbe5f25cef90d47fcb1c6428efe15a" title="user can assign this to whatever, usually to create a 1:1 relationship with a user...">PxScene::userData</a>.  <a href="#63d40516cfbbe7d167d89e6fe55e3834"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#26b321b928708c10a047b38ec9127797">solverBatchSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines the number of actors required to spawn a separate rigid body solver island task chain.  <a href="#26b321b928708c10a047b38ec9127797"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83">nbContactDataBlocks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting to define the number of 16K blocks that will be initially reserved to store contact, friction, and contact cache data. This is the number of 16K memory blocks that will be automatically allocated from the user allocator when the scene is instantiated. Further 16k memory blocks may be allocated during the simulation up to maxNbContactDataBlocks.  <a href="#625cdbae7d2149a9df472fb4f9c06f83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35">maxNbContactDataBlocks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting to define the maximum number of 16K blocks that can be allocated to store contact, friction, and contact cache data. As the complexity of a scene increases, the SDK may require to allocate new 16k blocks in addition to the blocks it has already allocated. This variable controls the maximum number of blocks that the SDK can allocate.  <a href="#8791132cbe8cce32f051e5eaab774d35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#65bbe399965691dec83ba3fe1a5082ec">maxBiasCoefficient</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum bias coefficient used in the constraint solver.  <a href="#65bbe399965691dec83ba3fe1a5082ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#02d696140e9828477c8aa493a048f48a">contactReportStreamBufferSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the contact report stream (in bytes).  <a href="#02d696140e9828477c8aa493a048f48a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#65aa4ceefbbd6aebd75ea879d7c385f9">ccdMaxPasses</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of CCD passes.  <a href="#65aa4ceefbbd6aebd75ea879d7c385f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7">wakeCounterResetValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The wake counter reset value.  <a href="#79e2c9c06f711272a48d7f07451117b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPxBounds3.html">PxBounds3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#8d6ba51fe74a6c5ea4a46709abb89168">sanityBounds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bounds used to sanity check user-set positions of actors and articulation links.  <a href="#8d6ba51fe74a6c5ea4a46709abb89168"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPxgDynamicsMemoryConfig.html">PxgDynamicsMemoryConfig</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#b90ebca71afa21639bd99693df30e197">gpuDynamicsConfig</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The pre-allocations performed in the GPU dynamics pipeline.  <a href="#b90ebca71afa21639bd99693df30e197"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#3673610cdfbcb84103e2c3840754ecac">gpuMaxNumPartitions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limitation for the partitions in the GPU dynamics pipeline. This variable must be power of 2. A value greater than 32 is currently not supported. <b>Range:</b> (1, 32)<br>
.  <a href="#3673610cdfbcb84103e2c3840754ecac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxSceneDesc.html#c02177181688e06f18f504e3ba6327a7">gpuComputeVersion</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines which compute version the GPU dynamics should target. DO NOT MODIFY.  <a href="#c02177181688e06f18f504e3ba6327a7"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Descriptor class for scenes. See <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a>. 
<p>
This struct must be initialized with the same <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> values used to initialize <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics.createScene</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> </dd></dl>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="bc7769532392c8e47ec4580677145e34"></a><!-- doxytag: member="PxSceneDesc::bounceThresholdVelocity" ref="bc7769532392c8e47ec4580677145e34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxReal <a class="el" href="classPxSceneDesc.html#bc7769532392c8e47ec4580677145e34">PxSceneDesc::bounceThresholdVelocity</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A contact with a relative velocity below this will not bounce. A typical value for simulation. stability is about 0.2 * gravity. 
<p>
<b>Range:</b> [0, PX_MAX_F32)<br>
 <b>Default:</b> 0.2 * <a class="el" href="classPxTolerancesScale.html#629358a15988697feaa85759d5c57e33">PxTolerancesScale::speed</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html" title="Material class to represent a set of surface properties.">PxMaterial</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ee15ebe1d7155c19866972ecf5cbdd91"></a><!-- doxytag: member="PxSceneDesc::broadPhaseCallback" ref="ee15ebe1d7155c19866972ecf5cbdd91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a>* <a class="el" href="classPxSceneDesc.html#ee15ebe1d7155c19866972ecf5cbdd91">PxSceneDesc::broadPhaseCallback</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Broad-phase callback. 
<p>
This callback will be associated with the client PX_DEFAULT_CLIENT. Please use <a class="el" href="classPxScene.html#c1110386fc2ffad70aa771aabc51d026" title="Sets a broad-phase user callback object.">PxScene::setBroadPhaseCallback()</a> to register callbacks for other clients.<p>
<b>Default:</b> NULL<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c27c85987bc2be98578f0130f455157"></a><!-- doxytag: member="PxSceneDesc::broadPhaseType" ref="3c27c85987bc2be98578f0130f455157" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxBroadPhaseType.html#c7422f895533bff02d0043d35a2b7dda">PxBroadPhaseType::Enum</a> <a class="el" href="classPxSceneDesc.html#3c27c85987bc2be98578f0130f455157">PxSceneDesc::broadPhaseType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selects the broad-phase algorithm to use. 
<p>
<b>Default:</b> <a class="el" href="structPxBroadPhaseType.html#c7422f895533bff02d0043d35a2b7dda33a7598e6dd29fb6a2e905966aba3c25" title="3-axes sweep-and-prune">PxBroadPhaseType::eSAP</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxBroadPhaseType.html" title="Broad phase algorithm used in the simulation.">PxBroadPhaseType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae577616d3e898347924de90e16188bb"></a><!-- doxytag: member="PxSceneDesc::ccdContactModifyCallback" ref="ae577616d3e898347924de90e16188bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a>* <a class="el" href="classPxSceneDesc.html#ae577616d3e898347924de90e16188bb">PxSceneDesc::ccdContactModifyCallback</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Possible asynchronous callback for contact modification. 
<p>
<b>Default:</b> NULL<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">PxScene.setContactModifyCallback()</a> <a class="el" href="classPxScene.html#1978693b355df49712d7e59c10c4115d" title="Retrieves the PxContactModifyCallback pointer set with setContactModifyCallback()...">PxScene.getContactModifyCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="65aa4ceefbbd6aebd75ea879d7c385f9"></a><!-- doxytag: member="PxSceneDesc::ccdMaxPasses" ref="65aa4ceefbbd6aebd75ea879d7c385f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#65aa4ceefbbd6aebd75ea879d7c385f9">PxSceneDesc::ccdMaxPasses</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of CCD passes. 
<p>
The CCD performs multiple passes, where each pass every object advances to its time of first impact. This value defines how many passes the CCD system should perform.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The CCD system is a multi-pass best-effort conservative advancement approach. After the defined number of passes has been completed, any remaining time is dropped. <p>
This defines the maximum number of passes the CCD can perform. It may perform fewer if additional passes are not necessary.</dd></dl>
<b>Default:</b> 1 <b>Range:</b> [1, PX_MAX_U32]<br>
 
</div>
</div><p>
<a class="anchor" name="74dc6e8ebde591ca823a3ea4807fca33"></a><!-- doxytag: member="PxSceneDesc::ccdMaxSeparation" ref="74dc6e8ebde591ca823a3ea4807fca33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxReal <a class="el" href="classPxSceneDesc.html#74dc6e8ebde591ca823a3ea4807fca33">PxSceneDesc::ccdMaxSeparation</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the two are used to resolve the contacts. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This only has any effect on contacting pairs where one of the bodies has <a class="el" href="structPxRigidBodyFlag.html#5fd4878ae66a98c030a9d976e8ba8596f13d6aa80b364fe2cef81a0039e37d45" title="Register a rigid body to dynamicly adjust contact offset based on velocity. This...">PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD</a> raised.</dd></dl>
<b>Range:</b> [0, PX_MAX_F32)<br>
 <b>Default:</b> 0.04 * <a class="el" href="classPxTolerancesScale.html#7d93bf20de0e5b54783eda5bb64effeb">PxTolerancesScale::length</a> 
<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2000ccfa6287d160b88967769de34b90"></a><!-- doxytag: member="PxSceneDesc::contactModifyCallback" ref="2000ccfa6287d160b88967769de34b90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a>* <a class="el" href="classPxSceneDesc.html#2000ccfa6287d160b88967769de34b90">PxSceneDesc::contactModifyCallback</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Possible asynchronous callback for contact modification. 
<p>
<b>Default:</b> NULL<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">PxScene.setContactModifyCallback()</a> <a class="el" href="classPxScene.html#1978693b355df49712d7e59c10c4115d" title="Retrieves the PxContactModifyCallback pointer set with setContactModifyCallback()...">PxScene.getContactModifyCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="02d696140e9828477c8aa493a048f48a"></a><!-- doxytag: member="PxSceneDesc::contactReportStreamBufferSize" ref="02d696140e9828477c8aa493a048f48a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#02d696140e9828477c8aa493a048f48a">PxSceneDesc::contactReportStreamBufferSize</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size of the contact report stream (in bytes). 
<p>
The contact report stream buffer is used during the simulation to store all the contact reports. If the size is not sufficient, the buffer will grow by a factor of two. It is possible to disable the buffer growth by setting the flag <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c538644817a9a2916453433702614672565" title="Disable contact report buffer resize. Once the contact buffer is full, the rest of...">PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE</a>. In that case the buffer will not grow but contact reports not stored in the buffer will not get sent in the contact report callbacks.<p>
<b>Default:</b> 8192<p>
<b>Range:</b> (0, PX_MAX_U32]<br>
 
<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c74f5f6c12d72b873716f82c2225b725"></a><!-- doxytag: member="PxSceneDesc::cpuDispatcher" ref="c74f5f6c12d72b873716f82c2225b725" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxCpuDispatcher* <a class="el" href="classPxSceneDesc.html#c74f5f6c12d72b873716f82c2225b725">PxSceneDesc::cpuDispatcher</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The CPU task dispatcher for the scene. 
<p>
See PxCpuDispatcher, <a class="el" href="classPxScene.html#6329c94cc092aff2193c1307e033f6bf" title="Return the cpu dispatcher that was set in PxSceneDesc::cpuDispatcher when creating...">PxScene::getCpuDispatcher</a> 
<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="038ba820b16315ea55c6e12a3cbe2b7f"></a><!-- doxytag: member="PxSceneDesc::dynamicStructure" ref="038ba820b16315ea55c6e12a3cbe2b7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a> <a class="el" href="classPxSceneDesc.html#038ba820b16315ea55c6e12a3cbe2b7f">PxSceneDesc::dynamicStructure</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the structure used to store dynamic objects. 
<p>

</div>
</div><p>
<a class="anchor" name="c3270ea72968fc446cacb81a7ce683d3"></a><!-- doxytag: member="PxSceneDesc::dynamicTreeRebuildRateHint" ref="c3270ea72968fc446cacb81a7ce683d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3">PxSceneDesc::dynamicTreeRebuildRateHint</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hint for how much work should be done per simulation frame to rebuild the pruning structure. 
<p>
This parameter gives a hint on the distribution of the workload for rebuilding the dynamic AABB tree pruning structure <a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9374d304bffaa55f53556e2b40a592e54" title="Using a dynamic AABB tree.">PxPruningStructureType::eDYNAMIC_AABB_TREE</a>. It specifies the desired number of simulation frames the rebuild process should take. Higher values will decrease the workload per frame but the pruning structure will get more and more outdated the longer the rebuild takes (which can make scene queries less efficient).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only used for <a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9374d304bffaa55f53556e2b40a592e54" title="Using a dynamic AABB tree.">PxPruningStructureType::eDYNAMIC_AABB_TREE</a> pruning structure.<p>
This parameter gives only a hint. The rebuild process might still take more or less time depending on the number of objects involved.</dd></dl>
<b>Range:</b> [4, PX_MAX_U32)<br>
 <b>Default:</b> 100 
<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f7b94475075eb9b43ca32650cd169cc1"></a><!-- doxytag: member="PxSceneDesc::filterCallback" ref="f7b94475075eb9b43ca32650cd169cc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a>* <a class="el" href="classPxSceneDesc.html#f7b94475075eb9b43ca32650cd169cc1">PxSceneDesc::filterCallback</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A custom collision filter callback which can be used to implement more complex filtering operations which need access to the simulation state, for example. 
<p>
<b>Default:</b> NULL<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9410287c6ea926dad9e2b2374541ad38"></a><!-- doxytag: member="PxSceneDesc::filterShader" ref="9410287c6ea926dad9e2b2374541ad38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a> <a class="el" href="classPxSceneDesc.html#9410287c6ea926dad9e2b2374541ad38">PxSceneDesc::filterShader</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The custom filter shader to use for collision filtering. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This parameter is compulsory. If you don't want to define your own filter shader you can use the default shader <a class="el" href="group__extensions.html#g587ba12f90f77543c3e4452abeb0f22f" title="Implementation of a simple filter shader that emulates PhysX 2.8.x filtering.">PxDefaultSimulationFilterShader</a> which can be found in the PhysX extensions library.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d9ceb142127cc259aa2f5d322a1494e2"></a><!-- doxytag: member="PxSceneDesc::filterShaderData" ref="d9ceb142127cc259aa2f5d322a1494e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2">PxSceneDesc::filterShaderData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shared global filter data which will get passed into the filter shader. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The provided data will get copied to internal buffers and this copy will be used for filtering calls.</dd></dl>
<b>Default:</b> NULL<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxScene.html#5ab05d2a2c908d98aed4ca642c5f394d" title="Sets the shared global filter data which will get passed into the filter shader.">PxScene::setFilterShaderData()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="710c03915bbaaa9bdf23925d535c3883"></a><!-- doxytag: member="PxSceneDesc::filterShaderDataSize" ref="710c03915bbaaa9bdf23925d535c3883" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#710c03915bbaaa9bdf23925d535c3883">PxSceneDesc::filterShaderDataSize</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size (in bytes) of the shared global filter data <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">filterShaderData</a>. 
<p>
<b>Default:</b> 0<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">filterShaderData</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9510b1233fb0ab03e9c1d5be44ff5a38"></a><!-- doxytag: member="PxSceneDesc::flags" ref="9510b1233fb0ab03e9c1d5be44ff5a38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxFlags.html">PxSceneFlags</a> <a class="el" href="classPxSceneDesc.html#9510b1233fb0ab03e9c1d5be44ff5a38">PxSceneDesc::flags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags used to select scene options. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> <a class="el" href="group__physics.html#g54a626a9a6d80543048bffc654814704" title="collection of set bits defined in PxSceneFlag.">PxSceneFlags</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f707e0c97624aaf6fa9ab2e82aadbecf"></a><!-- doxytag: member="PxSceneDesc::frictionOffsetThreshold" ref="f707e0c97624aaf6fa9ab2e82aadbecf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxReal <a class="el" href="classPxSceneDesc.html#f707e0c97624aaf6fa9ab2e82aadbecf">PxSceneDesc::frictionOffsetThreshold</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A threshold of contact separation distance used to decide if a contact point will experience friction forces. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the separation distance of a contact point is greater than the threshold then the contact point will not experience friction forces.<p>
If the aggregated contact offset of a pair of shapes is large it might be desirable to neglect friction for contact points whose separation distance is sufficiently large that the shape surfaces are clearly separated.<p>
This parameter can be used to tune the separation distance of contact points at which friction starts to have an effect.</dd></dl>
<b>Range:</b> [0, PX_MAX_F32)<br>
 <b>Default:</b> 0.04 * <a class="el" href="classPxTolerancesScale.html#7d93bf20de0e5b54783eda5bb64effeb">PxTolerancesScale::length</a> 
<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b1f18b0666adb645d92fc2f53373b1e9"></a><!-- doxytag: member="PxSceneDesc::frictionType" ref="b1f18b0666adb645d92fc2f53373b1e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a> <a class="el" href="classPxSceneDesc.html#b1f18b0666adb645d92fc2f53373b1e9">PxSceneDesc::frictionType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selects the friction algorithm to use for simulation. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>frictionType cannot be modified after the first call to any of <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">PxScene::simulate</a>, PxScene::solve and <a class="el" href="classPxScene.html#17c3863f711ef79c08c6054b69fd430c" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxFrictionType.html" title="Enum for selecting the friction algorithm used for simulation.">PxFrictionType</a> <b>Default:</b> <a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96bcf891c8b96deb40e1e475237fe4f4047" title="Select default patch-friction model.">PxFrictionType::ePATCH</a><p>
<a class="el" href="classPxScene.html#9ff7784b4d51acf2d56b9462e256b58b" title="Set the friction model.">PxScene::setFrictionType</a>, <a class="el" href="classPxScene.html#aca4a2838bc3bf7ffece380c8c7f0f4e" title="Return the friction model.">PxScene::getFrictionType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c02177181688e06f18f504e3ba6327a7"></a><!-- doxytag: member="PxSceneDesc::gpuComputeVersion" ref="c02177181688e06f18f504e3ba6327a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#c02177181688e06f18f504e3ba6327a7">PxSceneDesc::gpuComputeVersion</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines which compute version the GPU dynamics should target. DO NOT MODIFY. 
<p>

</div>
</div><p>
<a class="anchor" name="e3e78a948f61b9b2d3cd47c62205bccc"></a><!-- doxytag: member="PxSceneDesc::gpuDispatcher" ref="e3e78a948f61b9b2d3cd47c62205bccc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxGpuDispatcher* <a class="el" href="classPxSceneDesc.html#e3e78a948f61b9b2d3cd47c62205bccc">PxSceneDesc::gpuDispatcher</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The GPU task dispatcher for the scene. 
<p>
<b>Platform specific:</b> Applies to PC GPU only.<p>
See PxGpuDispatcher, <a class="el" href="classPxScene.html#256ac6d74578418c446fc5fe1fe95170" title="Return the gpu dispatcher that was set in PxSceneDesc::gpuDispatcher when creating...">PxScene::getGpuDispatcher</a> 
</div>
</div><p>
<a class="anchor" name="b90ebca71afa21639bd99693df30e197"></a><!-- doxytag: member="PxSceneDesc::gpuDynamicsConfig" ref="b90ebca71afa21639bd99693df30e197" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxgDynamicsMemoryConfig.html">PxgDynamicsMemoryConfig</a> <a class="el" href="classPxSceneDesc.html#b90ebca71afa21639bd99693df30e197">PxSceneDesc::gpuDynamicsConfig</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The pre-allocations performed in the GPU dynamics pipeline. 
<p>

</div>
</div><p>
<a class="anchor" name="3673610cdfbcb84103e2c3840754ecac"></a><!-- doxytag: member="PxSceneDesc::gpuMaxNumPartitions" ref="3673610cdfbcb84103e2c3840754ecac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#3673610cdfbcb84103e2c3840754ecac">PxSceneDesc::gpuMaxNumPartitions</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limitation for the partitions in the GPU dynamics pipeline. This variable must be power of 2. A value greater than 32 is currently not supported. <b>Range:</b> (1, 32)<br>
. 
<p>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b0de35c38c43b8aeff6e6f29bf0db20"></a><!-- doxytag: member="PxSceneDesc::gravity" ref="9b0de35c38c43b8aeff6e6f29bf0db20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxVec3.html">PxVec3</a> <a class="el" href="classPxSceneDesc.html#9b0de35c38c43b8aeff6e6f29bf0db20">PxSceneDesc::gravity</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gravity vector. 
<p>
<b>Range:</b> force vector<br>
 <b>Default:</b> Zero<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#575ed34c73adbd61892d728a688479f3" title="Sets a constant gravity for the entire scene.">PxScene.setGravity()</a></dd></dl>
When setting gravity, you should probably also set bounce threshold. 
</div>
</div><p>
<a class="anchor" name="90e220df7cb1f25852d4cc62cecd8869"></a><!-- doxytag: member="PxSceneDesc::kineKineFilteringMode" ref="90e220df7cb1f25852d4cc62cecd8869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxPairFilteringMode.html#eaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a> <a class="el" href="classPxSceneDesc.html#90e220df7cb1f25852d4cc62cecd8869">PxSceneDesc::kineKineFilteringMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Filtering mode for kinematic-kinematic pairs in the broadphase. 
<p>
<b>Default:</b> <a class="el" href="structPxPairFilteringMode.html#eaa62ad327b874e4b199022401bf7615464ca27835cd3bfe25854b99b6940c71">PxPairFilteringMode::eDEFAULT</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxPairFilteringMode.html">PxPairFilteringMode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b996312333ef4fdf5f77fcc16b84923e"></a><!-- doxytag: member="PxSceneDesc::limits" ref="b996312333ef4fdf5f77fcc16b84923e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSceneLimits.html">PxSceneLimits</a> <a class="el" href="classPxSceneDesc.html#b996312333ef4fdf5f77fcc16b84923e">PxSceneDesc::limits</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expected scene limits. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneLimits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits...">PxSceneLimits</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="65bbe399965691dec83ba3fe1a5082ec"></a><!-- doxytag: member="PxSceneDesc::maxBiasCoefficient" ref="65bbe399965691dec83ba3fe1a5082ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxReal <a class="el" href="classPxSceneDesc.html#65bbe399965691dec83ba3fe1a5082ec">PxSceneDesc::maxBiasCoefficient</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The maximum bias coefficient used in the constraint solver. 
<p>
When geometric errors are found in the constraint solver, either as a result of shapes penetrating or joints becoming separated or violating limits, a bias is introduced in the solver position iterations to correct these errors. This bias is proportional to 1/dt, meaning that the bias becomes increasingly strong as the time-step passed to <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">PxScene::simulate</a>(...) becomes smaller. This coefficient allows the application to restrict how large the bias coefficient is, to reduce how violent error corrections are. This can improve simulation quality in cases where either variable time-steps or extremely small time-steps are used.<p>
<b>Default:</b> PX_MAX_F32<p>
<b> Range</b> [0, PX_MAX_F32] <br>
 
</div>
</div><p>
<a class="anchor" name="8791132cbe8cce32f051e5eaab774d35"></a><!-- doxytag: member="PxSceneDesc::maxNbContactDataBlocks" ref="8791132cbe8cce32f051e5eaab774d35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35">PxSceneDesc::maxNbContactDataBlocks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting to define the maximum number of 16K blocks that can be allocated to store contact, friction, and contact cache data. As the complexity of a scene increases, the SDK may require to allocate new 16k blocks in addition to the blocks it has already allocated. This variable controls the maximum number of blocks that the SDK can allocate. 
<p>
In the case that the scene is sufficiently complex that all the permitted 16K blocks are used, contacts will be dropped and a warning passed to the error stream.<p>
If a warning is reported to the error stream to indicate the number of 16K blocks is insufficient for the scene complexity then the choices are either (i) re-tune the number of 16K data blocks until a number is found that is sufficient for the scene complexity, (ii) to simplify the scene or (iii) to opt to not increase the memory requirements of <a class="el" href="namespacephysx.html">physx</a> and accept some dropped contacts.<p>
<b>Default:</b> 65536<p>
<b>Range:</b> [0, PX_MAX_U32]<br>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to define the number of 16K blocks that will be initially reserved to store...">nbContactDataBlocks</a> <a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate().">PxScene::setNbContactDataBlocks</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="625cdbae7d2149a9df472fb4f9c06f83"></a><!-- doxytag: member="PxSceneDesc::nbContactDataBlocks" ref="625cdbae7d2149a9df472fb4f9c06f83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83">PxSceneDesc::nbContactDataBlocks</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting to define the number of 16K blocks that will be initially reserved to store contact, friction, and contact cache data. This is the number of 16K memory blocks that will be automatically allocated from the user allocator when the scene is instantiated. Further 16k memory blocks may be allocated during the simulation up to maxNbContactDataBlocks. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This value cannot be larger than maxNbContactDataBlocks because that defines the maximum number of 16k blocks that can be allocated by the SDK.</dd></dl>
<b>Default:</b> 0<p>
<b>Range:</b> [0, PX_MAX_U32]<br>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> <a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate().">PxScene::setNbContactDataBlocks</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8d6ba51fe74a6c5ea4a46709abb89168"></a><!-- doxytag: member="PxSceneDesc::sanityBounds" ref="8d6ba51fe74a6c5ea4a46709abb89168" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxBounds3.html">PxBounds3</a> <a class="el" href="classPxSceneDesc.html#8d6ba51fe74a6c5ea4a46709abb89168">PxSceneDesc::sanityBounds</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bounds used to sanity check user-set positions of actors and articulation links. 
<p>
These bounds are used to check the position values of rigid actors inserted into the scene, and positions set for rigid actors already within the scene.<p>
<b>Range:</b> any valid <a class="el" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box.">PxBounds3</a> <br>
 <b>Default:</b> (-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS) on each axis 
<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="466c85f090678a01f2c6ee85b9584e7a"></a><!-- doxytag: member="PxSceneDesc::sceneQueryUpdateMode" ref="466c85f090678a01f2c6ee85b9584e7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a> <a class="el" href="classPxSceneDesc.html#466c85f090678a01f2c6ee85b9584e7a">PxSceneDesc::sceneQueryUpdateMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the scene query update mode. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Setting a value other than the default will result in ignoring the deprecated PxSceneFlag::eSUPPRESS_EAGER_SCENE_QUERY_REFIT</dd></dl>
<b>Default:</b> <a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4a9f1900ad863b24a136a6bf7061718e5" title="Both scene query build and commit are executed.">PxSceneQueryUpdateMode::eBUILD_ENABLED_COMMIT_ENABLED</a> 
</div>
</div><p>
<a class="anchor" name="71a00536a56d40fe031de2ced1834941"></a><!-- doxytag: member="PxSceneDesc::simulationEventCallback" ref="71a00536a56d40fe031de2ced1834941" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a>* <a class="el" href="classPxSceneDesc.html#71a00536a56d40fe031de2ced1834941">PxSceneDesc::simulationEventCallback</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Possible notification callback. 
<p>
This callback will be associated with the client PX_DEFAULT_CLIENT. Please use <a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene::setSimulationEventCallback()</a> to register callbacks for other clients.<p>
<b>Default:</b> NULL<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> <a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">PxScene.setSimulationEventCallback()</a> <a class="el" href="classPxScene.html#1eb6366fd80f5a8f6a9154a412c33436" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback()...">PxScene.getSimulationEventCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="26b321b928708c10a047b38ec9127797"></a><!-- doxytag: member="PxSceneDesc::solverBatchSize" ref="26b321b928708c10a047b38ec9127797" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> <a class="el" href="classPxSceneDesc.html#26b321b928708c10a047b38ec9127797">PxSceneDesc::solverBatchSize</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the number of actors required to spawn a separate rigid body solver island task chain. 
<p>
This parameter defines the minimum number of actors required to spawn a separate rigid body solver task chain. Setting a low value will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor. Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the maximum number of solver iterations requested by any body in the island.<p>
<b>Default:</b> 128<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#ad9cc8bf329f4de4b407436f5cd38c98" title="Sets the number of actors required to spawn a separate rigid body solver thread.">PxScene.setSolverBatchSize()</a> <a class="el" href="classPxScene.html#dd966317a1feb083e273fd8c12f454b5" title="Retrieves the number of actors required to spawn a separate rigid body solver thread...">PxScene.getSolverBatchSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="91b6c205bf684c0f41432a23c1323ee2"></a><!-- doxytag: member="PxSceneDesc::solverOffsetSlop" ref="91b6c205bf684c0f41432a23c1323ee2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxReal <a class="el" href="classPxSceneDesc.html#91b6c205bf684c0f41432a23c1323ee2">PxSceneDesc::solverOffsetSlop</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A slop value used to zero contact offsets from the body's COM on an axis if the offset along that axis is smaller than this threshold. Can be used to compensate for small numerical errors in contact generation. 
<p>
<b>Range:</b> [0, PX_MAX_F32)<br>
 <b>Default:</b> 0.0 
</div>
</div><p>
<a class="anchor" name="1ff29795e987f8f9b347545468915de2"></a><!-- doxytag: member="PxSceneDesc::staticKineFilteringMode" ref="1ff29795e987f8f9b347545468915de2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxPairFilteringMode.html#eaa62ad327b874e4b199022401bf7615">PxPairFilteringMode::Enum</a> <a class="el" href="classPxSceneDesc.html#1ff29795e987f8f9b347545468915de2">PxSceneDesc::staticKineFilteringMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Filtering mode for static-kinematic pairs in the broadphase. 
<p>
<b>Default:</b> <a class="el" href="structPxPairFilteringMode.html#eaa62ad327b874e4b199022401bf7615464ca27835cd3bfe25854b99b6940c71">PxPairFilteringMode::eDEFAULT</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxPairFilteringMode.html">PxPairFilteringMode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="00495fa3240d1087d38cf33eebc313a7"></a><!-- doxytag: member="PxSceneDesc::staticStructure" ref="00495fa3240d1087d38cf33eebc313a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a> <a class="el" href="classPxSceneDesc.html#00495fa3240d1087d38cf33eebc313a7">PxSceneDesc::staticStructure</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the structure used to store static objects. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only <a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d99001cb07511fa509eae16a4a933a77f6" title="Using a static AABB tree.">PxPruningStructureType::eSTATIC_AABB_TREE</a> and <a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9374d304bffaa55f53556e2b40a592e54" title="Using a dynamic AABB tree.">PxPruningStructureType::eDYNAMIC_AABB_TREE</a> are allowed here. </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<a class="anchor" name="63d40516cfbbe7d167d89e6fe55e3834"></a><!-- doxytag: member="PxSceneDesc::userData" ref="63d40516cfbbe7d167d89e6fe55e3834" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPxSceneDesc.html#63d40516cfbbe7d167d89e6fe55e3834">PxSceneDesc::userData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Will be copied to <a class="el" href="classPxScene.html#64fbe5f25cef90d47fcb1c6428efe15a" title="user can assign this to whatever, usually to create a 1:1 relationship with a user...">PxScene::userData</a>. 
<p>
<b>Default:</b> NULL 
</div>
</div><p>
<a class="anchor" name="79e2c9c06f711272a48d7f07451117b7"></a><!-- doxytag: member="PxSceneDesc::wakeCounterResetValue" ref="79e2c9c06f711272a48d7f07451117b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxReal <a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7">PxSceneDesc::wakeCounterResetValue</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The wake counter reset value. 
<p>
Calling wakeUp() on objects which support sleeping will set their wake counter value to the specified reset value.<p>
<b>Range:</b> (0, PX_MAX_F32)<br>
 <b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html#4f1b9e9f437d8b8f27a6e9c2d9ea22fd" title="Wakes up the actor if it is sleeping.">PxRigidDynamic::wakeUp()</a> <a class="el" href="classPxArticulation.html#596fb9e8f1d136d571965583bc5d0d1b" title="Wakes up the articulation if it is sleeping.">PxArticulation::wakeUp()</a> <a class="el" href="classPxCloth.html#b5092893f40cf8d9399b467f59f893de" title="Forces cloth to wake up from sleep state.">PxCloth::wakeUp()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxSceneDesc_8h-source.html#l01010">isValid()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxSceneDesc_8h-source.html">PxSceneDesc.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
