<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxScene Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxScene Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxScene" -->A scene is a collection of bodies, particle systems and constraints which can interact.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxScene_8h-source.html">PxScene.h</a>&gt;</code>
<p>

<p>
<a href="classPxScene-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#287734b244b7ff6e40496e65d166ae95">getWakeCounterResetValue</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wake counter reset value.  <a href="#287734b244b7ff6e40496e65d166ae95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#3cb2b6b3b72cefb94fa9e64ca09660f6">shiftOrigin</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;shift)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the scene origin by the specified vector.  <a href="#3cb2b6b3b72cefb94fa9e64ca09660f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxPvdSceneClient.html">PxPvdSceneClient</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ac4ee13053cdb7f50ca6c065077c9ee3">getScenePvdClient</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Pvd client associated with the scene.  <a href="#ac4ee13053cdb7f50ca6c065077c9ee3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Add/Remove Contained Objects</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#be7b1220a8798cc9b0ca58fb074141fb">addArticulation</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;articulation)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an articulation to this scene.  <a href="#be7b1220a8798cc9b0ca58fb074141fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#50992e7d29c92240d2b22ac4fe31b090">removeArticulation</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;articulation, bool wakeOnLostTouch=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an articulation from this scene.  <a href="#50992e7d29c92240d2b22ac4fe31b090"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#dd384929e3a8a81881f7e616c7a0539b">addActor</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an actor to this scene.  <a href="#dd384929e3a8a81881f7e616c7a0539b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#caae28f21ccf233d0a9c0ad17a1ff5bd">addActors</a> (<a class="el" href="classPxActor.html">PxActor</a> *const *actors, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbActors)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds actors to this scene.  <a href="#caae28f21ccf233d0a9c0ad17a1ff5bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6a5610ee50faad60924a332ff4559321">addActors</a> (const <a class="el" href="classPxPruningStructure.html">PxPruningStructure</a> &amp;pruningStructure)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a pruning structure together with its actors to this scene.  <a href="#6a5610ee50faad60924a332ff4559321"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6ba76326fc73e3c5b0361568caec9267">removeActor</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor, bool wakeOnLostTouch=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an actor from this scene.  <a href="#6ba76326fc73e3c5b0361568caec9267"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#58d87bb19d1a3497bb2ca96eee2b2480">removeActors</a> (<a class="el" href="classPxActor.html">PxActor</a> *const *actors, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbActors, bool wakeOnLostTouch=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes actors from this scene.  <a href="#58d87bb19d1a3497bb2ca96eee2b2480"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7e1a5eaea13e5f97415dd14690e7ce38">addAggregate</a> (<a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;aggregate)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an aggregate to this scene.  <a href="#7e1a5eaea13e5f97415dd14690e7ce38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#bd705ae117336d9d56efcc8717c3f89b">removeAggregate</a> (<a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;aggregate, bool wakeOnLostTouch=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an aggregate from this scene.  <a href="#bd705ae117336d9d56efcc8717c3f89b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6b61683d8acb5e73b2ffb41ebecae589">addCollection</a> (const <a class="el" href="classPxCollection.html">PxCollection</a> &amp;collection)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds objects in the collection to this scene.  <a href="#6b61683d8acb5e73b2ffb41ebecae589"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Contained Object Retrieval</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#f44b7f47e3d9332a2fcade3e3f766a5d">getNbActors</a> (<a class="el" href="classPxFlags.html">PxActorTypeFlags</a> types) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the number of actors of certain types in the scene.  <a href="#f44b7f47e3d9332a2fcade3e3f766a5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#e2ad69311278772a479950d0c73f0b75">getActors</a> (<a class="el" href="classPxFlags.html">PxActorTypeFlags</a> types, <a class="el" href="classPxActor.html">PxActor</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an array of all the actors of certain types in the scene.  <a href="#e2ad69311278772a479950d0c73f0b75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED const <br class="typebreak">
<a class="el" href="structPxActiveTransform.html">PxActiveTransform</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#5fdec7976b853ad4af5573bb13197426">getActiveTransforms</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbTransformsOut, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step.  <a href="#5fdec7976b853ad4af5573bb13197426"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#c556f41a6fb051bae49765e3cbdbe3f8">getActiveActors</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbActorsOut, PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step.  <a href="#c556f41a6fb051bae49765e3cbdbe3f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b09a3fad6a720283c0a95fe7f76973e4">getNbArticulations</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of articulations in the scene.  <a href="#b09a3fad6a720283c0a95fe7f76973e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#eca9cb7d9353559e214a51a599e28a85">getArticulations</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the articulations in the scene.  <a href="#eca9cb7d9353559e214a51a599e28a85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7ee023de370ac90a7d4c204d916d3080">getNbConstraints</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of constraint shaders in the scene.  <a href="#7ee023de370ac90a7d4c204d916d3080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1e9919abdfb23495a84f47c5157a67b1">getConstraints</a> (<a class="el" href="classPxConstraint.html">PxConstraint</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the constraint shaders in the scene.  <a href="#1e9919abdfb23495a84f47c5157a67b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a95c08ef234a55388b297ec657487b69">getNbAggregates</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of aggregates in the scene.  <a href="#a95c08ef234a55388b297ec657487b69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#f25335de0c6012d9a5d7e78c8272824e">getAggregates</a> (<a class="el" href="classPxAggregate.html">PxAggregate</a> **userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the aggregates in the scene.  <a href="#f25335de0c6012d9a5d7e78c8272824e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dominance</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b6d9e986e6af967d2bd60a63a0b550c4">setDominanceGroupPair</a> (<a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group1, <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group2, const <a class="el" href="structPxDominanceGroupPair.html">PxDominanceGroupPair</a> &amp;dominance)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the dominance behavior of contacts between two actors with two certain dominance groups.  <a href="#b6d9e986e6af967d2bd60a63a0b550c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxDominanceGroupPair.html">PxDominanceGroupPair</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#951ada59fff16e5c860ccdd5f6d5a1f3">getDominanceGroupPair</a> (<a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group1, <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group2) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Samples the dominance matrix.  <a href="#951ada59fff16e5c860ccdd5f6d5a1f3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dispatcher</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxCpuDispatcher *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6329c94cc092aff2193c1307e033f6bf">getCpuDispatcher</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the cpu dispatcher that was set in <a class="el" href="classPxSceneDesc.html#c74f5f6c12d72b873716f82c2225b725" title="The CPU task dispatcher for the scene.">PxSceneDesc::cpuDispatcher</a> when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>.  <a href="#6329c94cc092aff2193c1307e033f6bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxGpuDispatcher *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#256ac6d74578418c446fc5fe1fe95170">getGpuDispatcher</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the gpu dispatcher that was set in <a class="el" href="classPxSceneDesc.html#e3e78a948f61b9b2d3cd47c62205bccc" title="The GPU task dispatcher for the scene.">PxSceneDesc::gpuDispatcher</a> when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>.  <a href="#256ac6d74578418c446fc5fe1fe95170"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiclient</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a">createClient</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserves a new client ID.  <a href="#285849425521dd0344f55b4a7c0a834a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6f61e48083f63f6fac343a3b1d8b2ddc">setClientBehaviorFlags</a> (<a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client, <a class="el" href="PxClient_8h.html#295b321eb41489154df2d9dd381282d1">PxClientBehaviorFlags</a> clientBehaviorFlags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets behavior bits for a client.  <a href="#6f61e48083f63f6fac343a3b1d8b2ddc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="PxClient_8h.html#295b321eb41489154df2d9dd381282d1">PxClientBehaviorFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#8259c90c79fb69ee62e9434eb35e0f37">getClientBehaviorFlags</a> (<a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves behavior bits for a client.  <a href="#8259c90c79fb69ee62e9434eb35e0f37"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloth</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b42513ab6ce4137698565ca8629eea1c">setClothInterCollisionDistance</a> (PxF32 distance)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the minimum separation distance for cloth inter-collision.  <a href="#b42513ab6ce4137698565ca8629eea1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED PxF32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b31964586c71755fb261a879435655fb">getClothInterCollisionDistance</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves distance used for cloth inter-collision.  <a href="#b31964586c71755fb261a879435655fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#85444db1420db29be5c0b748197b4fed">setClothInterCollisionStiffness</a> (PxF32 stiffness)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the cloth inter-collision stiffness.  <a href="#85444db1420db29be5c0b748197b4fed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED PxF32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#3f8880466c56bedbc2cd9f96f24e8331">getClothInterCollisionStiffness</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the stiffness coefficient used for cloth inter-collision.  <a href="#3f8880466c56bedbc2cd9f96f24e8331"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7197a1ce70671bfc81e6f3088920ac16">setClothInterCollisionNbIterations</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> nbIterations)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of inter-collision separation iterations to perform.  <a href="#7197a1ce70671bfc81e6f3088920ac16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#605049c3cc13532d47803ba5303ce326">getClothInterCollisionNbIterations</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of iterations used for cloth inter-collision.  <a href="#605049c3cc13532d47803ba5303ce326"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Callbacks</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31">setSimulationEventCallback</a> (<a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *callback, PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <a href="#88f5438bf61cf5c3f767d8b515c51d31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1eb6366fd80f5a8f6a9154a412c33436">getSimulationEventCallback</a> (PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the simulationEventCallback pointer set with <a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">setSimulationEventCallback()</a>.  <a href="#1eb6366fd80f5a8f6a9154a412c33436"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e">setContactModifyCallback</a> (<a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user callback object, which receives callbacks on all contacts generated for specified actors.  <a href="#eec3367a4461c1ab2e552acdb8c0609e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#593d339e0fd64e47fa3b68016ce723ec">setCCDContactModifyCallback</a> (<a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user callback object, which receives callbacks on all CCD contacts generated for specified actors.  <a href="#593d339e0fd64e47fa3b68016ce723ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1978693b355df49712d7e59c10c4115d">getContactModifyCallback</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> pointer set with <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a>.  <a href="#1978693b355df49712d7e59c10c4115d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#952ff4e7b46ff4d3396195e65cd494e6">getCCDContactModifyCallback</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classPxCCDContactModifyCallback.html" title="An interface class that the user can implement in order to modify CCD contact constraints...">PxCCDContactModifyCallback</a> pointer set with <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a>.  <a href="#952ff4e7b46ff4d3396195e65cd494e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#c1110386fc2ffad70aa771aabc51d026">setBroadPhaseCallback</a> (<a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a> *callback, PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a broad-phase user callback object.  <a href="#c1110386fc2ffad70aa771aabc51d026"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#3823d25fc80ebe53c1c02cef57115b06">getBroadPhaseCallback</a> (PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> pointer set with <a class="el" href="classPxScene.html#c1110386fc2ffad70aa771aabc51d026" title="Sets a broad-phase user callback object.">setBroadPhaseCallback()</a>.  <a href="#3823d25fc80ebe53c1c02cef57115b06"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Filtering</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#5ab05d2a2c908d98aed4ca642c5f394d">setFilterShaderData</a> (const void *data, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> dataSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the shared global filter data which will get passed into the filter shader.  <a href="#5ab05d2a2c908d98aed4ca642c5f394d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#5d004fdc88ed31447aa57ee4f98c14ea">getFilterShaderData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the shared global filter data in use for this scene.  <a href="#5d004fdc88ed31447aa57ee4f98c14ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ce291f68b365a4f1aaa291ba940eff9a">getFilterShaderDataSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>).  <a href="#ce291f68b365a4f1aaa291ba940eff9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a3f57314433de21448966c1d9004d71a">getFilterShader</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the custom collision filter shader in use for this scene.  <a href="#a3f57314433de21448966c1d9004d71a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#2b4c17b1a16df239e5d6a2e0e6f8b633">getFilterCallback</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the custom collision filter callback in use for this scene.  <a href="#2b4c17b1a16df239e5d6a2e0e6f8b633"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#f648aa06d19cfec20eeee278719f345c">resetFiltering</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the object to reset interactions and re-run collision filters in the next simulation step.  <a href="#f648aa06d19cfec20eeee278719f345c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ae469799c2e23d06ce5c1079e36df953">resetFiltering</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;actor, <a class="el" href="classPxShape.html">PxShape</a> *const *shapes, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> shapeCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the object to reset interactions and re-run collision filters for specified shapes in the next simulation step.  <a href="#ae469799c2e23d06ce5c1079e36df953"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Simulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5">simulate</a> (PxReal elapsedTime, <a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *completionTask=NULL, void *scratchMemBlock=0, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> scratchMemBlockSize=0, bool controlSimulation=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the simulation by an elapsedTime time.  <a href="#9a9cacecc3b0f6adaf2f3d2168c2aff5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#dc85aa20552a55905aa1329722a555d7">advance</a> (<a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *completionTask=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs dynamics phase of the simulation pipeline.  <a href="#dc85aa20552a55905aa1329722a555d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#17c3863f711ef79c08c6054b69fd430c">collide</a> (PxReal elapsedTime, <a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *completionTask=0, void *scratchMemBlock=0, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> scratchMemBlockSize=0, bool controlSimulation=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs collision detection for the scene over elapsedTime.  <a href="#17c3863f711ef79c08c6054b69fd430c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5">checkResults</a> (bool block=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This checks to see if the simulation run has completed.  <a href="#6f45a8ee04f0bcd2c23b23daa176bee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#c320cd782704022cc044a1ef4b0c582f">fetchCollision</a> (bool block=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults</a> (bool block=false, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *errorState=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#e5515efb07a300166c0d47adce6acd6f">fetchResultsStart</a> (const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> *&amp;contactPairs, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;nbContactPairs, bool block=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#9f212d5f07851efca3731594eccbccfd">processCallbacks</a> (<a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *continuation)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#9e70b9f9ac942c0b90b2b78d45b99708">fetchResultsFinish</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *errorState=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b557fc677e9549c71d36979dfd3ec8c5">flushSimulation</a> (bool sendPendingReports=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear internal buffers and free memory.  <a href="#b557fc677e9549c71d36979dfd3ec8c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#575ed34c73adbd61892d728a688479f3">setGravity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a constant gravity for the entire scene.  <a href="#575ed34c73adbd61892d728a688479f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6fe48dbf9144be415d63f1d2f3ce0b16">getGravity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current gravity setting.  <a href="#6fe48dbf9144be415d63f1d2f3ce0b16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1e102ec1b29dea3b588b7507561e656e">setBounceThresholdVelocity</a> (const PxReal t)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the bounce threshold velocity. Collision speeds below this threshold will not cause a bounce.  <a href="#1e102ec1b29dea3b588b7507561e656e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#36f1319b6695b33823529924f389ca3e">getBounceThresholdVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the bounce threshold velocity.  <a href="#36f1319b6695b33823529924f389ca3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ed46505d6eac63a508c7a2d7e39cd5fb">setCCDMaxPasses</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> ccdMaxPasses)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of CCD passes.  <a href="#ed46505d6eac63a508c7a2d7e39cd5fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b0033036e31f91c68d520185ef6c1703">getCCDMaxPasses</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the maximum number of CCD passes.  <a href="#b0033036e31f91c68d520185ef6c1703"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#c02554e87f89db490aca6803056db522">getFrictionOffsetThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of frictionOffsetThreshold that was set in <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>.  <a href="#c02554e87f89db490aca6803056db522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#9ff7784b4d51acf2d56b9462e256b58b">setFrictionType</a> (<a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a> frictionType)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the friction model.  <a href="#9ff7784b4d51acf2d56b9462e256b58b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#aca4a2838bc3bf7ffece380c8c7f0f4e">getFrictionType</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the friction model.  <a href="#aca4a2838bc3bf7ffece380c8c7f0f4e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Visualization and Statistics</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#4055d302466a1f5cd9d481028b66b20a">setVisualizationParameter</a> (<a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a> param, PxReal value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that lets you set debug visualization parameters.  <a href="#4055d302466a1f5cd9d481028b66b20a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxReal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7c036458140a45b23facb9cf2a9cdb84">getVisualizationParameter</a> (<a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a> paramEnum) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that lets you query debug visualization parameters.  <a href="#7c036458140a45b23facb9cf2a9cdb84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b562ba2df953188a7e2b99f7ddcda5dc">setVisualizationCullingBox</a> (const <a class="el" href="classPxBounds3.html">PxBounds3</a> &amp;box)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a box in world space to which visualization geometry will be (conservatively) culled. Use a non-empty culling box to enable the feature, and an empty culling box to disable it.  <a href="#b562ba2df953188a7e2b99f7ddcda5dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#aab5854538e05abbe83c485e9d3ec082">getVisualizationCullingBox</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the visualization culling box.  <a href="#aab5854538e05abbe83c485e9d3ec082"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classPxRenderBuffer.html">PxRenderBuffer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#35f231796a325fcf587e681831c5fcb5">getRenderBuffer</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the render buffer.  <a href="#35f231796a325fcf587e681831c5fcb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7abb1e1354ae3258b91fc097e9d682b8">getSimulationStatistics</a> (<a class="el" href="classPxSimulationStatistics.html">PxSimulationStatistics</a> &amp;stats) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve statistics for the current simulation step.  <a href="#7abb1e1354ae3258b91fc097e9d682b8"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scene Query</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#d285bee8674cc03378588a32c4f85dda">getStaticStructure</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of <a class="el" href="classPxSceneDesc.html#00495fa3240d1087d38cf33eebc313a7" title="Defines the structure used to store static objects.">PxSceneDesc::staticStructure</a> that was set when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>.  <a href="#d285bee8674cc03378588a32c4f85dda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#0c756c7ad50f94675d3d8ff9ac12289b">getDynamicStructure</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of <a class="el" href="classPxSceneDesc.html#038ba820b16315ea55c6e12a3cbe2b7f" title="Defines the structure used to store dynamic objects.">PxSceneDesc::dynamicStructure</a> that was set when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>.  <a href="#0c756c7ad50f94675d3d8ff9ac12289b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b5b6fb6168a5fb8aa34299cbe73747ed">flushQueryUpdates</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flushes any changes in the simulation to the scene query representation.  <a href="#b5b6fb6168a5fb8aa34299cbe73747ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxBatchQuery.html">PxBatchQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#080866698f34876134941cf42949592b">createBatchQuery</a> (const <a class="el" href="classPxBatchQueryDesc.html">PxBatchQueryDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a BatchQuery object.  <a href="#080866698f34876134941cf42949592b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxVolumeCache.html">PxVolumeCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b5921a4665caaa38d0e02d9324b77c7c">createVolumeCache</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxStaticShapes=32, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> maxDynamicShapes=8)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a volume cache. See the Guide, "Scene Queries" section, "Volume Caching" subsection for more information.  <a href="#b5921a4665caaa38d0e02d9324b77c7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#bf2322887ca4db2fdea0229a44e2892c">setDynamicTreeRebuildRateHint</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> dynamicTreeRebuildRateHint)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the rebuild rate of the dynamic tree pruning structures.  <a href="#bf2322887ca4db2fdea0229a44e2892c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#e220420fdd08f0dabee8b30f5ef2de68">getDynamicTreeRebuildRateHint</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the rebuild rate of the dynamic tree pruning structures.  <a href="#e220420fdd08f0dabee8b30f5ef2de68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#03b103772b8c06f2bf5c8192f1cb3f70">forceDynamicTreeRebuild</a> (bool rebuildStaticStructure, bool rebuildDynamicStructure)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces dynamic trees to be immediately rebuilt.  <a href="#03b103772b8c06f2bf5c8192f1cb3f70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#8b689efc2353e9c57abf0182cb3f7dfd">setSceneQueryUpdateMode</a> (<a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a> updateMode)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets scene query update mode.  <a href="#8b689efc2353e9c57abf0182cb3f7dfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1fd7e1e617aa9359b56e91e060ad9f90">getSceneQueryUpdateMode</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets scene query update mode.  <a href="#1fd7e1e617aa9359b56e91e060ad9f90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a2b103c61cc84c1df17b82266a17413f">sceneQueriesUpdate</a> (<a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *completionTask=NULL, bool controlSimulation=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes scene queries update tasks. This function will refit dirty shapes within the pruner and will execute a task to build a new AABB tree, which is build on a different thread. The new AABB tree is built based on the dynamic tree rebuild hint rate. Once the new tree is ready it will be commited in next fetchQueries call, which must be called after.  <a href="#a2b103c61cc84c1df17b82266a17413f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#e4e41c3f3c32b955b230b26a86390e0c">checkQueries</a> (bool block=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This checks to see if the scene queries update has completed.  <a href="#e4e41c3f3c32b955b230b26a86390e0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#2f7af5ab3815d6ec6db66603ef8ced4e">fetchQueries</a> (bool block=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7d7dcd877cee092f8b57c67d79982b50">raycast</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const PxReal distance, <a class="el" href="structPxHitCallback.html">PxRaycastCallback</a> &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer object or via a custom user callback implementation inheriting from PxRaycastCallback.  <a href="#7d7dcd877cee092f8b57c67d79982b50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#9b07b2a98e64105a06e97ffaeba2a63d">sweep</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const PxReal distance, <a class="el" href="structPxHitCallback.html">PxSweepCallback</a> &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *cache=NULL, const PxReal inflation=0.f) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a sweep test against objects in the scene, returns results in a PxSweepBuffer object or via a custom user callback implementation inheriting from PxSweepCallback.  <a href="#9b07b2a98e64105a06e97ffaeba2a63d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#31d09c0e967f9806a1f0d5df78dfc996">overlap</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, <a class="el" href="structPxHitCallback.html">PxOverlapCallback</a> &amp;hitCall, const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>(), <a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *filterCall=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOverlapBuffer object or via a custom user callback implementation inheriting from PxOverlapCallback.  <a href="#31d09c0e967f9806a1f0d5df78dfc996"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#32850ee34d1736811c1e93e25c689a68">getSceneQueryStaticTimestamp</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  <a href="#32850ee34d1736811c1e93e25c689a68"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Broad-phase</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxBroadPhaseType.html#c7422f895533bff02d0043d35a2b7dda">PxBroadPhaseType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#5ac224256bfbe7380ea3dad4dc6dac06">getBroadPhaseType</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns broad-phase type.  <a href="#5ac224256bfbe7380ea3dad4dc6dac06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#670748d0b132b7360d76188c2b5262c9">getBroadPhaseCaps</a> (<a class="el" href="structPxBroadPhaseCaps.html">PxBroadPhaseCaps</a> &amp;caps) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets broad-phase caps.  <a href="#670748d0b132b7360d76188c2b5262c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a531bcd0f349fee87c0c6447869a24cc">getNbBroadPhaseRegions</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of regions currently registered in the broad-phase.  <a href="#a531bcd0f349fee87c0c6447869a24cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#78c78c1d47c7a3ab9ee234032c438d36">getBroadPhaseRegions</a> (<a class="el" href="structPxBroadPhaseRegionInfo.html">PxBroadPhaseRegionInfo</a> *userBuffer, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets broad-phase regions.  <a href="#78c78c1d47c7a3ab9ee234032c438d36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ffbf0f147c773e2b2d58831df610b1a7">addBroadPhaseRegion</a> (const <a class="el" href="structPxBroadPhaseRegion.html">PxBroadPhaseRegion</a> &amp;region, bool populateRegion=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new broad-phase region.  <a href="#ffbf0f147c773e2b2d58831df610b1a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#8fff11a9236b623ae6c2e45d00c60232">removeBroadPhaseRegion</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> handle)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a new broad-phase region.  <a href="#8fff11a9236b623ae6c2e45d00c60232"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Threads and Memory</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxTaskManager *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#be1495d04a1852030c0dec380999525a">getTaskManager</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the task manager associated with this scene.  <a href="#be1495d04a1852030c0dec380999525a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81">lockRead</a> (const char *file=NULL, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> line=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the scene for reading from the calling thread.  <a href="#088a9978be5b160b79665d4fb471ec81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ca7f8e7bc71ad39645b787bc41ab8c13">unlockRead</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the scene from reading.  <a href="#ca7f8e7bc71ad39645b787bc41ab8c13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#89d45878685fa31bb2684c096d2c6918">lockWrite</a> (const char *file=NULL, <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> line=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the scene for writing from this thread.  <a href="#89d45878685fa31bb2684c096d2c6918"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#f2fa25d740641e78ae934c0488f17a4d">unlockWrite</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the scene from writing.  <a href="#f2fa25d740641e78ae934c0488f17a4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966">setNbContactDataBlocks</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> numBlocks)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the cache blocks that can be used during <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a>.  <a href="#148be23880c4e2d67f9f772066a9f966"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b6224a915d459fb6a1c0899a080f5697">getNbContactDataBlocksUsed</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the number of cache blocks currently used by the scene  <a href="#b6224a915d459fb6a1c0899a080f5697"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a3c625507d5cfaf0f1cb9d26f66be329">getMaxNbContactDataBlocksUsed</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the maximum number of cache blocks used by the scene  <a href="#a3c625507d5cfaf0f1cb9d26f66be329"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#c7b1dccad5d20304653f21c91b09258a">getContactReportStreamBufferSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value of <a class="el" href="classPxSceneDesc.html#02d696140e9828477c8aa493a048f48a" title="Size of the contact report stream (in bytes).">PxSceneDesc::contactReportStreamBufferSize</a> that was set when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>.  <a href="#c7b1dccad5d20304653f21c91b09258a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ad9cc8bf329f4de4b407436f5cd38c98">setSolverBatchSize</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> solverBatchSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of actors required to spawn a separate rigid body solver thread.  <a href="#ad9cc8bf329f4de4b407436f5cd38c98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#dd966317a1feb083e273fd8c12f454b5">getSolverBatchSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of actors required to spawn a separate rigid body solver thread.  <a href="#dd966317a1feb083e273fd8c12f454b5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#64fbe5f25cef90d47fcb1c6428efe15a">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#64fbe5f25cef90d47fcb1c6428efe15a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Basics</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#37b5f1aed7edbae16640e0555d9271ae">PxScene</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ba2cd20df65cecbc62a08415f9a8a4b8">~PxScene</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#61f68a8c516aea477cc5328b00c976ed">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the scene.  <a href="#61f68a8c516aea477cc5328b00c976ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6610c08a5a92c894dcac9d658e48b7de">setFlag</a> (<a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53">PxSceneFlag::Enum</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a scene flag. You can only set one flag at a time.  <a href="#6610c08a5a92c894dcac9d658e48b7de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFlags.html">PxSceneFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#0acbc97457d54775b6402f3790c3513b">getFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scene flags.  <a href="#0acbc97457d54775b6402f3790c3513b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1c9025d9a26efa7b90c8c75cb7126b92">setLimits</a> (const <a class="el" href="classPxSceneLimits.html">PxSceneLimits</a> &amp;limits)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set new scene limits.  <a href="#1c9025d9a26efa7b90c8c75cb7126b92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxSceneLimits.html">PxSceneLimits</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#76d9b31b013e4d666e3b5fdea3448887">getLimits</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current scene limits.  <a href="#76d9b31b013e4d666e3b5fdea3448887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a77b43c78a62a0c771e5e6404fc55ffe">getPhysics</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve the Physics SDK.  <a href="#a77b43c78a62a0c771e5e6404fc55ffe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6003ed1a202d434ef64439741e3f2de2">getTimestamp</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene's internal timestamp, increased each time a simulation step is completed.  <a href="#6003ed1a202d434ef64439741e3f2de2"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A scene is a collection of bodies, particle systems and constraints which can interact. 
<p>
The scene simulates the behavior of these objects over time. Several scenes may exist at the same time, but each body, particle system or constraint is specific to a scene -- they may not be shared.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics.createScene()</a> <a class="el" href="classPxScene.html#61f68a8c516aea477cc5328b00c976ed" title="Deletes the scene.">release()</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="37b5f1aed7edbae16640e0555d9271ae"></a><!-- doxytag: member="PxScene::PxScene" ref="37b5f1aed7edbae16640e0555d9271ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxScene::PxScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ba2cd20df65cecbc62a08415f9a8a4b8"></a><!-- doxytag: member="PxScene::~PxScene" ref="ba2cd20df65cecbc62a08415f9a8a4b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxScene::~PxScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dd384929e3a8a81881f7e616c7a0539b"></a><!-- doxytag: member="PxScene::addActor" ref="dd384929e3a8a81881f7e616c7a0539b" args="(PxActor &amp;actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an actor to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the actor is already assigned to a scene (see <a class="el" href="classPxActor.html#2bf2e48b1960ef8e4fc1a437473bd7a3" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and an error is issued. <p>
If the actor has an invalid constraint, in checked builds the call is ignored and an error is issued.<p>
You can not add individual articulation links (see <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a>) to the scene. Use <a class="el" href="classPxScene.html#be7b1220a8798cc9b0ca58fb074141fb" title="Adds an articulation to this scene.">addArticulation()</a> instead.<p>
If the actor is a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> then each assigned <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>Actor to add to scene.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classPxConstraint.html#96bea6e60039cf468b1c677d2594611a" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a5610ee50faad60924a332ff4559321"></a><!-- doxytag: member="PxScene::addActors" ref="6a5610ee50faad60924a332ff4559321" args="(const PxPruningStructure &amp;pruningStructure)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addActors           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxPruningStructure.html">PxPruningStructure</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pruningStructure</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a pruning structure together with its actors to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If an actor in the pruning structure contains an invalid constraint, in checked builds the call is ignored and an error is issued. <p>
For all actors in the pruning structure each assigned <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.<p>
This method is optimized for high performance, and does not support buffering. It may not be called during simulation.<p>
Merging a <a class="el" href="classPxPruningStructure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors...">PxPruningStructure</a> into an active scene query optimization AABB tree might unbalance the tree. A typical use case for <a class="el" href="classPxPruningStructure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors...">PxPruningStructure</a> is a large world scenario where blocks of closely positioned actors get streamed in. The merge process finds the best node in the active scene query optimization AABB tree and inserts the <a class="el" href="classPxPruningStructure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors...">PxPruningStructure</a>. Therefore using <a class="el" href="classPxPruningStructure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors...">PxPruningStructure</a> for actors scattered throughout the world will result in an unbalanced tree.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pruningStructure</em>&nbsp;</td><td>Pruning structure for a set of actors.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#5c62ebf74c105e7ecf3eaba6949a42fa" title="Creates a pruning structure from actors.">PxPhysics::createPruningStructure</a>, <a class="el" href="classPxPruningStructure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors...">PxPruningStructure</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="caae28f21ccf233d0a9c0ad17a1ff5bd"></a><!-- doxytag: member="PxScene::addActors" ref="caae28f21ccf233d0a9c0ad17a1ff5bd" args="(PxActor *const *actors, PxU32 nbActors)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> *const *&nbsp;</td>
          <td class="paramname"> <em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbActors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds actors to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If one of the actors is already assigned to a scene (see <a class="el" href="classPxActor.html#2bf2e48b1960ef8e4fc1a437473bd7a3" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and an error is issued.<p>
You can not add individual articulation links (see <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a>) to the scene. Use <a class="el" href="classPxScene.html#be7b1220a8798cc9b0ca58fb074141fb" title="Adds an articulation to this scene.">addArticulation()</a> instead.<p>
If an actor in the array contains an invalid constraint, in checked builds the call is ignored and an error is issued. <p>
If an actor in the array is a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> then each assigned <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.<p>
this method is optimized for high performance, and does not support buffering. It may not be called during simulation.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actors</em>&nbsp;</td><td>Array of actors to add to scene. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbActors</em>&nbsp;</td><td>Number of actors in the array.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classPxConstraint.html#96bea6e60039cf468b1c677d2594611a" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e1a5eaea13e5f97415dd14690e7ce38"></a><!-- doxytag: member="PxScene::addAggregate" ref="7e1a5eaea13e5f97415dd14690e7ce38" args="(PxAggregate &amp;aggregate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an aggregate to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the aggregate is already assigned to a scene (see <a class="el" href="classPxAggregate.html#a70f305e7f2934d99afd74d28b0c0194" title="Retrieves the scene which this aggregate belongs to.">PxAggregate::getScene</a>), the call is ignored and an error is issued. <p>
If the aggregate contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.<p>
If the aggregate already contains actors, those actors are added to the scene as well.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aggregate</em>&nbsp;</td><td>Aggregate to add to scene.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a>, <a class="el" href="classPxConstraint.html#96bea6e60039cf468b1c677d2594611a" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="be7b1220a8798cc9b0ca58fb074141fb"></a><!-- doxytag: member="PxScene::addArticulation" ref="be7b1220a8798cc9b0ca58fb074141fb" args="(PxArticulation &amp;articulation)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>articulation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an articulation to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the articulation is already assigned to a scene (see <a class="el" href="classPxArticulation.html#fd299e63283d38910c48243e6d9755dd" title="Retrieves the scene which this articulation belongs to.">PxArticulation::getScene</a>), the call is ignored and an error is issued.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>articulation</em>&nbsp;</td><td>Articulation to add to scene. See <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffbf0f147c773e2b2d58831df610b1a7"></a><!-- doxytag: member="PxScene::addBroadPhaseRegion" ref="ffbf0f147c773e2b2d58831df610b1a7" args="(const PxBroadPhaseRegion &amp;region, bool populateRegion=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::addBroadPhaseRegion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxBroadPhaseRegion.html">PxBroadPhaseRegion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>populateRegion</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a new broad-phase region. 
<p>
Note that by default, objects already existing in the SDK that might touch this region will not be automatically added to the region. In other words the newly created region will be empty, and will only be populated with new objects when they are added to the simulation, or with already existing objects when they are updated.<p>
It is nonetheless possible to override this default behavior and let the SDK populate the new region automatically with already existing objects overlapping the incoming region. This has a cost though, and it should only be used when the game can not guarantee that all objects within the new region will be added to the simulation after the region itself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>region</em>&nbsp;</td><td>User-provided region data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>populateRegion</em>&nbsp;</td><td>Automatically populate new region with already existing objects overlapping it </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Handle for newly created region, or 0xffffffff in case of failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6b61683d8acb5e73b2ffb41ebecae589"></a><!-- doxytag: member="PxScene::addCollection" ref="6b61683d8acb5e73b2ffb41ebecae589" args="(const PxCollection &amp;collection)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addCollection           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxCollection.html">PxCollection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds objects in the collection to this scene. 
<p>
This function adds the following types of objects to this scene: <a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a>, <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a>. This method is typically used after deserializing the collection in order to populate the scene with deserialized objects.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the collection contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>collection</em>&nbsp;</td><td>Objects to add to this scene. See <a class="el" href="classPxCollection.html" title="Collection class for serialization.">PxCollection</a></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCollection.html" title="Collection class for serialization.">PxCollection</a>, <a class="el" href="classPxConstraint.html#96bea6e60039cf468b1c677d2594611a" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc85aa20552a55905aa1329722a555d7"></a><!-- doxytag: member="PxScene::advance" ref="dc85aa20552a55905aa1329722a555d7" args="(physx::PxBaseTask *completionTask=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::advance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *&nbsp;</td>
          <td class="paramname"> <em>completionTask</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs dynamics phase of the simulation pipeline. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Calls to <a class="el" href="classPxScene.html#dc85aa20552a55905aa1329722a555d7" title="Performs dynamics phase of the simulation pipeline.">advance()</a> should follow calls to <a class="el" href="classPxScene.html#c320cd782704022cc044a1ef4b0c582f">fetchCollision()</a>. An error message will be issued if this sequence is not followed.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completionTask</em>&nbsp;</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classPxScene.html#dc85aa20552a55905aa1329722a555d7" title="Performs dynamics phase of the simulation pipeline.">advance()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e4e41c3f3c32b955b230b26a86390e0c"></a><!-- doxytag: member="PxScene::checkQueries" ref="e4e41c3f3c32b955b230b26a86390e0c" args="(bool block=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::checkQueries           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This checks to see if the scene queries update has completed. 
<p>
This does not cause the data available for reading to be updated with the results of the scene queries update, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the results are available.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#a2b103c61cc84c1df17b82266a17413f" title="Executes scene queries update tasks. This function will refit dirty shapes within...">sceneQueriesUpdate()</a> <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f45a8ee04f0bcd2c23b23daa176bee5"></a><!-- doxytag: member="PxScene::checkResults" ref="6f45a8ee04f0bcd2c23b23daa176bee5" args="(bool block=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::checkResults           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This checks to see if the simulation run has completed. 
<p>
This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the results are available.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="17c3863f711ef79c08c6054b69fd430c"></a><!-- doxytag: member="PxScene::collide" ref="17c3863f711ef79c08c6054b69fd430c" args="(PxReal elapsedTime, physx::PxBaseTask *completionTask=0, void *scratchMemBlock=0, PxU32 scratchMemBlockSize=0, bool controlSimulation=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::collide           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *&nbsp;</td>
          <td class="paramname"> <em>completionTask</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratchMemBlock</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>scratchMemBlockSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>controlSimulation</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs collision detection for the scene over elapsedTime. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Calls to <a class="el" href="classPxScene.html#17c3863f711ef79c08c6054b69fd430c" title="Performs collision detection for the scene over elapsedTime.">collide()</a> should be the first method called to simulate a frame.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elapsedTime</em>&nbsp;</td><td>Amount of time to advance simulation by. The parameter has to be larger than 0, else the resulting behavior will be undefined. <b>Range:</b> (0, PX_MAX_F32) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completionTask</em>&nbsp;</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classPxScene.html#17c3863f711ef79c08c6054b69fd430c" title="Performs collision detection for the scene over elapsedTime.">collide()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchMemBlock</em>&nbsp;</td><td>a memory region for <a class="el" href="namespacephysx.html">physx</a> to use for temporary data during simulation. This block may be reused by the application after fetchResults returns. Must be aligned on a 16-byte boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchMemBlockSize</em>&nbsp;</td><td>the size of the scratch memory block. Must be a multiple of 16K. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlSimulation</em>&nbsp;</td><td>if true, the scene controls its PxTaskManager simulation state. Leave true unless the application is calling the PxTaskManager start/stopSimulation() methods itself. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="080866698f34876134941cf42949592b"></a><!-- doxytag: member="PxScene::createBatchQuery" ref="080866698f34876134941cf42949592b" args="(const PxBatchQueryDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxBatchQuery.html">PxBatchQuery</a>* PxScene::createBatchQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBatchQueryDesc.html">PxBatchQueryDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a BatchQuery object. 
<p>
Scene queries like raycasts, overlap tests and sweeps are batched in this object and are then executed at once. See <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a>.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>The batched query feature has been deprecated in PhysX version 3.4</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The descriptor of scene query. Scene Queries need to register a callback. See <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="285849425521dd0344f55b4a7c0a834a"></a><!-- doxytag: member="PxScene::createClient" ref="285849425521dd0344f55b4a7c0a834a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> PxScene::createClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reserves a new client ID. 
<p>
PX_DEFAULT_CLIENT is always available as the default clientID. Additional clients are returned by this function. Clients cannot be released once created. An error is reported when more than a supported number of clients (currently 128) are created.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxClientBehaviorFlag.html" title="Behavior bit flags for simulation clients.">PxClientBehaviorFlag</a> <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12" title="An ID to identify different clients for multiclient support.">PxClientID</a> <a class="el" href="classPxScene.html#6f61e48083f63f6fac343a3b1d8b2ddc" title="Sets behavior bits for a client.">setClientBehaviorFlags()</a> <a class="el" href="classPxActor.html#d7b70236ed41524eda4c92636922d599" title="Sets the behavior bits of the actor.">PxActor::setClientBehaviorFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5921a4665caaa38d0e02d9324b77c7c"></a><!-- doxytag: member="PxScene::createVolumeCache" ref="b5921a4665caaa38d0e02d9324b77c7c" args="(PxU32 maxStaticShapes=32, PxU32 maxDynamicShapes=8)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxVolumeCache.html">PxVolumeCache</a>* PxScene::createVolumeCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxStaticShapes</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxDynamicShapes</em> = <code>8</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a volume cache. See the Guide, "Scene Queries" section, "Volume Caching" subsection for more information. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>The volume cache feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxVolumeCache.html" title="Volumetric cache for local collision geometry.">PxVolumeCache</a> <a class="el" href="classPxVolumeCache.html#5cf192b373fadb356a2c016717852c4d" title="Releases the cache object and its resources.">PxVolumeCache.release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c320cd782704022cc044a1ef4b0c582f"></a><!-- doxytag: member="PxScene::fetchCollision" ref="c320cd782704022cc044a1ef4b0c582f" args="(bool block=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::fetchCollision           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method must be called after <a class="el" href="classPxScene.html#17c3863f711ef79c08c6054b69fd430c" title="Performs collision detection for the scene over elapsedTime.">collide()</a> and before <a class="el" href="classPxScene.html#dc85aa20552a55905aa1329722a555d7" title="Performs dynamics phase of the simulation pipeline.">advance()</a>. It will wait for the collision phase to finish. If the user makes an illegal simulation call, the SDK will issue an error message.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met, which is collision must finish running. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2f7af5ab3815d6ec6db66603ef8ced4e"></a><!-- doxytag: member="PxScene::fetchQueries" ref="2f7af5ab3815d6ec6db66603ef8ced4e" args="(bool block=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::fetchQueries           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method must be called after sceneQueriesUpdate. It will wait for the scene queries update to finish. If the user makes an illegal scene queries update call, the SDK will issue an error message.<p>
If a new AABB tree build finished, then during fetchQueries the current tree within the pruning structure is swapped with the new tree.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met, which is tree built task must finish running. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b34e054ccf428a1cdbd81bf1e2b87fae"></a><!-- doxytag: member="PxScene::fetchResults" ref="b34e054ccf428a1cdbd81bf1e2b87fae" args="(bool block=false, PxU32 *errorState=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::fetchResults           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>errorState</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the big brother to <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> it basically does the following:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( <a class="code" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults</a>(block) )
    {
        fire appropriate callbacks
        swap buffers
        <span class="keywordflow">return</span> <span class="keyword">true</span>
    }
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until results are available. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>errorState</em>&nbsp;</td><td>Used to retrieve hardware error codes. A non zero value indicates an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the results have been fetched.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e70b9f9ac942c0b90b2b78d45b99708"></a><!-- doxytag: member="PxScene::fetchResultsFinish" ref="9e70b9f9ac942c0b90b2b78d45b99708" args="(PxU32 *errorState=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::fetchResultsFinish           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>errorState</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This call performs the second section of fetchResults: the buffer swap and subsequent callbacks.<p>
It must be called after <a class="el" href="classPxScene.html#e5515efb07a300166c0d47adce6acd6f">fetchResultsStart()</a> returns and contact reports have been processed.<p>
Note that once <a class="el" href="classPxScene.html#9e70b9f9ac942c0b90b2b78d45b99708">fetchResultsFinish()</a> has been called, the contact streams returned in <a class="el" href="classPxScene.html#e5515efb07a300166c0d47adce6acd6f">fetchResultsStart()</a> will be invalid.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>errorState</em>&nbsp;</td><td>Used to retrieve hardware error codes. A non zero value indicates an error.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> <a class="el" href="classPxScene.html#e5515efb07a300166c0d47adce6acd6f">fetchResultsStart()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5515efb07a300166c0d47adce6acd6f"></a><!-- doxytag: member="PxScene::fetchResultsStart" ref="e5515efb07a300166c0d47adce6acd6f" args="(const PxContactPairHeader *&amp;contactPairs, PxU32 &amp;nbContactPairs, bool block=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::fetchResultsStart           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxContactPairHeader.html">PxContactPairHeader</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>contactPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbContactPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This call performs the first section of fetchResults (callbacks fired before swapBuffers), and returns a pointer to a to the contact streams output by the simulation. It can be used to process contact pairs in parallel, which is often a limiting factor for <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> performance.<p>
After calling this function and processing the contact streams, call <a class="el" href="classPxScene.html#9e70b9f9ac942c0b90b2b78d45b99708">fetchResultsFinish()</a>. Note that writes to the simulation are not permitted between the start of <a class="el" href="classPxScene.html#e5515efb07a300166c0d47adce6acd6f">fetchResultsStart()</a> and the end of <a class="el" href="classPxScene.html#9e70b9f9ac942c0b90b2b78d45b99708">fetchResultsFinish()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until results are available. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>contactPairs</em>&nbsp;</td><td>an array of pointers to contact pair headers </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbContactPairs</em>&nbsp;</td><td>the number of contact pairs </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the results have been fetched.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> <a class="el" href="classPxScene.html#9e70b9f9ac942c0b90b2b78d45b99708">fetchResultsFinish()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5b6fb6168a5fb8aa34299cbe73747ed"></a><!-- doxytag: member="PxScene::flushQueryUpdates" ref="b5b6fb6168a5fb8aa34299cbe73747ed" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::flushQueryUpdates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flushes any changes in the simulation to the scene query representation. 
<p>
This method updates the state of the scene query representation to match changes in the scene state.<p>
By default, these changes are buffered until the next query is submitted. Calling this function will not change the results from scene queries, but can be used to ensure that a query will not perform update work in the course of its execution.<p>
A thread performing updates will hold a write lock on the query structure, and thus stall other querying threads. In multithread scenarios it can be useful to explicitly schedule the period where this lock may be held for a significant period, so that subsequent queries issued from multiple threads will not block.<p>
Note that while queries will block during the execution of this method, other read operations on the scene will not. 
</div>
</div><p>
<a class="anchor" name="b557fc677e9549c71d36979dfd3ec8c5"></a><!-- doxytag: member="PxScene::flushSimulation" ref="b557fc677e9549c71d36979dfd3ec8c5" args="(bool sendPendingReports=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::flushSimulation           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sendPendingReports</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear internal buffers and free memory. 
<p>
This method can be used to clear buffers and free internal memory without having to destroy the scene. Can be useful if the physics data gets streamed in and a checkpoint with a clean state should be created.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is not allowed to call this method while the simulation is running. The call will fail.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendPendingReports</em>&nbsp;</td><td>When set to true pending reports will be sent out before the buffers get cleaned up (for instance lost touch contact/trigger reports due to deleted objects). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="03b103772b8c06f2bf5c8192f1cb3f70"></a><!-- doxytag: member="PxScene::forceDynamicTreeRebuild" ref="03b103772b8c06f2bf5c8192f1cb3f70" args="(bool rebuildStaticStructure, bool rebuildDynamicStructure)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::forceDynamicTreeRebuild           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>rebuildStaticStructure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>rebuildDynamicStructure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces dynamic trees to be immediately rebuilt. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rebuildStaticStructure</em>&nbsp;</td><td>True to rebuild the dynamic tree containing static objects </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rebuildDynamicStructure</em>&nbsp;</td><td>True to rebuild the dynamic tree containing dynamic objects</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3" title="Hint for how much work should be done per simulation frame to rebuild the pruning...">PxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classPxScene.html#bf2322887ca4db2fdea0229a44e2892c" title="Sets the rebuild rate of the dynamic tree pruning structures.">setDynamicTreeRebuildRateHint()</a> <a class="el" href="classPxScene.html#e220420fdd08f0dabee8b30f5ef2de68" title="Retrieves the rebuild rate of the dynamic tree pruning structures.">getDynamicTreeRebuildRateHint()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c556f41a6fb051bae49765e3cbdbe3f8"></a><!-- doxytag: member="PxScene::getActiveActors" ref="c556f41a6fb051bae49765e3cbdbe3f8" args="(PxU32 &amp;nbActorsOut, PX_DEPRECATED PxClientID client=PX_DEFAULT_CLIENT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxActor.html">PxActor</a>** PxScene::getActiveActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbActorsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53b864a8d54af8c7baaedba117977a523f" title="Enable Active Actors Notification.">PxSceneFlag::eENABLE_ACTIVE_ACTORS</a> must be set. Multiclient behavior: the system returns only the list of active actors owned by the specified client.<p>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored and NULL will be returned.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbActorsOut</em>&nbsp;</td><td>The number of actors returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client whose actors the caller is interested in.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd><a class="el" href="structPxActorClientBehaviorFlag.html" title="Multiclient behavior bit flags for actors.">PxActorClientBehaviorFlag</a> feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the list of active PxActors generated during the last call to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fdec7976b853ad4af5573bb13197426"></a><!-- doxytag: member="PxScene::getActiveTransforms" ref="5fdec7976b853ad4af5573bb13197426" args="(PxU32 &amp;nbTransformsOut, PxClientID client=PX_DEFAULT_CLIENT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED const <a class="el" href="structPxActiveTransform.html">PxActiveTransform</a>* PxScene::getActiveTransforms           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbTransformsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>PxSceneFlag::eENABLE_ACTIVETRANSFORMS must be set. Multiclient behavior: Active transforms return only the list of active actors owned by the specified client.<p>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored and NULL will be returned.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbTransformsOut</em>&nbsp;</td><td>The number of transforms returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client whose actors the caller is interested in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the list of PxActiveTransforms generated during the last call to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxActiveTransform.html" title="Data struct for use with Active Transform Notification. Used with PxScene::getActiveTransforms()...">PxActiveTransform</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e2ad69311278772a479950d0c73f0b75"></a><!-- doxytag: member="PxScene::getActors" ref="e2ad69311278772a479950d0c73f0b75" args="(PxActorTypeFlags types, PxActor **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxActorTypeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve an array of all the actors of certain types in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>types</em>&nbsp;</td><td>Combination of actor types to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive actor pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first actor pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of actors written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#f44b7f47e3d9332a2fcade3e3f766a5d" title="Retrieve the number of actors of certain types in the scene.">getNbActors()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f25335de0c6012d9a5d7e78c8272824e"></a><!-- doxytag: member="PxScene::getAggregates" ref="f25335de0c6012d9a5d7e78c8272824e" args="(PxAggregate **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getAggregates           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxAggregate.html">PxAggregate</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the aggregates in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive aggregates pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first aggregate pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of aggregates written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#a95c08ef234a55388b297ec657487b69" title="Returns the number of aggregates in the scene.">getNbAggregates()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eca9cb7d9353559e214a51a599e28a85"></a><!-- doxytag: member="PxScene::getArticulations" ref="eca9cb7d9353559e214a51a599e28a85" args="(PxArticulation **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getArticulations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the articulations in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive articulations pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first articulations pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of articulations written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b09a3fad6a720283c0a95fe7f76973e4" title="Returns the number of articulations in the scene.">getNbArticulations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="36f1319b6695b33823529924f389ca3e"></a><!-- doxytag: member="PxScene::getBounceThresholdVelocity" ref="36f1319b6695b33823529924f389ca3e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxScene::getBounceThresholdVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the bounce threshold velocity. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#bc7769532392c8e47ec4580677145e34" title="A contact with a relative velocity below this will not bounce. A typical value for...">PxSceneDesc.bounceThresholdVelocity</a>, <a class="el" href="classPxScene.html#1e102ec1b29dea3b588b7507561e656e" title="Set the bounce threshold velocity. Collision speeds below this threshold will not...">setBounceThresholdVelocity</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3823d25fc80ebe53c1c02cef57115b06"></a><!-- doxytag: member="PxScene::getBroadPhaseCallback" ref="3823d25fc80ebe53c1c02cef57115b06" args="(PX_DEPRECATED PxClientID client=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a>* PxScene::getBroadPhaseCallback           </td>
          <td>(</td>
          <td class="paramtype">PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the <a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> pointer set with <a class="el" href="classPxScene.html#c1110386fc2ffad70aa771aabc51d026" title="Sets a broad-phase user callback object.">setBroadPhaseCallback()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client whose callback object is to be returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current broad-phase callback pointer. See <a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a>.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd><a class="el" href="structPxActorClientBehaviorFlag.html" title="Multiclient behavior bit flags for actors.">PxActorClientBehaviorFlag</a> feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> <a class="el" href="classPxScene.html#c1110386fc2ffad70aa771aabc51d026" title="Sets a broad-phase user callback object.">setBroadPhaseCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="670748d0b132b7360d76188c2b5262c9"></a><!-- doxytag: member="PxScene::getBroadPhaseCaps" ref="670748d0b132b7360d76188c2b5262c9" args="(PxBroadPhaseCaps &amp;caps) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::getBroadPhaseCaps           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxBroadPhaseCaps.html">PxBroadPhaseCaps</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>caps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets broad-phase caps. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>caps</em>&nbsp;</td><td>Broad-phase caps </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if success </dd></dl>

</div>
</div><p>
<a class="anchor" name="78c78c1d47c7a3ab9ee234032c438d36"></a><!-- doxytag: member="PxScene::getBroadPhaseRegions" ref="78c78c1d47c7a3ab9ee234032c438d36" args="(PxBroadPhaseRegionInfo *userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getBroadPhaseRegions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxBroadPhaseRegionInfo.html">PxBroadPhaseRegionInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets broad-phase regions. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>Returned broad-phase regions </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of userBuffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first desired region, in [0 ; getNbRegions()[ </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of written out regions </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ac224256bfbe7380ea3dad4dc6dac06"></a><!-- doxytag: member="PxScene::getBroadPhaseType" ref="5ac224256bfbe7380ea3dad4dc6dac06" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxBroadPhaseType.html#c7422f895533bff02d0043d35a2b7dda">PxBroadPhaseType::Enum</a> PxScene::getBroadPhaseType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns broad-phase type. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Broad-phase type </dd></dl>

</div>
</div><p>
<a class="anchor" name="952ff4e7b46ff4d3396195e65cd494e6"></a><!-- doxytag: member="PxScene::getCCDContactModifyCallback" ref="952ff4e7b46ff4d3396195e65cd494e6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a>* PxScene::getCCDContactModifyCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the <a class="el" href="classPxCCDContactModifyCallback.html" title="An interface class that the user can implement in order to modify CCD contact constraints...">PxCCDContactModifyCallback</a> pointer set with <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current user contact modify callback pointer. See <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0033036e31f91c68d520185ef6c1703"></a><!-- doxytag: member="PxScene::getCCDMaxPasses" ref="b0033036e31f91c68d520185ef6c1703" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getCCDMaxPasses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the maximum number of CCD passes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum number of CCD passes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#65aa4ceefbbd6aebd75ea879d7c385f9" title="Maximum number of CCD passes.">PxSceneDesc::ccdMaxPasses</a> <a class="el" href="classPxScene.html#ed46505d6eac63a508c7a2d7e39cd5fb" title="Sets the maximum number of CCD passes.">setCCDMaxPasses()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8259c90c79fb69ee62e9434eb35e0f37"></a><!-- doxytag: member="PxScene::getClientBehaviorFlags" ref="8259c90c79fb69ee62e9434eb35e0f37" args="(PxClientID client) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="PxClient_8h.html#295b321eb41489154df2d9dd381282d1">PxClientBehaviorFlags</a> PxScene::getClientBehaviorFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves behavior bits for a client. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd><a class="el" href="structPxActorClientBehaviorFlag.html" title="Multiclient behavior bit flags for actors.">PxActorClientBehaviorFlag</a> feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxClientBehaviorFlag.html" title="Behavior bit flags for simulation clients.">PxClientBehaviorFlag</a> <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12" title="An ID to identify different clients for multiclient support.">PxClientID</a> <a class="el" href="classPxScene.html#6f61e48083f63f6fac343a3b1d8b2ddc" title="Sets behavior bits for a client.">setClientBehaviorFlags()</a> <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b31964586c71755fb261a879435655fb"></a><!-- doxytag: member="PxScene::getClothInterCollisionDistance" ref="b31964586c71755fb261a879435655fb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED PxF32 PxScene::getClothInterCollisionDistance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves distance used for cloth inter-collision. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The distance used for cloth inter-collision. </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="605049c3cc13532d47803ba5303ce326"></a><!-- doxytag: member="PxScene::getClothInterCollisionNbIterations" ref="605049c3cc13532d47803ba5303ce326" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getClothInterCollisionNbIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of iterations used for cloth inter-collision. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of iterations used for cloth inter-collision. </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f8880466c56bedbc2cd9f96f24e8331"></a><!-- doxytag: member="PxScene::getClothInterCollisionStiffness" ref="3f8880466c56bedbc2cd9f96f24e8331" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED PxF32 PxScene::getClothInterCollisionStiffness           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the stiffness coefficient used for cloth inter-collision. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The stiffness coefficient used for cloth inter-collision. </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e9919abdfb23495a84f47c5157a67b1"></a><!-- doxytag: member="PxScene::getConstraints" ref="1e9919abdfb23495a84f47c5157a67b1" args="(PxConstraint **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getConstraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConstraint.html">PxConstraint</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the constraint shaders in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive constraint shader pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first constraint pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of constraint shaders written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#7ee023de370ac90a7d4c204d916d3080" title="Returns the number of constraint shaders in the scene.">getNbConstraints()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1978693b355df49712d7e59c10c4115d"></a><!-- doxytag: member="PxScene::getContactModifyCallback" ref="1978693b355df49712d7e59c10c4115d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a>* PxScene::getContactModifyCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> pointer set with <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current user contact modify callback pointer. See <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c7b1dccad5d20304653f21c91b09258a"></a><!-- doxytag: member="PxScene::getContactReportStreamBufferSize" ref="c7b1dccad5d20304653f21c91b09258a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getContactReportStreamBufferSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value of <a class="el" href="classPxSceneDesc.html#02d696140e9828477c8aa493a048f48a" title="Size of the contact report stream (in bytes).">PxSceneDesc::contactReportStreamBufferSize</a> that was set when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#02d696140e9828477c8aa493a048f48a" title="Size of the contact report stream (in bytes).">PxSceneDesc::contactReportStreamBufferSize</a>, <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6329c94cc092aff2193c1307e033f6bf"></a><!-- doxytag: member="PxScene::getCpuDispatcher" ref="6329c94cc092aff2193c1307e033f6bf" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCpuDispatcher* PxScene::getCpuDispatcher           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the cpu dispatcher that was set in <a class="el" href="classPxSceneDesc.html#c74f5f6c12d72b873716f82c2225b725" title="The CPU task dispatcher for the scene.">PxSceneDesc::cpuDispatcher</a> when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#c74f5f6c12d72b873716f82c2225b725" title="The CPU task dispatcher for the scene.">PxSceneDesc::cpuDispatcher</a>, <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="951ada59fff16e5c860ccdd5f6d5a1f3"></a><!-- doxytag: member="PxScene::getDominanceGroupPair" ref="951ada59fff16e5c860ccdd5f6d5a1f3" args="(PxDominanceGroup group1, PxDominanceGroup group2) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxDominanceGroupPair.html">PxDominanceGroupPair</a> PxScene::getDominanceGroupPair           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Samples the dominance matrix. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b6d9e986e6af967d2bd60a63a0b550c4" title="Specifies the dominance behavior of contacts between two actors with two certain...">setDominanceGroupPair()</a> <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> <a class="el" href="structPxDominanceGroupPair.html" title="Expresses the dominance relationship of a contact. For the time being only three...">PxDominanceGroupPair</a> <a class="el" href="classPxActor.html#614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a> <a class="el" href="classPxActor.html#24602fee489b3e797ff0f82613eef755" title="Retrieves the value set with setDominanceGroup().">PxActor::getDominanceGroup()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0c756c7ad50f94675d3d8ff9ac12289b"></a><!-- doxytag: member="PxScene::getDynamicStructure" ref="0c756c7ad50f94675d3d8ff9ac12289b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a> PxScene::getDynamicStructure           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value of <a class="el" href="classPxSceneDesc.html#038ba820b16315ea55c6e12a3cbe2b7f" title="Defines the structure used to store dynamic objects.">PxSceneDesc::dynamicStructure</a> that was set when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#038ba820b16315ea55c6e12a3cbe2b7f" title="Defines the structure used to store dynamic objects.">PxSceneDesc::dynamicStructure</a>, <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e220420fdd08f0dabee8b30f5ef2de68"></a><!-- doxytag: member="PxScene::getDynamicTreeRebuildRateHint" ref="e220420fdd08f0dabee8b30f5ef2de68" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getDynamicTreeRebuildRateHint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the rebuild rate of the dynamic tree pruning structures. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The rebuild rate of the dynamic tree pruning structures.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3" title="Hint for how much work should be done per simulation frame to rebuild the pruning...">PxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classPxScene.html#bf2322887ca4db2fdea0229a44e2892c" title="Sets the rebuild rate of the dynamic tree pruning structures.">setDynamicTreeRebuildRateHint()</a> <a class="el" href="classPxScene.html#03b103772b8c06f2bf5c8192f1cb3f70" title="Forces dynamic trees to be immediately rebuilt.">forceDynamicTreeRebuild()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b4c17b1a16df239e5d6a2e0e6f8b633"></a><!-- doxytag: member="PxScene::getFilterCallback" ref="2b4c17b1a16df239e5d6a2e0e6f8b633" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a>* PxScene::getFilterCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the custom collision filter callback in use for this scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Filter callback class that defines the collision pair filtering.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#f7b94475075eb9b43ca32650cd169cc1" title="A custom collision filter callback which can be used to implement more complex filtering...">PxSceneDesc.filterCallback</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3f57314433de21448966c1d9004d71a"></a><!-- doxytag: member="PxScene::getFilterShader" ref="a3f57314433de21448966c1d9004d71a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a> PxScene::getFilterShader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the custom collision filter shader in use for this scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Filter shader class that defines the collision pair filtering.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#9410287c6ea926dad9e2b2374541ad38" title="The custom filter shader to use for collision filtering.">PxSceneDesc.filterShader</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d004fdc88ed31447aa57ee4f98c14ea"></a><!-- doxytag: member="PxScene::getFilterShaderData" ref="5d004fdc88ed31447aa57ee4f98c14ea" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* PxScene::getFilterShaderData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the shared global filter data in use for this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The reference points to a copy of the original filter data specified in <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> or provided by <a class="el" href="classPxScene.html#5ab05d2a2c908d98aed4ca642c5f394d" title="Sets the shared global filter data which will get passed into the filter shader.">setFilterShaderData()</a>.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Shared filter data for filter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#ce291f68b365a4f1aaa291ba940eff9a" title="Gets the size of the shared global filter data (PxSceneDesc.filterShaderData).">getFilterShaderDataSize()</a> <a class="el" href="classPxScene.html#5ab05d2a2c908d98aed4ca642c5f394d" title="Sets the shared global filter data which will get passed into the filter shader.">setFilterShaderData()</a> <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce291f68b365a4f1aaa291ba940eff9a"></a><!-- doxytag: member="PxScene::getFilterShaderDataSize" ref="ce291f68b365a4f1aaa291ba940eff9a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getFilterShaderDataSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of shared filter data [bytes].</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#5d004fdc88ed31447aa57ee4f98c14ea" title="Gets the shared global filter data in use for this scene.">getFilterShaderData()</a> <a class="el" href="classPxSceneDesc.html#710c03915bbaaa9bdf23925d535c3883" title="Size (in bytes) of the shared global filter data filterShaderData.">PxSceneDesc.filterShaderDataSize</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0acbc97457d54775b6402f3790c3513b"></a><!-- doxytag: member="PxScene::getFlags" ref="0acbc97457d54775b6402f3790c3513b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFlags.html">PxSceneFlags</a> PxScene::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the scene flags. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The scene flags. See <a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c02554e87f89db490aca6803056db522"></a><!-- doxytag: member="PxScene::getFrictionOffsetThreshold" ref="c02554e87f89db490aca6803056db522" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxScene::getFrictionOffsetThreshold           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value of frictionOffsetThreshold that was set in <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#f707e0c97624aaf6fa9ab2e82aadbecf" title="A threshold of contact separation distance used to decide if a contact point will...">PxSceneDesc::frictionOffsetThreshold</a>, <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="aca4a2838bc3bf7ffece380c8c7f0f4e"></a><!-- doxytag: member="PxScene::getFrictionType" ref="aca4a2838bc3bf7ffece380c8c7f0f4e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a> PxScene::getFrictionType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the friction model. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxFrictionType.html" title="Enum for selecting the friction algorithm used for simulation.">PxFrictionType</a>, <a class="el" href="classPxSceneDesc.html#b1f18b0666adb645d92fc2f53373b1e9" title="Selects the friction algorithm to use for simulation.">PxSceneDesc::frictionType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="256ac6d74578418c446fc5fe1fe95170"></a><!-- doxytag: member="PxScene::getGpuDispatcher" ref="256ac6d74578418c446fc5fe1fe95170" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxGpuDispatcher* PxScene::getGpuDispatcher           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the gpu dispatcher that was set in <a class="el" href="classPxSceneDesc.html#e3e78a948f61b9b2d3cd47c62205bccc" title="The GPU task dispatcher for the scene.">PxSceneDesc::gpuDispatcher</a> when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>. 
<p>
<b>Platform specific:</b> Applies to PC GPU only.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#e3e78a948f61b9b2d3cd47c62205bccc" title="The GPU task dispatcher for the scene.">PxSceneDesc::gpuDispatcher</a>, <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fe48dbf9144be415d63f1d2f3ce0b16"></a><!-- doxytag: member="PxScene::getGravity" ref="6fe48dbf9144be415d63f1d2f3ce0b16" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxScene::getGravity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the current gravity setting. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current gravity for the scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#575ed34c73adbd61892d728a688479f3" title="Sets a constant gravity for the entire scene.">setGravity()</a> <a class="el" href="classPxSceneDesc.html#9b0de35c38c43b8aeff6e6f29bf0db20" title="Gravity vector.">PxSceneDesc.gravity</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="76d9b31b013e4d666e3b5fdea3448887"></a><!-- doxytag: member="PxScene::getLimits" ref="76d9b31b013e4d666e3b5fdea3448887" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSceneLimits.html">PxSceneLimits</a> PxScene::getLimits           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current scene limits. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current scene limits. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneLimits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits...">PxSceneLimits</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3c625507d5cfaf0f1cb9d26f66be329"></a><!-- doxytag: member="PxScene::getMaxNbContactDataBlocksUsed" ref="a3c625507d5cfaf0f1cb9d26f66be329" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getMaxNbContactDataBlocksUsed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the maximum number of cache blocks used by the scene 
<p>
This function may not be called while the scene is simulating<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of cache blocks everused by the scene</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to define the number of 16K blocks that will be initially reserved to store...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35" title="Setting to define the maximum number of 16K blocks that can be allocated to store...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classPxScene.html#b557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory.">flushSimulation()</a> <a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate().">setNbContactDataBlocks()</a> <a class="el" href="classPxScene.html#b6224a915d459fb6a1c0899a080f5697" title="get the number of cache blocks currently used by the scene">getNbContactDataBlocksUsed()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f44b7f47e3d9332a2fcade3e3f766a5d"></a><!-- doxytag: member="PxScene::getNbActors" ref="f44b7f47e3d9332a2fcade3e3f766a5d" args="(PxActorTypeFlags types) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getNbActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxActorTypeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>types</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the number of actors of certain types in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>types</em>&nbsp;</td><td>Combination of actor types. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of actors.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#e2ad69311278772a479950d0c73f0b75" title="Retrieve an array of all the actors of certain types in the scene.">getActors()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a95c08ef234a55388b297ec657487b69"></a><!-- doxytag: member="PxScene::getNbAggregates" ref="a95c08ef234a55388b297ec657487b69" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getNbAggregates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of aggregates in the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of aggregates in this scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#f25335de0c6012d9a5d7e78c8272824e" title="Retrieve all the aggregates in the scene.">getAggregates()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b09a3fad6a720283c0a95fe7f76973e4"></a><!-- doxytag: member="PxScene::getNbArticulations" ref="b09a3fad6a720283c0a95fe7f76973e4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getNbArticulations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of articulations in the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of articulations in this scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#eca9cb7d9353559e214a51a599e28a85" title="Retrieve all the articulations in the scene.">getArticulations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a531bcd0f349fee87c0c6447869a24cc"></a><!-- doxytag: member="PxScene::getNbBroadPhaseRegions" ref="a531bcd0f349fee87c0c6447869a24cc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getNbBroadPhaseRegions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of regions currently registered in the broad-phase. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of regions </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ee023de370ac90a7d4c204d916d3080"></a><!-- doxytag: member="PxScene::getNbConstraints" ref="7ee023de370ac90a7d4c204d916d3080" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getNbConstraints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of constraint shaders in the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of constraint shaders in this scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#1e9919abdfb23495a84f47c5157a67b1" title="Retrieve all the constraint shaders in the scene.">getConstraints()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6224a915d459fb6a1c0899a080f5697"></a><!-- doxytag: member="PxScene::getNbContactDataBlocksUsed" ref="b6224a915d459fb6a1c0899a080f5697" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getNbContactDataBlocksUsed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the number of cache blocks currently used by the scene 
<p>
This function may not be called while the scene is simulating<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of cache blocks currently used by the scene</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to define the number of 16K blocks that will be initially reserved to store...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35" title="Setting to define the maximum number of 16K blocks that can be allocated to store...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classPxScene.html#b557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory.">flushSimulation()</a> <a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate().">setNbContactDataBlocks()</a> <a class="el" href="classPxScene.html#a3c625507d5cfaf0f1cb9d26f66be329" title="get the maximum number of cache blocks used by the scene">getMaxNbContactDataBlocksUsed()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a77b43c78a62a0c771e5e6404fc55ffe"></a><!-- doxytag: member="PxScene::getPhysics" ref="a77b43c78a62a0c771e5e6404fc55ffe" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxPhysics.html">PxPhysics</a>&amp; PxScene::getPhysics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this method to retrieve the Physics SDK. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The physics SDK this scene is associated with.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35f231796a325fcf587e681831c5fcb5"></a><!-- doxytag: member="PxScene::getRenderBuffer" ref="35f231796a325fcf587e681831c5fcb5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classPxRenderBuffer.html">PxRenderBuffer</a>&amp; PxScene::getRenderBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the render buffer. 
<p>
This will contain the results of any active visualization for this scene.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not use this method while the simulation is running. Calls to this method while result in undefined behaviour.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The render buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRenderBuffer.html" title="Interface for points, lines, triangles, and text buffer.">PxRenderBuffer</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac4ee13053cdb7f50ca6c065077c9ee3"></a><!-- doxytag: member="PxScene::getScenePvdClient" ref="ac4ee13053cdb7f50ca6c065077c9ee3" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxPvdSceneClient.html">PxPvdSceneClient</a>* PxScene::getScenePvdClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the Pvd client associated with the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the client, NULL if no PVD supported. </dd></dl>

</div>
</div><p>
<a class="anchor" name="32850ee34d1736811c1e93e25c689a68"></a><!-- doxytag: member="PxScene::getSceneQueryStaticTimestamp" ref="32850ee34d1736811c1e93e25c689a68" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getSceneQueryStaticTimestamp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>scene query static timestamp </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fd7e1e617aa9359b56e91e060ad9f90"></a><!-- doxytag: member="PxScene::getSceneQueryUpdateMode" ref="1fd7e1e617aa9359b56e91e060ad9f90" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a> PxScene::getSceneQueryUpdateMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets scene query update mode. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current scene query update mode.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1eb6366fd80f5a8f6a9154a412c33436"></a><!-- doxytag: member="PxScene::getSimulationEventCallback" ref="1eb6366fd80f5a8f6a9154a412c33436" args="(PX_DEPRECATED PxClientID client=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a>* PxScene::getSimulationEventCallback           </td>
          <td>(</td>
          <td class="paramtype">PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the simulationEventCallback pointer set with <a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">setSimulationEventCallback()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client whose callback object is to be returned. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current user notify pointer. See <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a>.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd><a class="el" href="structPxActorClientBehaviorFlag.html" title="Multiclient behavior bit flags for actors.">PxActorClientBehaviorFlag</a> feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> <a class="el" href="classPxScene.html#88f5438bf61cf5c3f767d8b515c51d31" title="Sets a user notify object which receives special simulation events when they occur...">setSimulationEventCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7abb1e1354ae3258b91fc097e9d682b8"></a><!-- doxytag: member="PxScene::getSimulationStatistics" ref="7abb1e1354ae3258b91fc097e9d682b8" args="(PxSimulationStatistics &amp;stats) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::getSimulationStatistics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSimulationStatistics.html">PxSimulationStatistics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this method to retrieve statistics for the current simulation step. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Used to retrieve statistics for the current simulation step.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationStatistics.html" title="Class used to retrieve statistics for a simulation step.">PxSimulationStatistics</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd966317a1feb083e273fd8c12f454b5"></a><!-- doxytag: member="PxScene::getSolverBatchSize" ref="dd966317a1feb083e273fd8c12f454b5" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getSolverBatchSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of actors required to spawn a separate rigid body solver thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current number of actors required to spawn a separate rigid body solver thread.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#26b321b928708c10a047b38ec9127797" title="Defines the number of actors required to spawn a separate rigid body solver island...">PxSceneDesc.solverBatchSize</a> <a class="el" href="classPxScene.html#ad9cc8bf329f4de4b407436f5cd38c98" title="Sets the number of actors required to spawn a separate rigid body solver thread.">setSolverBatchSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d285bee8674cc03378588a32c4f85dda"></a><!-- doxytag: member="PxScene::getStaticStructure" ref="d285bee8674cc03378588a32c4f85dda" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxPruningStructureType.html#058454782f6ed1cc953b8d6561b636d9">PxPruningStructureType::Enum</a> PxScene::getStaticStructure           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the value of <a class="el" href="classPxSceneDesc.html#00495fa3240d1087d38cf33eebc313a7" title="Defines the structure used to store static objects.">PxSceneDesc::staticStructure</a> that was set when creating the scene with <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#00495fa3240d1087d38cf33eebc313a7" title="Defines the structure used to store static objects.">PxSceneDesc::staticStructure</a>, <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="be1495d04a1852030c0dec380999525a"></a><!-- doxytag: member="PxScene::getTaskManager" ref="be1495d04a1852030c0dec380999525a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxTaskManager* PxScene::getTaskManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the task manager associated with this scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the task manager associated with the scene </dd></dl>

</div>
</div><p>
<a class="anchor" name="6003ed1a202d434ef64439741e3f2de2"></a><!-- doxytag: member="PxScene::getTimestamp" ref="6003ed1a202d434ef64439741e3f2de2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> PxScene::getTimestamp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the scene's internal timestamp, increased each time a simulation step is completed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>scene timestamp </dd></dl>

</div>
</div><p>
<a class="anchor" name="aab5854538e05abbe83c485e9d3ec082"></a><!-- doxytag: member="PxScene::getVisualizationCullingBox" ref="aab5854538e05abbe83c485e9d3ec082" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a> PxScene::getVisualizationCullingBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the visualization culling box. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the box to which the geometry will be culled. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#4055d302466a1f5cd9d481028b66b20a" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="classPxScene.html#b562ba2df953188a7e2b99f7ddcda5dc" title="Defines a box in world space to which visualization geometry will be (conservatively)...">setVisualizationCullingBox</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c036458140a45b23facb9cf2a9cdb84"></a><!-- doxytag: member="PxScene::getVisualizationParameter" ref="7c036458140a45b23facb9cf2a9cdb84" args="(PxVisualizationParameter::Enum paramEnum) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxScene::getVisualizationParameter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>paramEnum</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that lets you query debug visualization parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>paramEnum</em>&nbsp;</td><td>The Parameter to retrieve. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the parameter.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#4055d302466a1f5cd9d481028b66b20a" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="287734b244b7ff6e40496e65d166ae95"></a><!-- doxytag: member="PxScene::getWakeCounterResetValue" ref="287734b244b7ff6e40496e65d166ae95" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxScene::getWakeCounterResetValue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the wake counter reset value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Wake counter reset value</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value.">PxSceneDesc.wakeCounterResetValue</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="088a9978be5b160b79665d4fb471ec81"></a><!-- doxytag: member="PxScene::lockRead" ref="088a9978be5b160b79665d4fb471ec81" args="(const char *file=NULL, PxU32 line=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::lockRead           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>line</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the scene for reading from the calling thread. 
<p>
When the <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c5397a4bafb1db3bba4b8ff373e16d67c5b" title="Require scene-level locking.">PxSceneFlag::eREQUIRE_RW_LOCK</a> flag is enabled <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a> must be called before any read calls are made on the scene.<p>
Multiple threads may read at the same time, no threads may read while a thread is writing. If a call to <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a> is made while another thread is holding a write lock then the calling thread will be blocked until the writing thread calls <a class="el" href="classPxScene.html#f2fa25d740641e78ae934c0488f17a4d" title="Unlock the scene from writing.">unlockWrite()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Lock upgrading is *not* supported, that means it is an error to call <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a> followed by <a class="el" href="classPxScene.html#89d45878685fa31bb2684c096d2c6918" title="Lock the scene for writing from this thread.">lockWrite()</a>.<p>
Recursive locking is supported but each <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a> call must be paired with an <a class="el" href="classPxScene.html#ca7f8e7bc71ad39645b787bc41ab8c13" title="Unlock the scene from reading.">unlockRead()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>String representing the calling file, for debug purposes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>The source file line number, for debug purposes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="89d45878685fa31bb2684c096d2c6918"></a><!-- doxytag: member="PxScene::lockWrite" ref="89d45878685fa31bb2684c096d2c6918" args="(const char *file=NULL, PxU32 line=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::lockWrite           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>line</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the scene for writing from this thread. 
<p>
When the <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c5397a4bafb1db3bba4b8ff373e16d67c5b" title="Require scene-level locking.">PxSceneFlag::eREQUIRE_RW_LOCK</a> flag is enabled <a class="el" href="classPxScene.html#89d45878685fa31bb2684c096d2c6918" title="Lock the scene for writing from this thread.">lockWrite()</a> must be called before any write calls are made on the scene.<p>
Only one thread may write at a time and no threads may read while a thread is writing. If a call to <a class="el" href="classPxScene.html#89d45878685fa31bb2684c096d2c6918" title="Lock the scene for writing from this thread.">lockWrite()</a> is made and there are other threads reading then the calling thread will be blocked until the readers complete.<p>
Writers have priority. If a thread is blocked waiting to write then subsequent calls to <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a> from other threads will be blocked until the writer completes.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If multiple threads are waiting to write then the thread that is first granted access depends on OS scheduling.<p>
Recursive locking is supported but each <a class="el" href="classPxScene.html#89d45878685fa31bb2684c096d2c6918" title="Lock the scene for writing from this thread.">lockWrite()</a> call must be paired with an <a class="el" href="classPxScene.html#f2fa25d740641e78ae934c0488f17a4d" title="Unlock the scene from writing.">unlockWrite()</a>.<p>
If a thread has already locked the scene for writing then it may call <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>String representing the calling file, for debug purposes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>The source file line number, for debug purposes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31d09c0e967f9806a1f0d5df78dfc996"></a><!-- doxytag: member="PxScene::overlap" ref="31d09c0e967f9806a1f0d5df78dfc996" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, PxOverlapCallback &amp;hitCall, const PxQueryFilterData &amp;filterData=PxQueryFilterData(), PxQueryFilterCallback *filterCall=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::overlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHitCallback.html">PxOverlapCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOverlapBuffer object or via a custom user callback implementation inheriting from PxOverlapCallback. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see <a class="el" href="structPxQueryHitType.html" title="Classification of scene query hits (intersections).">PxQueryHitType</a>).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitCall</em>&nbsp;</td><td>Overlap hit buffer or callback object used to report overlap hits. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. See <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to overlap.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if any touching or blocking hits were found or any hit was found in case <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> was specified.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>eBLOCK should not be returned from user filters for <a class="el" href="classPxScene.html#31d09c0e967f9806a1f0d5df78dfc996" title="Performs an overlap test of a given geometry against objects in the scene, returns...">overlap()</a>. Doing so will result in undefined behavior, and a warning will be issued. <p>
If the <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f98467f45e717fa0f52652f52b0ff9798">PxQueryFlag::eNO_BLOCK</a> flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g9baa3a8cad31bbb8ef666fe01b3afeb7" title="Overlap query callback.">PxOverlapCallback</a> <a class="el" href="group__scenequery.html#g54a708942a891f3321c2427d5c160750" title="Overlap query buffer.">PxOverlapBuffer</a> PxHitFlags <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f212d5f07851efca3731594eccbccfd"></a><!-- doxytag: member="PxScene::processCallbacks" ref="9f212d5f07851efca3731594eccbccfd" args="(physx::PxBaseTask *continuation)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::processCallbacks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *&nbsp;</td>
          <td class="paramname"> <em>continuation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This call processes all event callbacks in parallel. It takes a continuation task, which will be executed once all callbacks have been processed.<p>
This is a utility function to make it easier to process callbacks in parallel using the PhysX task system. It can only be used in conjunction with fetchResultsStart(...) and fetchResultsFinish(...)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>continuation</em>&nbsp;</td><td>The task that will be executed once all callbacks have been processed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d7dcd877cee092f8b57c67d79982b50"></a><!-- doxytag: member="PxScene::raycast" ref="7d7dcd877cee092f8b57c67d79982b50" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, const PxReal distance, PxRaycastCallback &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const PxQueryFilterData &amp;filterData=PxQueryFilterData(), PxQueryFilterCallback *filterCall=NULL, const PxQueryCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::raycast           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHitCallback.html">PxRaycastCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&nbsp;</td>
          <td class="paramname"> <em>hitFlags</em> = <code>PxHitFlags(PxHitFlag::eDEFAULT)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer object or via a custom user callback implementation inheriting from PxRaycastCallback. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered. <p>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in user guide article SceneQuery. User can ignore such objects by employing one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Has to be in the [0, inf) range. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitCall</em>&nbsp;</td><td>Raycast hit buffer or callback object used to report raycast hits. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitFlags</em>&nbsp;</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data passed to the filer shader. See <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="group__scenequery.html#ga1264802560d96e1740850b2e1a9856b" title="Batched query pre-filter shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g043a6549307b8fd63c96f48edafddad0" title="Batched query post-filter shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if any touching or blocking hits were found or any hit was found in case <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> was specified.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g4dbe8142d799492bd8e7c5ec70bfac41" title="Raycast query callback.">PxRaycastCallback</a> <a class="el" href="group__scenequery.html#gb21a68ce9e5a18aa742111920b75a84c" title="Raycast query buffer.">PxRaycastBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structPxQueryCache.html" title="single hit cache for scene queries.">PxQueryCache</a> <a class="el" href="structPxRaycastHit.html" title="Stores results of raycast queries.">PxRaycastHit</a> <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="61f68a8c516aea477cc5328b00c976ed"></a><!-- doxytag: member="PxScene::release" ref="61f68a8c516aea477cc5328b00c976ed" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the scene. 
<p>
Removes any actors, particle systems, and constraint shaders from this scene (if the user hasn't already done so).<p>
Be sure to not keep a reference to this object after calling release. Avoid release calls while the scene is simulating (in between <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> and <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> calls).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics.createScene()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ba76326fc73e3c5b0361568caec9267"></a><!-- doxytag: member="PxScene::removeActor" ref="6ba76326fc73e3c5b0361568caec9267" args="(PxActor &amp;actor, bool wakeOnLostTouch=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeOnLostTouch</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an actor from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the actor is not part of this scene (see <a class="el" href="classPxActor.html#2bf2e48b1960ef8e4fc1a437473bd7a3" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and an error is issued.<p>
You can not remove individual articulation links (see <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a>) from the scene. Use <a class="el" href="classPxScene.html#50992e7d29c92240d2b22ac4fe31b090" title="Removes an articulation from this scene.">removeArticulation()</a> instead.<p>
If the actor is a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> then all assigned <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> objects will get removed from the scene automatically.<p>
If the actor is in an aggregate it will be removed from the aggregate.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>Actor to remove from scene. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeOnLostTouch</em>&nbsp;</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> and <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> types.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="58d87bb19d1a3497bb2ca96eee2b2480"></a><!-- doxytag: member="PxScene::removeActors" ref="58d87bb19d1a3497bb2ca96eee2b2480" args="(PxActor *const *actors, PxU32 nbActors, bool wakeOnLostTouch=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> *const *&nbsp;</td>
          <td class="paramname"> <em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeOnLostTouch</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes actors from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If some actor is not part of this scene (see <a class="el" href="classPxActor.html#2bf2e48b1960ef8e4fc1a437473bd7a3" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the actor remove is ignored and an error is issued.<p>
You can not remove individual articulation links (see <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a>) from the scene. Use <a class="el" href="classPxScene.html#50992e7d29c92240d2b22ac4fe31b090" title="Removes an articulation from this scene.">removeArticulation()</a> instead.<p>
If the actor is a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> then all assigned <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> objects will get removed from the scene automatically.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actors</em>&nbsp;</td><td>Array of actors to add to scene. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbActors</em>&nbsp;</td><td>Number of actors in the array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeOnLostTouch</em>&nbsp;</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> and <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> types.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd705ae117336d9d56efcc8717c3f89b"></a><!-- doxytag: member="PxScene::removeAggregate" ref="bd705ae117336d9d56efcc8717c3f89b" args="(PxAggregate &amp;aggregate, bool wakeOnLostTouch=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeOnLostTouch</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an aggregate from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the aggregate is not part of this scene (see <a class="el" href="classPxAggregate.html#a70f305e7f2934d99afd74d28b0c0194" title="Retrieves the scene which this aggregate belongs to.">PxAggregate::getScene</a>), the call is ignored and an error is issued.<p>
If the aggregate contains actors, those actors are removed from the scene as well.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aggregate</em>&nbsp;</td><td>Aggregate to remove from scene. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeOnLostTouch</em>&nbsp;</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> and <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> types.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="50992e7d29c92240d2b22ac4fe31b090"></a><!-- doxytag: member="PxScene::removeArticulation" ref="50992e7d29c92240d2b22ac4fe31b090" args="(PxArticulation &amp;articulation, bool wakeOnLostTouch=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>articulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeOnLostTouch</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an articulation from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the articulation is not part of this scene (see <a class="el" href="classPxArticulation.html#fd299e63283d38910c48243e6d9755dd" title="Retrieves the scene which this articulation belongs to.">PxArticulation::getScene</a>), the call is ignored and an error is issued.<p>
If the articulation is in an aggregate it will be removed from the aggregate.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>articulation</em>&nbsp;</td><td>Articulation to remove from scene. See <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeOnLostTouch</em>&nbsp;</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> and <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> types.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a>, <a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8fff11a9236b623ae6c2e45d00c60232"></a><!-- doxytag: member="PxScene::removeBroadPhaseRegion" ref="8fff11a9236b623ae6c2e45d00c60232" args="(PxU32 handle)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::removeBroadPhaseRegion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a new broad-phase region. 
<p>
If the region still contains objects, and if those objects do not overlap any region any more, they are not automatically removed from the simulation. Instead, the <a class="el" href="classPxBroadPhaseCallback.html#b7aa03ff4a741400562bd5787a7aaca0" title="Out-of-bounds notification.">PxBroadPhaseCallback::onObjectOutOfBounds</a> notification is used for each object. Users are responsible for removing the objects from the simulation if this is the desired behavior.<p>
If the handle is invalid, or if a valid handle is removed twice, an error message is sent to the error stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handle</em>&nbsp;</td><td>Region's handle, as returned by <a class="el" href="classPxScene.html#ffbf0f147c773e2b2d58831df610b1a7" title="Adds a new broad-phase region.">PxScene::addBroadPhaseRegion</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if success </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae469799c2e23d06ce5c1079e36df953"></a><!-- doxytag: member="PxScene::resetFiltering" ref="ae469799c2e23d06ce5c1079e36df953" args="(PxRigidActor &amp;actor, PxShape *const *shapes, PxU32 shapeCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::resetFiltering           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> *const *&nbsp;</td>
          <td class="paramname"> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>shapeCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks the object to reset interactions and re-run collision filters for specified shapes in the next simulation step. 
<p>
This is a specialization of the <a class="el" href="classPxScene.html#f648aa06d19cfec20eeee278719f345c" title="Marks the object to reset interactions and re-run collision filters in the next simulation...">resetFiltering(PxActor&amp; actor)</a> method and allows to reset interactions for specific shapes of a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a>.<p>
<b>Sleeping:</b> Does wake up the actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor for which to re-evaluate interactions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>The shapes for which to re-evaluate interactions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeCount</em>&nbsp;</td><td>Number of shapes in the list.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f648aa06d19cfec20eeee278719f345c"></a><!-- doxytag: member="PxScene::resetFiltering" ref="f648aa06d19cfec20eeee278719f345c" args="(PxActor &amp;actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::resetFiltering           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks the object to reset interactions and re-run collision filters in the next simulation step. 
<p>
This call forces the object to remove all existing collision interactions, to search anew for existing contact pairs and to run the collision filters again for found collision pairs.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The operation is supported for <a class="el" href="classPxParticleBase.html" title="The particle base class represents the shared module for particle based simulation...">PxParticleBase</a> (deprecated) and <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> objects only.<p>
All persistent state of existing interactions will be lost and can not be retrieved even if the same collison pair is found again in the next step. This will mean, for example, that you will not get notified about persistent contact for such an interaction (see <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f69f6e6373fe2f024618f752c388ef6b1" title="Call contact report callback while this collision pair is in contact.">PxPairFlag::eNOTIFY_TOUCH_PERSISTS</a>), the contact pair will be interpreted as newly found instead.<p>
Lost touch contact reports will be sent for every collision pair which includes this shape, if they have been requested through <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f201281be698379417370bf7b0aeeb78e" title="Call contact report callback or trigger callback when this collision pair stops to...">PxPairFlag::eNOTIFY_TOUCH_LOST</a> or <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f517ae07b413b27ad008f766170051ae6" title="Call contact report callback when the contact force between the actors of this collision...">PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST</a>.<p>
This is an expensive operation, don't use it if you don't have to.<p>
Can be used to retrieve collision pairs that were killed by the collision filters (see <a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc58083ee697d6e40f98c73eb8f5cb5201f1ca9" title="Ignore the collision pair as long as the bounding volumes of the pair objects overlap...">PxFilterFlag::eKILL</a>)<p>
It is invalid to use this method if the actor has not been added to a scene already.<p>
It is invalid to use this method if <a class="el" href="structPxActorFlag.html#1bc4c717e79cd547bdbe09a179ee9f1d0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<b>Sleeping:</b> Does wake up the actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor for which to re-evaluate interactions.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2b103c61cc84c1df17b82266a17413f"></a><!-- doxytag: member="PxScene::sceneQueriesUpdate" ref="a2b103c61cc84c1df17b82266a17413f" args="(physx::PxBaseTask *completionTask=NULL, bool controlSimulation=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::sceneQueriesUpdate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *&nbsp;</td>
          <td class="paramname"> <em>completionTask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>controlSimulation</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes scene queries update tasks. This function will refit dirty shapes within the pruner and will execute a task to build a new AABB tree, which is build on a different thread. The new AABB tree is built based on the dynamic tree rebuild hint rate. Once the new tree is ready it will be commited in next fetchQueries call, which must be called after. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If <a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4793afa91b648fc6b1c92ff333490e7f2" title="No work is done, no update of scene queries.">PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED</a> is used, it is required to update the scene queries using this function.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completionTask</em>&nbsp;</td><td>if non-NULL, this task will have its refcount incremented in sceneQueryUpdate(), then decremented when the scene is ready to have fetchQueries called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlSimulation</em>&nbsp;</td><td>if true, the scene controls its PxTaskManager simulation state. Leave true unless the application is calling the PxTaskManager start/stopSimulation() methods itself.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4793afa91b648fc6b1c92ff333490e7f2" title="No work is done, no update of scene queries.">PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e102ec1b29dea3b588b7507561e656e"></a><!-- doxytag: member="PxScene::setBounceThresholdVelocity" ref="1e102ec1b29dea3b588b7507561e656e" args="(const PxReal t)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setBounceThresholdVelocity           </td>
          <td>(</td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the bounce threshold velocity. Collision speeds below this threshold will not cause a bounce. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#bc7769532392c8e47ec4580677145e34" title="A contact with a relative velocity below this will not bounce. A typical value for...">PxSceneDesc::bounceThresholdVelocity</a>, <a class="el" href="classPxScene.html#36f1319b6695b33823529924f389ca3e" title="Return the bounce threshold velocity.">getBounceThresholdVelocity</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c1110386fc2ffad70aa771aabc51d026"></a><!-- doxytag: member="PxScene::setBroadPhaseCallback" ref="c1110386fc2ffad70aa771aabc51d026" args="(PxBroadPhaseCallback *callback, PX_DEPRECATED PxClientID client=PX_DEFAULT_CLIENT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setBroadPhaseCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxBroadPhaseCallback.html">PxBroadPhaseCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a broad-phase user callback object. 
<p>
Multiclient behavior: unlike the <a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> that can be specified in the <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a>, this method lets the user associate additional callbacks with clients other than PX_DEFAULT_CLIENT. This way each client can register its own callback class. Each callback function has a somewhat different way of determining which clients' callbacks will be called in a certain event. Refer to the documentation of particular callback functions inside <a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> for this information.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Asynchronous broad-phase callback. See <a class="el" href="classPxBroadPhaseCallback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client to be associated with this callback.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>PxClient feature has been deprecated in PhysX version 3.4 </dd></dl>

</div>
</div><p>
<a class="anchor" name="593d339e0fd64e47fa3b68016ce723ec"></a><!-- doxytag: member="PxScene::setCCDContactModifyCallback" ref="593d339e0fd64e47fa3b68016ce723ec" args="(PxCCDContactModifyCallback *callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setCCDContactModifyCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxCCDContactModifyCallback.html">PxCCDContactModifyCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a user callback object, which receives callbacks on all CCD contacts generated for specified actors. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Asynchronous user contact modification callback. See <a class="el" href="classPxCCDContactModifyCallback.html" title="An interface class that the user can implement in order to modify CCD contact constraints...">PxCCDContactModifyCallback</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ed46505d6eac63a508c7a2d7e39cd5fb"></a><!-- doxytag: member="PxScene::setCCDMaxPasses" ref="ed46505d6eac63a508c7a2d7e39cd5fb" args="(PxU32 ccdMaxPasses)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setCCDMaxPasses           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>ccdMaxPasses</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum number of CCD passes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ccdMaxPasses</em>&nbsp;</td><td>Maximum number of CCD passes</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#65aa4ceefbbd6aebd75ea879d7c385f9" title="Maximum number of CCD passes.">PxSceneDesc.ccdMaxPasses</a> <a class="el" href="classPxScene.html#b0033036e31f91c68d520185ef6c1703" title="Gets the maximum number of CCD passes.">getCCDMaxPasses()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f61e48083f63f6fac343a3b1d8b2ddc"></a><!-- doxytag: member="PxScene::setClientBehaviorFlags" ref="6f61e48083f63f6fac343a3b1d8b2ddc" args="(PxClientID client, PxClientBehaviorFlags clientBehaviorFlags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED void PxScene::setClientBehaviorFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#295b321eb41489154df2d9dd381282d1">PxClientBehaviorFlags</a>&nbsp;</td>
          <td class="paramname"> <em>clientBehaviorFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets behavior bits for a client. 
<p>
The behavior bits are a property of a client that determine when it receives callbacks.<p>
It is permissible to change the behavior for PX_DEFAULT_CLIENT with this call. Initially all created clients, as well as PX_DEFAULT_CLIENT have all bits set to 0.<p>
Note that in addition to setting a client to listen to a particular foreign actor event type, the user must also configure actors to send that particular event type to foreign clients using <a class="el" href="classPxActor.html#d7b70236ed41524eda4c92636922d599" title="Sets the behavior bits of the actor.">PxActor::setClientBehaviorFlags()</a>.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd><a class="el" href="structPxActorClientBehaviorFlag.html" title="Multiclient behavior bit flags for actors.">PxActorClientBehaviorFlag</a> feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxClientBehaviorFlag.html" title="Behavior bit flags for simulation clients.">PxClientBehaviorFlag</a> <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12" title="An ID to identify different clients for multiclient support.">PxClientID</a> <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a> <a class="el" href="classPxScene.html#8259c90c79fb69ee62e9434eb35e0f37" title="Retrieves behavior bits for a client.">getClientBehaviorFlags()</a> <a class="el" href="classPxActor.html#d7b70236ed41524eda4c92636922d599" title="Sets the behavior bits of the actor.">PxActor::setClientBehaviorFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b42513ab6ce4137698565ca8629eea1c"></a><!-- doxytag: member="PxScene::setClothInterCollisionDistance" ref="b42513ab6ce4137698565ca8629eea1c" args="(PxF32 distance)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED void PxScene::setClothInterCollisionDistance           </td>
          <td>(</td>
          <td class="paramtype">PxF32&nbsp;</td>
          <td class="paramname"> <em>distance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the minimum separation distance for cloth inter-collision. 
<p>
Particles closer than this distance that belong to different <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> objects will be separated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>The minimum particle separation distance (default: 0.0).</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth.">PxCloth</a> objects that interact can be controlled through the filter shader, </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a>. Cloth objects with the PxClothFlag::eGPU set can only interact with other GPU simulated <a class="el" href="group__cloth.html">cloth (deprecated)</a> objects.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="7197a1ce70671bfc81e6f3088920ac16"></a><!-- doxytag: member="PxScene::setClothInterCollisionNbIterations" ref="7197a1ce70671bfc81e6f3088920ac16" args="(PxU32 nbIterations)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED void PxScene::setClothInterCollisionNbIterations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbIterations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the number of inter-collision separation iterations to perform. 
<p>
The accuracy of cloth inter-collision may be improved by increasing the number of separation passes that are performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbIterations</em>&nbsp;</td><td>The number of iterations to perform (default: 1). </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="85444db1420db29be5c0b748197b4fed"></a><!-- doxytag: member="PxScene::setClothInterCollisionStiffness" ref="85444db1420db29be5c0b748197b4fed" args="(PxF32 stiffness)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED void PxScene::setClothInterCollisionStiffness           </td>
          <td>(</td>
          <td class="paramtype">PxF32&nbsp;</td>
          <td class="paramname"> <em>stiffness</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the cloth inter-collision stiffness. 
<p>
Inter-collision stiffness controls how much two particles repel each other when they are closer than the inter-collision distance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stiffness</em>&nbsp;</td><td>Fraction of distance residual to resolve per iteration (default: 1.0). </td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>The PhysX cloth feature has been deprecated in PhysX version 3.4.1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="eec3367a4461c1ab2e552acdb8c0609e"></a><!-- doxytag: member="PxScene::setContactModifyCallback" ref="eec3367a4461c1ab2e552acdb8c0609e" args="(PxContactModifyCallback *callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setContactModifyCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a user callback object, which receives callbacks on all contacts generated for specified actors. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Asynchronous user contact modification callback. See <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6d9e986e6af967d2bd60a63a0b550c4"></a><!-- doxytag: member="PxScene::setDominanceGroupPair" ref="b6d9e986e6af967d2bd60a63a0b550c4" args="(PxDominanceGroup group1, PxDominanceGroup group2, const PxDominanceGroupPair &amp;dominance)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setDominanceGroupPair           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxDominanceGroupPair.html">PxDominanceGroupPair</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dominance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies the dominance behavior of contacts between two actors with two certain dominance groups. 
<p>
It is possible to assign each actor to a dominance groups using <a class="el" href="classPxActor.html#614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a>.<p>
With dominance groups one can have all contacts created between actors act in one direction only. This is useful, for example, if you want an object to push debris out of its way and be unaffected,while still responding physically to forces and collisions with non-debris objects.<p>
Whenever a contact between two actors (a0, a1) needs to be solved, the groups (g0, g1) of both actors are retrieved. Then the <a class="el" href="structPxDominanceGroupPair.html" title="Expresses the dominance relationship of a contact. For the time being only three...">PxDominanceGroupPair</a> setting for this group pair is retrieved with getDominanceGroupPair(g0, g1).<p>
In the contact, <a class="el" href="structPxDominanceGroupPair.html#ca0435bf44309f7b432df322c32deb8a">PxDominanceGroupPair::dominance0</a> becomes the dominance setting for a0, and <a class="el" href="structPxDominanceGroupPair.html#5767359f402fbda972c3a44e5d86aa75">PxDominanceGroupPair::dominance1</a> becomes the dominance setting for a1. A dominanceN setting of 1.0f, the default, will permit aN to be pushed or pulled by a(1-N) through the contact. A dominanceN setting of 0.0f, will however prevent aN to be pushed by a(1-N) via the contact. Thus, a <a class="el" href="structPxDominanceGroupPair.html" title="Expresses the dominance relationship of a contact. For the time being only three...">PxDominanceGroupPair</a> of (1.0f, 0.0f) makes the interaction one-way.<p>
The matrix sampled by getDominanceGroupPair(g1, g2) is initialised by default such that:<p>
if g1 == g2, then (1.0f, 1.0f) is returned if g1 &lt; g2, then (0.0f, 1.0f) is returned if g1 &gt; g2, then (1.0f, 0.0f) is returned<p>
In other words, we permit actors in higher groups to be pushed around by actors in lower groups by default.<p>
These settings should cover most applications, and in fact not overriding these settings may likely result in higher performance.<p>
It is not possible to make the matrix asymetric, or to change the diagonal. In other words:<p>
it is not possible to change (g1, g2) if (g1==g2) if you set<p>
(g1, g2) to X, then (g2, g1) will implicitly and automatically be set to ~X, where:<p>
~(1.0f, 1.0f) is (1.0f, 1.0f) ~(0.0f, 1.0f) is (1.0f, 0.0f) ~(1.0f, 0.0f) is (0.0f, 1.0f)<p>
These two restrictions are to make sure that contacts between two actors will always evaluate to the same dominance setting, regardless of the order of the actors.<p>
Dominance settings are currently specified as floats 0.0f or 1.0f because in the future we may permit arbitrary fractional settings to express 'partly-one-way' interactions.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake actors up automatically.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#951ada59fff16e5c860ccdd5f6d5a1f3" title="Samples the dominance matrix.">getDominanceGroupPair()</a> <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> <a class="el" href="structPxDominanceGroupPair.html" title="Expresses the dominance relationship of a contact. For the time being only three...">PxDominanceGroupPair</a> <a class="el" href="classPxActor.html#614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a> <a class="el" href="classPxActor.html#24602fee489b3e797ff0f82613eef755" title="Retrieves the value set with setDominanceGroup().">PxActor::getDominanceGroup()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf2322887ca4db2fdea0229a44e2892c"></a><!-- doxytag: member="PxScene::setDynamicTreeRebuildRateHint" ref="bf2322887ca4db2fdea0229a44e2892c" args="(PxU32 dynamicTreeRebuildRateHint)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setDynamicTreeRebuildRateHint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>dynamicTreeRebuildRateHint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the rebuild rate of the dynamic tree pruning structures. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dynamicTreeRebuildRateHint</em>&nbsp;</td><td>Rebuild rate of the dynamic tree pruning structures.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3" title="Hint for how much work should be done per simulation frame to rebuild the pruning...">PxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classPxScene.html#e220420fdd08f0dabee8b30f5ef2de68" title="Retrieves the rebuild rate of the dynamic tree pruning structures.">getDynamicTreeRebuildRateHint()</a> <a class="el" href="classPxScene.html#03b103772b8c06f2bf5c8192f1cb3f70" title="Forces dynamic trees to be immediately rebuilt.">forceDynamicTreeRebuild()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ab05d2a2c908d98aed4ca642c5f394d"></a><!-- doxytag: member="PxScene::setFilterShaderData" ref="5ab05d2a2c908d98aed4ca642c5f394d" args="(const void *data, PxU32 dataSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setFilterShaderData           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>dataSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the shared global filter data which will get passed into the filter shader. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is the user's responsibility to ensure that changing the shared global filter data does not change the filter output value for existing pairs. If the filter output for existing pairs does change nonetheless then such a change will not take effect until the pair gets refiltered. <a class="el" href="classPxScene.html#f648aa06d19cfec20eeee278719f345c" title="Marks the object to reset interactions and re-run collision filters in the next simulation...">resetFiltering()</a> can be used to explicitly refilter the pairs of specific objects.<p>
The provided data will get copied to internal buffers and this copy will be used for filtering calls.<p>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The shared global filter shader data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataSize</em>&nbsp;</td><td>Size of the shared global filter shader data (in bytes).</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#5d004fdc88ed31447aa57ee4f98c14ea" title="Gets the shared global filter data in use for this scene.">getFilterShaderData()</a> <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6610c08a5a92c894dcac9d658e48b7de"></a><!-- doxytag: member="PxScene::setFlag" ref="6610c08a5a92c894dcac9d658e48b7de" args="(PxSceneFlag::Enum flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53">PxSceneFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a scene flag. You can only set one flag at a time. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not all flags are mutable and changing some will result in an error. Please check <a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> to see which flags can be changed.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ff7784b4d51acf2d56b9462e256b58b"></a><!-- doxytag: member="PxScene::setFrictionType" ref="9ff7784b4d51acf2d56b9462e256b58b" args="(PxFrictionType::Enum frictionType)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setFrictionType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxFrictionType.html#603c53fd85805e2528a338252496a96b">PxFrictionType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>frictionType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the friction model. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxFrictionType.html" title="Enum for selecting the friction algorithm used for simulation.">PxFrictionType</a>, <a class="el" href="classPxSceneDesc.html#b1f18b0666adb645d92fc2f53373b1e9" title="Selects the friction algorithm to use for simulation.">PxSceneDesc::frictionType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="575ed34c73adbd61892d728a688479f3"></a><!-- doxytag: member="PxScene::setGravity" ref="575ed34c73adbd61892d728a688479f3" args="(const PxVec3 &amp;vec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setGravity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a constant gravity for the entire scene. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>A new gravity vector(e.g. <a class="el" href="classPxVec3.html" title="3 Element vector class.">PxVec3</a>(0.0f,-9.8f,0.0f) ) <b>Range:</b> force vector</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#9b0de35c38c43b8aeff6e6f29bf0db20" title="Gravity vector.">PxSceneDesc.gravity</a> <a class="el" href="classPxScene.html#6fe48dbf9144be415d63f1d2f3ce0b16" title="Retrieves the current gravity setting.">getGravity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c9025d9a26efa7b90c8c75cb7126b92"></a><!-- doxytag: member="PxScene::setLimits" ref="1c9025d9a26efa7b90c8c75cb7126b92" args="(const PxSceneLimits &amp;limits)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setLimits           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxSceneLimits.html">PxSceneLimits</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>limits</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set new scene limits. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Increase the maximum capacity of various data structures in the scene. The new capacities will be at least as large as required to deal with the objects currently in the scene. Further, these values are for preallocation and do not represent hard limits.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>limits</em>&nbsp;</td><td>Scene limits. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneLimits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits...">PxSceneLimits</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="148be23880c4e2d67f9f772066a9f966"></a><!-- doxytag: member="PxScene::setNbContactDataBlocks" ref="148be23880c4e2d67f9f772066a9f966" args="(PxU32 numBlocks)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setNbContactDataBlocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>numBlocks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set the cache blocks that can be used during <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a>. 
<p>
Each frame the simulation requires memory to store contact, friction, and contact cache data. This memory is used in blocks of 16K. Each frame the blocks used by the previous frame are freed, and may be retrieved by the application using <a class="el" href="classPxScene.html#b557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory.">PxScene::flushSimulation()</a><p>
This call will force allocation of cache blocks if the numBlocks parameter is greater than the currently allocated number of blocks, and less than the max16KContactDataBlocks parameter specified at scene creation time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numBlocks</em>&nbsp;</td><td>The number of blocks to allocate.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to define the number of 16K blocks that will be initially reserved to store...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35" title="Setting to define the maximum number of 16K blocks that can be allocated to store...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classPxScene.html#b557fc677e9549c71d36979dfd3ec8c5" title="Clear internal buffers and free memory.">flushSimulation()</a> <a class="el" href="classPxScene.html#b6224a915d459fb6a1c0899a080f5697" title="get the number of cache blocks currently used by the scene">getNbContactDataBlocksUsed</a> <a class="el" href="classPxScene.html#a3c625507d5cfaf0f1cb9d26f66be329" title="get the maximum number of cache blocks used by the scene">getMaxNbContactDataBlocksUsed</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b689efc2353e9c57abf0182cb3f7dfd"></a><!-- doxytag: member="PxScene::setSceneQueryUpdateMode" ref="8b689efc2353e9c57abf0182cb3f7dfd" args="(PxSceneQueryUpdateMode::Enum updateMode)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setSceneQueryUpdateMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>updateMode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets scene query update mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>updateMode</em>&nbsp;</td><td>Scene query update mode.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryUpdateMode.html#04e575a313bce592e2b404eedf89a9d4">PxSceneQueryUpdateMode::Enum</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="88f5438bf61cf5c3f767d8b515c51d31"></a><!-- doxytag: member="PxScene::setSimulationEventCallback" ref="88f5438bf61cf5c3f767d8b515c51d31" args="(PxSimulationEventCallback *callback, PX_DEPRECATED PxClientID client=PX_DEFAULT_CLIENT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setSimulationEventCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PX_DEPRECATED <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a user notify object which receives special simulation events when they occur. 
<p>
Multiclient behavior: unlike the <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> that can be specified in the <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a>, this method lets the user associate additional callbacks with clients other than PX_DEFAULT_CLIENT. This way each client can register its own callback class.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User notification callback. See <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client to be associated with this callback.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd><a class="el" href="structPxActorClientBehaviorFlag.html" title="Multiclient behavior bit flags for actors.">PxActorClientBehaviorFlag</a> feature has been deprecated in PhysX version 3.4</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> <a class="el" href="classPxScene.html#1eb6366fd80f5a8f6a9154a412c33436" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback()...">getSimulationEventCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad9cc8bf329f4de4b407436f5cd38c98"></a><!-- doxytag: member="PxScene::setSolverBatchSize" ref="ad9cc8bf329f4de4b407436f5cd38c98" args="(PxU32 solverBatchSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setSolverBatchSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>solverBatchSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the number of actors required to spawn a separate rigid body solver thread. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>solverBatchSize</em>&nbsp;</td><td>Number of actors required to spawn a separate rigid body solver thread.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#26b321b928708c10a047b38ec9127797" title="Defines the number of actors required to spawn a separate rigid body solver island...">PxSceneDesc.solverBatchSize</a> <a class="el" href="classPxScene.html#dd966317a1feb083e273fd8c12f454b5" title="Retrieves the number of actors required to spawn a separate rigid body solver thread...">getSolverBatchSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b562ba2df953188a7e2b99f7ddcda5dc"></a><!-- doxytag: member="PxScene::setVisualizationCullingBox" ref="b562ba2df953188a7e2b99f7ddcda5dc" args="(const PxBounds3 &amp;box)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setVisualizationCullingBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBounds3.html">PxBounds3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines a box in world space to which visualization geometry will be (conservatively) culled. Use a non-empty culling box to enable the feature, and an empty culling box to disable it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>box</em>&nbsp;</td><td>the box to which the geometry will be culled. Empty box to disable the feature. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#4055d302466a1f5cd9d481028b66b20a" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="classPxScene.html#aab5854538e05abbe83c485e9d3ec082" title="Retrieves the visualization culling box.">getVisualizationCullingBox</a> <a class="el" href="classPxScene.html#35f231796a325fcf587e681831c5fcb5" title="Retrieves the render buffer.">getRenderBuffer()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4055d302466a1f5cd9d481028b66b20a"></a><!-- doxytag: member="PxScene::setVisualizationParameter" ref="4055d302466a1f5cd9d481028b66b20a" args="(PxVisualizationParameter::Enum param, PxReal value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::setVisualizationParameter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that lets you set debug visualization parameters. 
<p>
Returns false if the value passed is out of range for usage specified by the enum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>param</em>&nbsp;</td><td>Parameter to set. See <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set, see <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> for allowable values. Setting to zero disables visualization for the specified property, setting to a positive value usually enables visualization and defines the scale factor. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False if the parameter is out of range.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#7c036458140a45b23facb9cf2a9cdb84" title="Function that lets you query debug visualization parameters.">getVisualizationParameter</a> <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> <a class="el" href="classPxScene.html#35f231796a325fcf587e681831c5fcb5" title="Retrieves the render buffer.">getRenderBuffer()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3cb2b6b3b72cefb94fa9e64ca09660f6"></a><!-- doxytag: member="PxScene::shiftOrigin" ref="3cb2b6b3b72cefb94fa9e64ca09660f6" args="(const PxVec3 &amp;shift)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::shiftOrigin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the scene origin by the specified vector. 
<p>
The poses of all objects in the scene and the corresponding data structures will get adjusted to reflect the new origin location (the shift vector will get subtracted from all object positions).<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is the user's responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysX accordingly.<p>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.<p>
Make sure to propagate the origin shift to other dependent modules (for example, the character controller module etc.).<p>
This is an expensive operation and we recommend to use it only in the case where distance related precision issues may arise in areas far from the origin.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift</em>&nbsp;</td><td>Translation vector to shift the origin by. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9a9cacecc3b0f6adaf2f3d2168c2aff5"></a><!-- doxytag: member="PxScene::simulate" ref="9a9cacecc3b0f6adaf2f3d2168c2aff5" args="(PxReal elapsedTime, physx::PxBaseTask *completionTask=NULL, void *scratchMemBlock=0, PxU32 scratchMemBlockSize=0, bool controlSimulation=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::simulate           </td>
          <td>(</td>
          <td class="paramtype">PxReal&nbsp;</td>
          <td class="paramname"> <em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1PxBaseTask.html">physx::PxBaseTask</a> *&nbsp;</td>
          <td class="paramname"> <em>completionTask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratchMemBlock</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>scratchMemBlockSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>controlSimulation</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the simulation by an elapsedTime time. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Large elapsedTime values can lead to instabilities. In such cases elapsedTime should be subdivided into smaller time intervals and <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> should be called multiple times for each interval.</dd></dl>
Calls to <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> should pair with calls to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>: Each <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> invocation corresponds to exactly one <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> invocation; calling <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> twice without an intervening <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> or <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> twice without an intervening <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a> causes an error condition.<p>
scene-&gt;<a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a>; ...do some processing until physics is computed... scene-&gt;<a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>; ...now results of run may be retrieved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elapsedTime</em>&nbsp;</td><td>Amount of time to advance simulation by. The parameter has to be larger than 0, else the resulting behavior will be undefined. <b>Range:</b> (0, PX_MAX_F32) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completionTask</em>&nbsp;</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classPxScene.html#9a9cacecc3b0f6adaf2f3d2168c2aff5" title="Advances the simulation by an elapsedTime time.">simulate()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchMemBlock</em>&nbsp;</td><td>a memory region for <a class="el" href="namespacephysx.html">physx</a> to use for temporary data during simulation. This block may be reused by the application after fetchResults returns. Must be aligned on a 16-byte boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchMemBlockSize</em>&nbsp;</td><td>the size of the scratch memory block. Must be a multiple of 16K. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlSimulation</em>&nbsp;</td><td>if true, the scene controls its PxTaskManager simulation state. Leave true unless the application is calling the PxTaskManager start/stopSimulation() methods itself.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9b07b2a98e64105a06e97ffaeba2a63d"></a><!-- doxytag: member="PxScene::sweep" ref="9b07b2a98e64105a06e97ffaeba2a63d" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSweepCallback &amp;hitCall, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const PxQueryFilterData &amp;filterData=PxQueryFilterData(), PxQueryFilterCallback *filterCall=NULL, const PxQueryCache *cache=NULL, const PxReal inflation=0.f) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::sweep           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxHitCallback.html">PxSweepCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&nbsp;</td>
          <td class="paramname"> <em>hitFlags</em> = <code>PxHitFlags(PxHitFlag::eDEFAULT)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxQueryFilterData.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxQueryFilterCallback.html">PxQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxQueryCache.html">PxQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&nbsp;</td>
          <td class="paramname"> <em>inflation</em> = <code>0.f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a sweep test against objects in the scene, returns results in a PxSweepBuffer object or via a custom user callback implementation inheriting from PxSweepCallback. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered. <p>
If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be in [0, inf) range and &gt;0 if eASSUME_NO_INITIAL_OVERLAP was specified. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitCall</em>&nbsp;</td><td>Sweep hit buffer or callback object used to report sweep hits. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitFlags</em>&nbsp;</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxQueryFlag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first. If no hit is found the sweep gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inflation</em>&nbsp;</td><td>This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal. Note: ePRECISE_SWEEP doesn't support inflation. Therefore the sweep will be performed with zero inflation.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if any touching or blocking hits were found or any hit was found in case <a class="el" href="structPxQueryFlag.html#2124ff0cff0a021e01e6880a1bba431f2837a6ac649b29ee72af661b65f4d8ab">PxQueryFlag::eANY_HIT</a> was specified.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g6f93f556cef747d50f643499928dd865" title="Sweep query callback.">PxSweepCallback</a> <a class="el" href="group__scenequery.html#gecfed2b83a930b922b3d95e22ff30665" title="Sweep query buffer.">PxSweepBuffer</a> <a class="el" href="structPxQueryFilterData.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classPxQueryFilterCallback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structPxSweepHit.html" title="Stores results of sweep queries.">PxSweepHit</a> <a class="el" href="structPxQueryCache.html" title="single hit cache for scene queries.">PxQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca7f8e7bc71ad39645b787bc41ab8c13"></a><!-- doxytag: member="PxScene::unlockRead" ref="ca7f8e7bc71ad39645b787bc41ab8c13" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::unlockRead           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock the scene from reading. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Each <a class="el" href="classPxScene.html#ca7f8e7bc71ad39645b787bc41ab8c13" title="Unlock the scene from reading.">unlockRead()</a> must be paired with a <a class="el" href="classPxScene.html#088a9978be5b160b79665d4fb471ec81" title="Lock the scene for reading from the calling thread.">lockRead()</a> from the same thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2fa25d740641e78ae934c0488f17a4d"></a><!-- doxytag: member="PxScene::unlockWrite" ref="f2fa25d740641e78ae934c0488f17a4d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::unlockWrite           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock the scene from writing. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Each <a class="el" href="classPxScene.html#f2fa25d740641e78ae934c0488f17a4d" title="Unlock the scene from writing.">unlockWrite()</a> must be paired with a <a class="el" href="classPxScene.html#89d45878685fa31bb2684c096d2c6918" title="Lock the scene for writing from this thread.">lockWrite()</a> from the same thread. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="64fbe5f25cef90d47fcb1c6428efe15a"></a><!-- doxytag: member="PxScene::userData" ref="64fbe5f25cef90d47fcb1c6428efe15a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPxScene.html#64fbe5f25cef90d47fcb1c6428efe15a">PxScene::userData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxScene_8h-source.html">PxScene.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
