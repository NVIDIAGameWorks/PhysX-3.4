<html>
	<head>
		<title>NVIDIA(R) PhysX(R) SDK 3.4 API Reference: PxConstraintConnector Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxConstraintConnector Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxConstraintConnector" -->This class connects a custom constraint to the SDK.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxConstraintDesc_8h-source.html">PxConstraintDesc.h</a>&gt;</code>
<p>

<p>
<a href="classPxConstraintConnector-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#f04ac1b3cbd43565ac99957dd9cde100">prepareData</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#c70ca90dc4055c11c76b2faf15dbb205">updatePvdProperties</a> (physx::pvdsdk::PvdDataStream &amp;pvdConnection, const <a class="el" href="classPxConstraint.html">PxConstraint</a> *c, <a class="el" href="structPxPvdUpdateType.html#534206ee246bcbd046d6eb314ebf821e">PxPvdUpdateType::Enum</a> updateType) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#9c4abc11ca607b42c8f84956392c9cdd">onConstraintRelease</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#93cb6a551c50f48d5ccec421a97cabcc">onComShift</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> actor)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#668fc9420f8dee64887f9d7dad97ed5f">onOriginShift</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;shift)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#1210c94b5fa0513b2cd99ceedccd23ee">getExternalReference</a> (<a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;typeID)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetches external data for a constraint.  <a href="#1210c94b5fa0513b2cd99ceedccd23ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxBase.html">PxBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#e924cd9415c06057a3fcd7077028baad">getSerializable</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a reference to a <a class="el" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> interface if the constraint has one.  <a href="#e924cd9415c06057a3fcd7077028baad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g538ba0a5410c612bc666bb10d44bcb7a">PxConstraintSolverPrep</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#ff598a3ab349524666e2ed79c862f3a9">getPrep</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the shader function pointer used to prep rows for this constraint.  <a href="#ff598a3ab349524666e2ed79c862f3a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#7a93655be259791a2eaf2a7d857c598d">getConstantBlock</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the pointer to the constraint's constant data.  <a href="#7a93655be259791a2eaf2a7d857c598d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxConstraintConnector.html#71f8ff017c14b26c81b06be700f015f1">~PxConstraintConnector</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">virtual destructor  <a href="#71f8ff017c14b26c81b06be700f015f1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class connects a custom constraint to the SDK. 
<p>
This class connects a custom constraint to the SDK, and functions are called by the SDK to query the custom implementation for specific information to pass on to the application or inform the constraint when the application makes calls into the SDK which will update the custom constraint's internal implementation <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="71f8ff017c14b26c81b06be700f015f1"></a><!-- doxytag: member="PxConstraintConnector::~PxConstraintConnector" ref="71f8ff017c14b26c81b06be700f015f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxConstraintConnector::~PxConstraintConnector           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
virtual destructor 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7a93655be259791a2eaf2a7d857c598d"></a><!-- doxytag: member="PxConstraintConnector::getConstantBlock" ref="7a93655be259791a2eaf2a7d857c598d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* PxConstraintConnector::getConstantBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the pointer to the constraint's constant data. 
<p>

</div>
</div><p>
<a class="anchor" name="1210c94b5fa0513b2cd99ceedccd23ee"></a><!-- doxytag: member="PxConstraintConnector::getExternalReference" ref="1210c94b5fa0513b2cd99ceedccd23ee" args="(PxU32 &amp;typeID)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* PxConstraintConnector::getExternalReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetches external data for a constraint. 
<p>
This function is used by the SDK to acquire a reference to the owner of a constraint and a unique owner type ID. This information will be passed on when a breakable constraint breaks or when <a class="el" href="classPxConstraint.html#c35d572c4d343685c120f11c8884526e" title="Fetch external owner of the constraint.">PxConstraint::getExternalReference()</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>typeID</em>&nbsp;</td><td>Unique type identifier of the external object. The value 0xffffffff is reserved and should not be used. Furthermore, if the PhysX extensions library is used, some other IDs are reserved already (see <a class="el" href="structPxConstraintExtIDs.html" title="Unique identifiers for extensions classes which implement a constraint based on PxConstraint...">PxConstraintExtIDs</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the external object which owns the constraint.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxConstraintInfo.html" title="Descriptor for a broken constraint.">PxConstraintInfo</a> <a class="el" href="classPxSimulationEventCallback.html#67c6553ee9090481ece8b041502eb948" title="This is called when a breakable constraint breaks.">PxSimulationEventCallback.onConstraintBreak()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff598a3ab349524666e2ed79c862f3a9"></a><!-- doxytag: member="PxConstraintConnector::getPrep" ref="ff598a3ab349524666e2ed79c862f3a9" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__physics.html#g538ba0a5410c612bc666bb10d44bcb7a">PxConstraintSolverPrep</a> PxConstraintConnector::getPrep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain the shader function pointer used to prep rows for this constraint. 
<p>

</div>
</div><p>
<a class="anchor" name="e924cd9415c06057a3fcd7077028baad"></a><!-- doxytag: member="PxConstraintConnector::getSerializable" ref="e924cd9415c06057a3fcd7077028baad" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBase.html">PxBase</a>* PxConstraintConnector::getSerializable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain a reference to a <a class="el" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> interface if the constraint has one. 
<p>
If the constraint does not implement the <a class="el" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> interface, it should return NULL. 
</div>
</div><p>
<a class="anchor" name="93cb6a551c50f48d5ccec421a97cabcc"></a><!-- doxytag: member="PxConstraintConnector::onComShift" ref="93cb6a551c50f48d5ccec421a97cabcc" args="(PxU32 actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxConstraintConnector::onComShift           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gcce5749db3dcfb916e98c253374264ed">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called by the SDK when the CoM of one of the actors is moved. Since the API specifies constraint positions relative to actors, and the constraint shader functions are supplied with coordinates relative to bodies, some synchronization is usually required when the application moves an object's center of mass. 
</div>
</div><p>
<a class="anchor" name="9c4abc11ca607b42c8f84956392c9cdd"></a><!-- doxytag: member="PxConstraintConnector::onConstraintRelease" ref="9c4abc11ca607b42c8f84956392c9cdd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxConstraintConnector::onConstraintRelease           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When the SDK deletes a <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object this function is called by the SDK. In general custom constraints should not be deleted directly by applications: rather, the constraint should respond to a release() request by calling <a class="el" href="classPxConstraint.html#8153c211d21fff49565e7e06e475d5cc" title="Releases a PxConstraint instance.">PxConstraint::release()</a>, then wait for this call to release its own resources, so that even if the release() call occurs during a simulation step, the deletion of the constraint is buffered until that step completes.<p>
This function is also called when a <a class="el" href="classPxConstraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object is deleted on cleanup due to destruction of the <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> object. 
</div>
</div><p>
<a class="anchor" name="668fc9420f8dee64887f9d7dad97ed5f"></a><!-- doxytag: member="PxConstraintConnector::onOriginShift" ref="668fc9420f8dee64887f9d7dad97ed5f" args="(const PxVec3 &amp;shift)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxConstraintConnector::onOriginShift           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shift</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called by the SDK when the scene origin gets shifted and allows to adjust custom data which contains world space transforms.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the adjustments affect constraint shader data, it is necessary to call <a class="el" href="classPxConstraint.html#c54f23bc7b3d52d3b5f265f6750e3199" title="Notify the scene that the constraint shader data has been updated by the application...">PxConstraint::markDirty()</a> to make sure that the data gets synced at the beginning of the next simulation step.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift</em>&nbsp;</td><td>Translation vector the origin is shifted by.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#3cb2b6b3b72cefb94fa9e64ca09660f6" title="Shift the scene origin by the specified vector.">PxScene.shiftOrigin()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f04ac1b3cbd43565ac99957dd9cde100"></a><!-- doxytag: member="PxConstraintConnector::prepareData" ref="f04ac1b3cbd43565ac99957dd9cde100" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* PxConstraintConnector::prepareData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
when the constraint is marked dirty, this function is called at the start of the simulation step for the SDK to copy the constraint data block. 
</div>
</div><p>
<a class="anchor" name="c70ca90dc4055c11c76b2faf15dbb205"></a><!-- doxytag: member="PxConstraintConnector::updatePvdProperties" ref="c70ca90dc4055c11c76b2faf15dbb205" args="(physx::pvdsdk::PvdDataStream &amp;pvdConnection, const PxConstraint *c, PxPvdUpdateType::Enum updateType) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxConstraintConnector::updatePvdProperties           </td>
          <td>(</td>
          <td class="paramtype">physx::pvdsdk::PvdDataStream &amp;&nbsp;</td>
          <td class="paramname"> <em>pvdConnection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxConstraint.html">PxConstraint</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxPvdUpdateType.html#534206ee246bcbd046d6eb314ebf821e">PxPvdUpdateType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>updateType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
this function is called by the SDK to update PVD's view of it 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxConstraintDesc_8h-source.html">PxConstraintDesc.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2018 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
