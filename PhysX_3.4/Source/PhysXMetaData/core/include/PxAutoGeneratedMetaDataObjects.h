// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2018 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.

// This code is auto-generated by the PhysX Clang metadata generator.  Do not edit or be
// prepared for your edits to be quietly ignored next time the clang metadata generator is
// run.  You can find the most recent version of clang metadata generator by contacting
// Chris Nuernberger <chrisn@nvidia.com> or Dilip or Adam.
// The source code for the generate was at one time checked into:
// physx/PhysXMetaDataGenerator/llvm/tools/clang/lib/Frontend/PhysXMetaDataAction.cpp
#define THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON

#define PX_PROPERTY_INFO_NAME PxPropertyInfoName
	static PxU32ToName g_physx__PxClothFlag__EnumConversion[] = {
		{ "eDEFAULT", static_cast<PxU32>( physx::PxClothFlag::eDEFAULT ) },
		{ "eCUDA", static_cast<PxU32>( physx::PxClothFlag::eCUDA ) },
		{ "eGPU", static_cast<PxU32>( physx::PxClothFlag::eGPU ) },
		{ "eSWEPT_CONTACT", static_cast<PxU32>( physx::PxClothFlag::eSWEPT_CONTACT ) },
		{ "eSCENE_COLLISION", static_cast<PxU32>( physx::PxClothFlag::eSCENE_COLLISION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxClothFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxClothFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxShapeFlag__EnumConversion[] = {
		{ "eSIMULATION_SHAPE", static_cast<PxU32>( physx::PxShapeFlag::eSIMULATION_SHAPE ) },
		{ "eSCENE_QUERY_SHAPE", static_cast<PxU32>( physx::PxShapeFlag::eSCENE_QUERY_SHAPE ) },
		{ "eTRIGGER_SHAPE", static_cast<PxU32>( physx::PxShapeFlag::eTRIGGER_SHAPE ) },
		{ "eVISUALIZATION", static_cast<PxU32>( physx::PxShapeFlag::eVISUALIZATION ) },
		{ "ePARTICLE_DRAIN", static_cast<PxU32>( physx::PxShapeFlag::ePARTICLE_DRAIN ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxShapeFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxShapeFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxPhysics;
	struct PxPhysicsGeneratedValues
	{
		PxTolerancesScale TolerancesScale;
		 PX_PHYSX_CORE_API PxPhysicsGeneratedValues( const PxPhysics* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPhysics, TolerancesScale, PxPhysicsGeneratedValues)
	struct PxPhysicsGeneratedInfo

	{
		static const char* getClassName() { return "PxPhysics"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_TolerancesScale, PxPhysics, const PxTolerancesScale > TolerancesScale;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_TriangleMeshes, PxPhysics, PxTriangleMesh *, PxInputStream & > TriangleMeshes;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_HeightFields, PxPhysics, PxHeightField *, PxInputStream & > HeightFields;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_ConvexMeshes, PxPhysics, PxConvexMesh *, PxInputStream & > ConvexMeshes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_ClothFabrics, PxPhysics, PxClothFabric * > ClothFabrics;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_Scenes, PxPhysics, PxScene *, const PxSceneDesc & > Scenes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_Shapes, PxPhysics, PxShape * > Shapes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_Materials, PxPhysics, PxMaterial * > Materials;

		PX_PHYSX_CORE_API PxPhysicsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxPhysics*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( TolerancesScale, inStartIndex + 0 );; 
			inOperator( TriangleMeshes, inStartIndex + 1 );; 
			inOperator( HeightFields, inStartIndex + 2 );; 
			inOperator( ConvexMeshes, inStartIndex + 3 );; 
			inOperator( ClothFabrics, inStartIndex + 4 );; 
			inOperator( Scenes, inStartIndex + 5 );; 
			inOperator( Shapes, inStartIndex + 6 );; 
			inOperator( Materials, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPhysics>
	{ 
		PxPhysicsGeneratedInfo Info;
		const PxPhysicsGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxMaterialFlag__EnumConversion[] = {
		{ "eDISABLE_FRICTION", static_cast<PxU32>( physx::PxMaterialFlag::eDISABLE_FRICTION ) },
		{ "eDISABLE_STRONG_FRICTION", static_cast<PxU32>( physx::PxMaterialFlag::eDISABLE_STRONG_FRICTION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxMaterialFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxMaterialFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxCombineMode__EnumConversion[] = {
		{ "eAVERAGE", static_cast<PxU32>( physx::PxCombineMode::eAVERAGE ) },
		{ "eMIN", static_cast<PxU32>( physx::PxCombineMode::eMIN ) },
		{ "eMULTIPLY", static_cast<PxU32>( physx::PxCombineMode::eMULTIPLY ) },
		{ "eMAX", static_cast<PxU32>( physx::PxCombineMode::eMAX ) },
		{ "eN_VALUES", static_cast<PxU32>( physx::PxCombineMode::eN_VALUES ) },
		{ "ePAD_32", static_cast<PxU32>( physx::PxCombineMode::ePAD_32 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxCombineMode::Enum > { PxEnumTraits() : NameConversion( g_physx__PxCombineMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxMaterial;
	struct PxMaterialGeneratedValues
	{
		PxU32 ReferenceCount;
		PxReal DynamicFriction;
		PxReal StaticFriction;
		PxReal Restitution;
		PxMaterialFlags Flags;
		PxCombineMode::Enum FrictionCombineMode;
		PxCombineMode::Enum RestitutionCombineMode;
		const char * ConcreteTypeName;
		void * UserData;
		 PX_PHYSX_CORE_API PxMaterialGeneratedValues( const PxMaterial* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, ReferenceCount, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, DynamicFriction, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, StaticFriction, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, Restitution, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, Flags, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, FrictionCombineMode, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, RestitutionCombineMode, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, ConcreteTypeName, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, UserData, PxMaterialGeneratedValues)
	struct PxMaterialGeneratedInfo

	{
		static const char* getClassName() { return "PxMaterial"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_ReferenceCount, PxMaterial, PxU32 > ReferenceCount;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_DynamicFriction, PxMaterial, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_StaticFriction, PxMaterial, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_Restitution, PxMaterial, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_Flags, PxMaterial, PxMaterialFlags, PxMaterialFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_FrictionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > FrictionCombineMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_RestitutionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > RestitutionCombineMode;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_ConcreteTypeName, PxMaterial, const char * > ConcreteTypeName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_UserData, PxMaterial, void *, void * > UserData;

		PX_PHYSX_CORE_API PxMaterialGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxMaterial*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( ReferenceCount, inStartIndex + 0 );; 
			inOperator( DynamicFriction, inStartIndex + 1 );; 
			inOperator( StaticFriction, inStartIndex + 2 );; 
			inOperator( Restitution, inStartIndex + 3 );; 
			inOperator( Flags, inStartIndex + 4 );; 
			inOperator( FrictionCombineMode, inStartIndex + 5 );; 
			inOperator( RestitutionCombineMode, inStartIndex + 6 );; 
			inOperator( ConcreteTypeName, inStartIndex + 7 );; 
			inOperator( UserData, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMaterial>
	{ 
		PxMaterialGeneratedInfo Info;
		const PxMaterialGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxActorType__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( physx::PxActorType::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( physx::PxActorType::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( physx::PxActorType::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( physx::PxActorType::ePARTICLE_FLUID ) },
		{ "eARTICULATION_LINK", static_cast<PxU32>( physx::PxActorType::eARTICULATION_LINK ) },
		{ "eCLOTH", static_cast<PxU32>( physx::PxActorType::eCLOTH ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxActorFlag__EnumConversion[] = {
		{ "eVISUALIZATION", static_cast<PxU32>( physx::PxActorFlag::eVISUALIZATION ) },
		{ "eDISABLE_GRAVITY", static_cast<PxU32>( physx::PxActorFlag::eDISABLE_GRAVITY ) },
		{ "eSEND_SLEEP_NOTIFIES", static_cast<PxU32>( physx::PxActorFlag::eSEND_SLEEP_NOTIFIES ) },
		{ "eDISABLE_SIMULATION", static_cast<PxU32>( physx::PxActorFlag::eDISABLE_SIMULATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxActorClientBehaviorFlag__EnumConversion[] = {
		{ "eREPORT_TO_FOREIGN_CLIENTS_TRIGGER_NOTIFY", static_cast<PxU32>( physx::PxActorClientBehaviorFlag::eREPORT_TO_FOREIGN_CLIENTS_TRIGGER_NOTIFY ) },
		{ "eREPORT_TO_FOREIGN_CLIENTS_CONTACT_NOTIFY", static_cast<PxU32>( physx::PxActorClientBehaviorFlag::eREPORT_TO_FOREIGN_CLIENTS_CONTACT_NOTIFY ) },
		{ "eREPORT_TO_FOREIGN_CLIENTS_CONSTRAINT_BREAK_NOTIFY", static_cast<PxU32>( physx::PxActorClientBehaviorFlag::eREPORT_TO_FOREIGN_CLIENTS_CONSTRAINT_BREAK_NOTIFY ) },
		{ "eREPORT_TO_FOREIGN_CLIENTS_SCENE_QUERY", static_cast<PxU32>( physx::PxActorClientBehaviorFlag::eREPORT_TO_FOREIGN_CLIENTS_SCENE_QUERY ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorClientBehaviorFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorClientBehaviorFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxActor;
	struct PxActorGeneratedValues
	{
		PxScene * Scene;
		const char * Name;
		PxActorFlags ActorFlags;
		PxDominanceGroup DominanceGroup;
		PxClientID OwnerClient;
		PxActorClientBehaviorFlags ClientBehaviorFlags;
		PxAggregate * Aggregate;
		void * UserData;
		 PX_PHYSX_CORE_API PxActorGeneratedValues( const PxActor* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Scene, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Name, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ActorFlags, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, DominanceGroup, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, OwnerClient, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ClientBehaviorFlags, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Aggregate, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, UserData, PxActorGeneratedValues)
	struct PxActorGeneratedInfo

	{
		static const char* getClassName() { return "PxActor"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Scene, PxActor, PxScene * > Scene;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Name, PxActor, const char *, const char * > Name;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ActorFlags, PxActor, PxActorFlags, PxActorFlags > ActorFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_DominanceGroup, PxActor, PxDominanceGroup, PxDominanceGroup > DominanceGroup;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_OwnerClient, PxActor, PxClientID, PxClientID > OwnerClient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ClientBehaviorFlags, PxActor, PxActorClientBehaviorFlags, PxActorClientBehaviorFlags > ClientBehaviorFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Aggregate, PxActor, PxAggregate * > Aggregate;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_UserData, PxActor, void *, void * > UserData;

		PX_PHYSX_CORE_API PxActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxActor*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( Name, inStartIndex + 1 );; 
			inOperator( ActorFlags, inStartIndex + 2 );; 
			inOperator( DominanceGroup, inStartIndex + 3 );; 
			inOperator( OwnerClient, inStartIndex + 4 );; 
			inOperator( ClientBehaviorFlags, inStartIndex + 5 );; 
			inOperator( Aggregate, inStartIndex + 6 );; 
			inOperator( UserData, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxActor>
	{ 
		PxActorGeneratedInfo Info;
		const PxActorGeneratedInfo* getInfo() { return &Info; }
	};

	class PxRigidActor;
	struct PxRigidActorGeneratedValues
		: PxActorGeneratedValues	{
		PxTransform GlobalPose;
		 PX_PHYSX_CORE_API PxRigidActorGeneratedValues( const PxRigidActor* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidActor, GlobalPose, PxRigidActorGeneratedValues)
	struct PxRigidActorGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidActor"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_GlobalPose, PxRigidActor, const PxTransform &, PxTransform > GlobalPose;
		PxRigidActorShapeCollection Shapes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_Constraints, PxRigidActor, PxConstraint * > Constraints;

		PX_PHYSX_CORE_API PxRigidActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxRigidActor*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( GlobalPose, inStartIndex + 0 );; 
			inOperator( Shapes, inStartIndex + 1 );; 
			inOperator( Constraints, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidActor>
	{ 
		PxRigidActorGeneratedInfo Info;
		const PxRigidActorGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxForceMode__EnumConversion[] = {
		{ "eFORCE", static_cast<PxU32>( physx::PxForceMode::eFORCE ) },
		{ "eIMPULSE", static_cast<PxU32>( physx::PxForceMode::eIMPULSE ) },
		{ "eVELOCITY_CHANGE", static_cast<PxU32>( physx::PxForceMode::eVELOCITY_CHANGE ) },
		{ "eACCELERATION", static_cast<PxU32>( physx::PxForceMode::eACCELERATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxForceMode::Enum > { PxEnumTraits() : NameConversion( g_physx__PxForceMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxRigidBodyFlag__EnumConversion[] = {
		{ "eKINEMATIC", static_cast<PxU32>( physx::PxRigidBodyFlag::eKINEMATIC ) },
		{ "eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES", static_cast<PxU32>( physx::PxRigidBodyFlag::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES ) },
		{ "eENABLE_CCD", static_cast<PxU32>( physx::PxRigidBodyFlag::eENABLE_CCD ) },
		{ "eENABLE_CCD_FRICTION", static_cast<PxU32>( physx::PxRigidBodyFlag::eENABLE_CCD_FRICTION ) },
		{ "eENABLE_POSE_INTEGRATION_PREVIEW", static_cast<PxU32>( physx::PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW ) },
		{ "eENABLE_SPECULATIVE_CCD", static_cast<PxU32>( physx::PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD ) },
		{ "eENABLE_CCD_MAX_CONTACT_IMPULSE", static_cast<PxU32>( physx::PxRigidBodyFlag::eENABLE_CCD_MAX_CONTACT_IMPULSE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxRigidBodyFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxRigidBodyFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidBody;
	struct PxRigidBodyGeneratedValues
		: PxRigidActorGeneratedValues	{
		PxTransform CMassLocalPose;
		PxReal Mass;
		PxReal InvMass;
		PxVec3 MassSpaceInertiaTensor;
		PxVec3 MassSpaceInvInertiaTensor;
		PxVec3 LinearVelocity;
		PxVec3 AngularVelocity;
		PxRigidBodyFlags RigidBodyFlags;
		PxReal MinCCDAdvanceCoefficient;
		PxReal MaxDepenetrationVelocity;
		PxReal MaxContactImpulse;
		 PX_PHYSX_CORE_API PxRigidBodyGeneratedValues( const PxRigidBody* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, CMassLocalPose, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, Mass, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, InvMass, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MassSpaceInertiaTensor, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MassSpaceInvInertiaTensor, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, LinearVelocity, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, AngularVelocity, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, RigidBodyFlags, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MinCCDAdvanceCoefficient, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MaxDepenetrationVelocity, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MaxContactImpulse, PxRigidBodyGeneratedValues)
	struct PxRigidBodyGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidBody"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_CMassLocalPose, PxRigidBody, const PxTransform &, PxTransform > CMassLocalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_Mass, PxRigidBody, PxReal, PxReal > Mass;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_InvMass, PxRigidBody, PxReal > InvMass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MassSpaceInertiaTensor, PxRigidBody, const PxVec3 &, PxVec3 > MassSpaceInertiaTensor;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MassSpaceInvInertiaTensor, PxRigidBody, PxVec3 > MassSpaceInvInertiaTensor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_LinearVelocity, PxRigidBody, const PxVec3 &, PxVec3 > LinearVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_AngularVelocity, PxRigidBody, const PxVec3 &, PxVec3 > AngularVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_RigidBodyFlags, PxRigidBody, PxRigidBodyFlags, PxRigidBodyFlags > RigidBodyFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MinCCDAdvanceCoefficient, PxRigidBody, PxReal, PxReal > MinCCDAdvanceCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MaxDepenetrationVelocity, PxRigidBody, PxReal, PxReal > MaxDepenetrationVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MaxContactImpulse, PxRigidBody, PxReal, PxReal > MaxContactImpulse;

		PX_PHYSX_CORE_API PxRigidBodyGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxRigidBody*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 11; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( CMassLocalPose, inStartIndex + 0 );; 
			inOperator( Mass, inStartIndex + 1 );; 
			inOperator( InvMass, inStartIndex + 2 );; 
			inOperator( MassSpaceInertiaTensor, inStartIndex + 3 );; 
			inOperator( MassSpaceInvInertiaTensor, inStartIndex + 4 );; 
			inOperator( LinearVelocity, inStartIndex + 5 );; 
			inOperator( AngularVelocity, inStartIndex + 6 );; 
			inOperator( RigidBodyFlags, inStartIndex + 7 );; 
			inOperator( MinCCDAdvanceCoefficient, inStartIndex + 8 );; 
			inOperator( MaxDepenetrationVelocity, inStartIndex + 9 );; 
			inOperator( MaxContactImpulse, inStartIndex + 10 );; 
			return 11 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidBody>
	{ 
		PxRigidBodyGeneratedInfo Info;
		const PxRigidBodyGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxRigidDynamicLockFlag__EnumConversion[] = {
		{ "eLOCK_LINEAR_X", static_cast<PxU32>( physx::PxRigidDynamicLockFlag::eLOCK_LINEAR_X ) },
		{ "eLOCK_LINEAR_Y", static_cast<PxU32>( physx::PxRigidDynamicLockFlag::eLOCK_LINEAR_Y ) },
		{ "eLOCK_LINEAR_Z", static_cast<PxU32>( physx::PxRigidDynamicLockFlag::eLOCK_LINEAR_Z ) },
		{ "eLOCK_ANGULAR_X", static_cast<PxU32>( physx::PxRigidDynamicLockFlag::eLOCK_ANGULAR_X ) },
		{ "eLOCK_ANGULAR_Y", static_cast<PxU32>( physx::PxRigidDynamicLockFlag::eLOCK_ANGULAR_Y ) },
		{ "eLOCK_ANGULAR_Z", static_cast<PxU32>( physx::PxRigidDynamicLockFlag::eLOCK_ANGULAR_Z ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxRigidDynamicLockFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxRigidDynamicLockFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidDynamic;
	struct PxRigidDynamicGeneratedValues
		: PxRigidBodyGeneratedValues	{
		PxReal LinearDamping;
		PxReal AngularDamping;
		PxReal MaxAngularVelocity;
		_Bool IsSleeping;
		PxReal SleepThreshold;
		PxReal StabilizationThreshold;
		PxRigidDynamicLockFlags RigidDynamicLockFlags;
		PxReal WakeCounter;
		PxU32 SolverIterationCounts[2];
		PxReal ContactReportThreshold;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxRigidDynamicGeneratedValues( const PxRigidDynamic* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, LinearDamping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, AngularDamping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, MaxAngularVelocity, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, IsSleeping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, SleepThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, StabilizationThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, RigidDynamicLockFlags, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, WakeCounter, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, SolverIterationCounts, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, ContactReportThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, ConcreteTypeName, PxRigidDynamicGeneratedValues)
	struct PxRigidDynamicGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidDynamic"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_LinearDamping, PxRigidDynamic, PxReal, PxReal > LinearDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_AngularDamping, PxRigidDynamic, PxReal, PxReal > AngularDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_MaxAngularVelocity, PxRigidDynamic, PxReal, PxReal > MaxAngularVelocity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_IsSleeping, PxRigidDynamic, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_SleepThreshold, PxRigidDynamic, PxReal, PxReal > SleepThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_StabilizationThreshold, PxRigidDynamic, PxReal, PxReal > StabilizationThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_RigidDynamicLockFlags, PxRigidDynamic, PxRigidDynamicLockFlags, PxRigidDynamicLockFlags > RigidDynamicLockFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_WakeCounter, PxRigidDynamic, PxReal, PxReal > WakeCounter;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_SolverIterationCounts, PxRigidDynamic, PxU32 > SolverIterationCounts;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_ContactReportThreshold, PxRigidDynamic, PxReal, PxReal > ContactReportThreshold;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_ConcreteTypeName, PxRigidDynamic, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxRigidDynamicGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxRigidDynamic*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 11; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidBodyGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( LinearDamping, inStartIndex + 0 );; 
			inOperator( AngularDamping, inStartIndex + 1 );; 
			inOperator( MaxAngularVelocity, inStartIndex + 2 );; 
			inOperator( IsSleeping, inStartIndex + 3 );; 
			inOperator( SleepThreshold, inStartIndex + 4 );; 
			inOperator( StabilizationThreshold, inStartIndex + 5 );; 
			inOperator( RigidDynamicLockFlags, inStartIndex + 6 );; 
			inOperator( WakeCounter, inStartIndex + 7 );; 
			inOperator( SolverIterationCounts, inStartIndex + 8 );; 
			inOperator( ContactReportThreshold, inStartIndex + 9 );; 
			inOperator( ConcreteTypeName, inStartIndex + 10 );; 
			return 11 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidDynamic>
	{ 
		PxRigidDynamicGeneratedInfo Info;
		const PxRigidDynamicGeneratedInfo* getInfo() { return &Info; }
	};

	class PxRigidStatic;
	struct PxRigidStaticGeneratedValues
		: PxRigidActorGeneratedValues	{
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxRigidStaticGeneratedValues( const PxRigidStatic* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidStatic, ConcreteTypeName, PxRigidStaticGeneratedValues)
	struct PxRigidStaticGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidStatic"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidStatic_ConcreteTypeName, PxRigidStatic, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxRigidStaticGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxRigidStatic*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( ConcreteTypeName, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidStatic>
	{ 
		PxRigidStaticGeneratedInfo Info;
		const PxRigidStaticGeneratedInfo* getInfo() { return &Info; }
	};

	class PxArticulationLink;
	struct PxArticulationLinkGeneratedValues
		: PxRigidBodyGeneratedValues	{
		PxArticulationJoint * InboundJoint;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxArticulationLinkGeneratedValues( const PxArticulationLink* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationLink, InboundJoint, PxArticulationLinkGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationLink, ConcreteTypeName, PxArticulationLinkGeneratedValues)
	struct PxArticulationLinkGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxArticulationLink"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_InboundJoint, PxArticulationLink, PxArticulationJoint * > InboundJoint;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_Children, PxArticulationLink, PxArticulationLink * > Children;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_ConcreteTypeName, PxArticulationLink, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxArticulationLinkGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxArticulationLink*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidBodyGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( InboundJoint, inStartIndex + 0 );; 
			inOperator( Children, inStartIndex + 1 );; 
			inOperator( ConcreteTypeName, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationLink>
	{ 
		PxArticulationLinkGeneratedInfo Info;
		const PxArticulationLinkGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxArticulationJointDriveType__EnumConversion[] = {
		{ "eTARGET", static_cast<PxU32>( physx::PxArticulationJointDriveType::eTARGET ) },
		{ "eERROR", static_cast<PxU32>( physx::PxArticulationJointDriveType::eERROR ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxArticulationJointDriveType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxArticulationJointDriveType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxArticulationJoint;
	struct PxArticulationJointGeneratedValues
	{
		PxTransform ParentPose;
		PxTransform ChildPose;
		PxQuat TargetOrientation;
		PxVec3 TargetVelocity;
		PxArticulationJointDriveType::Enum DriveType;
		PxReal Stiffness;
		PxReal Damping;
		PxReal InternalCompliance;
		PxReal ExternalCompliance;
		PxReal SwingLimit[2];
		PxReal TangentialStiffness;
		PxReal TangentialDamping;
		PxReal SwingLimitContactDistance;
		_Bool SwingLimitEnabled;
		PxReal TwistLimit[2];
		_Bool TwistLimitEnabled;
		PxReal TwistLimitContactDistance;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxArticulationJointGeneratedValues( const PxArticulationJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ParentPose, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ChildPose, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TargetOrientation, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TargetVelocity, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, DriveType, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, Stiffness, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, Damping, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, InternalCompliance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ExternalCompliance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimit, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TangentialStiffness, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TangentialDamping, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimitContactDistance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimitEnabled, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimit, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimitEnabled, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimitContactDistance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ConcreteTypeName, PxArticulationJointGeneratedValues)
	struct PxArticulationJointGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulationJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ParentPose, PxArticulationJoint, const PxTransform &, PxTransform > ParentPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ChildPose, PxArticulationJoint, const PxTransform &, PxTransform > ChildPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TargetOrientation, PxArticulationJoint, const PxQuat &, PxQuat > TargetOrientation;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TargetVelocity, PxArticulationJoint, const PxVec3 &, PxVec3 > TargetVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_DriveType, PxArticulationJoint, PxArticulationJointDriveType::Enum, PxArticulationJointDriveType::Enum > DriveType;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_Stiffness, PxArticulationJoint, PxReal, PxReal > Stiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_Damping, PxArticulationJoint, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_InternalCompliance, PxArticulationJoint, PxReal, PxReal > InternalCompliance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ExternalCompliance, PxArticulationJoint, PxReal, PxReal > ExternalCompliance;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimit, PxArticulationJoint, PxReal > SwingLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TangentialStiffness, PxArticulationJoint, PxReal, PxReal > TangentialStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TangentialDamping, PxArticulationJoint, PxReal, PxReal > TangentialDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimitContactDistance, PxArticulationJoint, PxReal, PxReal > SwingLimitContactDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimitEnabled, PxArticulationJoint, _Bool, _Bool > SwingLimitEnabled;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimit, PxArticulationJoint, PxReal > TwistLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimitEnabled, PxArticulationJoint, _Bool, _Bool > TwistLimitEnabled;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimitContactDistance, PxArticulationJoint, PxReal, PxReal > TwistLimitContactDistance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ConcreteTypeName, PxArticulationJoint, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxArticulationJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxArticulationJoint*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 18; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( ParentPose, inStartIndex + 0 );; 
			inOperator( ChildPose, inStartIndex + 1 );; 
			inOperator( TargetOrientation, inStartIndex + 2 );; 
			inOperator( TargetVelocity, inStartIndex + 3 );; 
			inOperator( DriveType, inStartIndex + 4 );; 
			inOperator( Stiffness, inStartIndex + 5 );; 
			inOperator( Damping, inStartIndex + 6 );; 
			inOperator( InternalCompliance, inStartIndex + 7 );; 
			inOperator( ExternalCompliance, inStartIndex + 8 );; 
			inOperator( SwingLimit, inStartIndex + 9 );; 
			inOperator( TangentialStiffness, inStartIndex + 10 );; 
			inOperator( TangentialDamping, inStartIndex + 11 );; 
			inOperator( SwingLimitContactDistance, inStartIndex + 12 );; 
			inOperator( SwingLimitEnabled, inStartIndex + 13 );; 
			inOperator( TwistLimit, inStartIndex + 14 );; 
			inOperator( TwistLimitEnabled, inStartIndex + 15 );; 
			inOperator( TwistLimitContactDistance, inStartIndex + 16 );; 
			inOperator( ConcreteTypeName, inStartIndex + 17 );; 
			return 18 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationJoint>
	{ 
		PxArticulationJointGeneratedInfo Info;
		const PxArticulationJointGeneratedInfo* getInfo() { return &Info; }
	};

	class PxArticulation;
	struct PxArticulationGeneratedValues
	{
		PxScene * Scene;
		PxU32 MaxProjectionIterations;
		PxReal SeparationTolerance;
		PxU32 InternalDriveIterations;
		PxU32 ExternalDriveIterations;
		PxU32 SolverIterationCounts[2];
		_Bool IsSleeping;
		PxReal SleepThreshold;
		PxReal StabilizationThreshold;
		PxReal WakeCounter;
		const char * Name;
		PxAggregate * Aggregate;
		const char * ConcreteTypeName;
		void * UserData;
		 PX_PHYSX_CORE_API PxArticulationGeneratedValues( const PxArticulation* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Scene, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, MaxProjectionIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SeparationTolerance, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, InternalDriveIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, ExternalDriveIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SolverIterationCounts, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, IsSleeping, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SleepThreshold, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, StabilizationThreshold, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, WakeCounter, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Name, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Aggregate, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, ConcreteTypeName, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, UserData, PxArticulationGeneratedValues)
	struct PxArticulationGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulation"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Scene, PxArticulation, PxScene * > Scene;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_MaxProjectionIterations, PxArticulation, PxU32, PxU32 > MaxProjectionIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SeparationTolerance, PxArticulation, PxReal, PxReal > SeparationTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_InternalDriveIterations, PxArticulation, PxU32, PxU32 > InternalDriveIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_ExternalDriveIterations, PxArticulation, PxU32, PxU32 > ExternalDriveIterations;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SolverIterationCounts, PxArticulation, PxU32 > SolverIterationCounts;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_IsSleeping, PxArticulation, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SleepThreshold, PxArticulation, PxReal, PxReal > SleepThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_StabilizationThreshold, PxArticulation, PxReal, PxReal > StabilizationThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_WakeCounter, PxArticulation, PxReal, PxReal > WakeCounter;
		PxArticulationLinkCollectionProp Links;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Name, PxArticulation, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Aggregate, PxArticulation, PxAggregate * > Aggregate;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_ConcreteTypeName, PxArticulation, const char * > ConcreteTypeName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_UserData, PxArticulation, void *, void * > UserData;

		PX_PHYSX_CORE_API PxArticulationGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxArticulation*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 15; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( MaxProjectionIterations, inStartIndex + 1 );; 
			inOperator( SeparationTolerance, inStartIndex + 2 );; 
			inOperator( InternalDriveIterations, inStartIndex + 3 );; 
			inOperator( ExternalDriveIterations, inStartIndex + 4 );; 
			inOperator( SolverIterationCounts, inStartIndex + 5 );; 
			inOperator( IsSleeping, inStartIndex + 6 );; 
			inOperator( SleepThreshold, inStartIndex + 7 );; 
			inOperator( StabilizationThreshold, inStartIndex + 8 );; 
			inOperator( WakeCounter, inStartIndex + 9 );; 
			inOperator( Links, inStartIndex + 10 );; 
			inOperator( Name, inStartIndex + 11 );; 
			inOperator( Aggregate, inStartIndex + 12 );; 
			inOperator( ConcreteTypeName, inStartIndex + 13 );; 
			inOperator( UserData, inStartIndex + 14 );; 
			return 15 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulation>
	{ 
		PxArticulationGeneratedInfo Info;
		const PxArticulationGeneratedInfo* getInfo() { return &Info; }
	};

	class PxAggregate;
	struct PxAggregateGeneratedValues
	{
		PxU32 MaxNbActors;
		_Bool SelfCollision;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxAggregateGeneratedValues( const PxAggregate* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxAggregate, MaxNbActors, PxAggregateGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxAggregate, SelfCollision, PxAggregateGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxAggregate, ConcreteTypeName, PxAggregateGeneratedValues)
	struct PxAggregateGeneratedInfo

	{
		static const char* getClassName() { return "PxAggregate"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_MaxNbActors, PxAggregate, PxU32 > MaxNbActors;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_Actors, PxAggregate, PxActor * > Actors;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_SelfCollision, PxAggregate, _Bool > SelfCollision;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_ConcreteTypeName, PxAggregate, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxAggregateGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxAggregate*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( MaxNbActors, inStartIndex + 0 );; 
			inOperator( Actors, inStartIndex + 1 );; 
			inOperator( SelfCollision, inStartIndex + 2 );; 
			inOperator( ConcreteTypeName, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxAggregate>
	{ 
		PxAggregateGeneratedInfo Info;
		const PxAggregateGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxConstraintFlag__EnumConversion[] = {
		{ "eBROKEN", static_cast<PxU32>( physx::PxConstraintFlag::eBROKEN ) },
		{ "ePROJECT_TO_ACTOR0", static_cast<PxU32>( physx::PxConstraintFlag::ePROJECT_TO_ACTOR0 ) },
		{ "ePROJECT_TO_ACTOR1", static_cast<PxU32>( physx::PxConstraintFlag::ePROJECT_TO_ACTOR1 ) },
		{ "ePROJECTION", static_cast<PxU32>( physx::PxConstraintFlag::ePROJECTION ) },
		{ "eCOLLISION_ENABLED", static_cast<PxU32>( physx::PxConstraintFlag::eCOLLISION_ENABLED ) },
		{ "eVISUALIZATION", static_cast<PxU32>( physx::PxConstraintFlag::eVISUALIZATION ) },
		{ "eDRIVE_LIMITS_ARE_FORCES", static_cast<PxU32>( physx::PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES ) },
		{ "eIMPROVED_SLERP", static_cast<PxU32>( physx::PxConstraintFlag::eIMPROVED_SLERP ) },
		{ "eDISABLE_PREPROCESSING", static_cast<PxU32>( physx::PxConstraintFlag::eDISABLE_PREPROCESSING ) },
		{ "eGPU_COMPATIBLE", static_cast<PxU32>( physx::PxConstraintFlag::eGPU_COMPATIBLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxConstraintFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxConstraintFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxConstraint;
	struct PxConstraintGeneratedValues
	{
		PxScene * Scene;
		PxRigidActor * Actors[2];
		PxConstraintFlags Flags;
		_Bool IsValid;
		PxReal BreakForce[2];
		PxReal MinResponseThreshold;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxConstraintGeneratedValues( const PxConstraint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Scene, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Actors, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Flags, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, IsValid, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, BreakForce, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, MinResponseThreshold, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, ConcreteTypeName, PxConstraintGeneratedValues)
	struct PxConstraintGeneratedInfo

	{
		static const char* getClassName() { return "PxConstraint"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Scene, PxConstraint, PxScene * > Scene;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Actors, PxConstraint, PxRigidActor * > Actors;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Flags, PxConstraint, PxConstraintFlags, PxConstraintFlags > Flags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_IsValid, PxConstraint, _Bool > IsValid;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_BreakForce, PxConstraint, PxReal > BreakForce;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_MinResponseThreshold, PxConstraint, PxReal, PxReal > MinResponseThreshold;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_ConcreteTypeName, PxConstraint, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxConstraintGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxConstraint*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 7; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( Actors, inStartIndex + 1 );; 
			inOperator( Flags, inStartIndex + 2 );; 
			inOperator( IsValid, inStartIndex + 3 );; 
			inOperator( BreakForce, inStartIndex + 4 );; 
			inOperator( MinResponseThreshold, inStartIndex + 5 );; 
			inOperator( ConcreteTypeName, inStartIndex + 6 );; 
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConstraint>
	{ 
		PxConstraintGeneratedInfo Info;
		const PxConstraintGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxGeometryType__EnumConversion[] = {
		{ "eSPHERE", static_cast<PxU32>( physx::PxGeometryType::eSPHERE ) },
		{ "ePLANE", static_cast<PxU32>( physx::PxGeometryType::ePLANE ) },
		{ "eCAPSULE", static_cast<PxU32>( physx::PxGeometryType::eCAPSULE ) },
		{ "eBOX", static_cast<PxU32>( physx::PxGeometryType::eBOX ) },
		{ "eCONVEXMESH", static_cast<PxU32>( physx::PxGeometryType::eCONVEXMESH ) },
		{ "eTRIANGLEMESH", static_cast<PxU32>( physx::PxGeometryType::eTRIANGLEMESH ) },
		{ "eHEIGHTFIELD", static_cast<PxU32>( physx::PxGeometryType::eHEIGHTFIELD ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxGeometryType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxGeometryType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxShape;
	struct PxShapeGeneratedValues
	{
		PxGeometryType::Enum GeometryType;
		PxGeometryHolder Geometry;
		PxTransform LocalPose;
		PxFilterData SimulationFilterData;
		PxFilterData QueryFilterData;
		PxReal ContactOffset;
		PxReal RestOffset;
		PxShapeFlags Flags;
		_Bool IsExclusive;
		const char * Name;
		const char * ConcreteTypeName;
		void * UserData;
		 PX_PHYSX_CORE_API PxShapeGeneratedValues( const PxShape* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, GeometryType, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Geometry, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, LocalPose, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, SimulationFilterData, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, QueryFilterData, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, ContactOffset, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, RestOffset, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Flags, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, IsExclusive, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Name, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, ConcreteTypeName, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, UserData, PxShapeGeneratedValues)
	struct PxShapeGeneratedInfo

	{
		static const char* getClassName() { return "PxShape"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_GeometryType, PxShape, PxGeometryType::Enum > GeometryType;
		PxShapeGeometryProperty Geometry;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_LocalPose, PxShape, const PxTransform &, PxTransform > LocalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_SimulationFilterData, PxShape, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_QueryFilterData, PxShape, const PxFilterData &, PxFilterData > QueryFilterData;
		PxShapeMaterialsProperty Materials;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_ContactOffset, PxShape, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_RestOffset, PxShape, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_Flags, PxShape, PxShapeFlags, PxShapeFlags > Flags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_IsExclusive, PxShape, _Bool > IsExclusive;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_Name, PxShape, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_ConcreteTypeName, PxShape, const char * > ConcreteTypeName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_UserData, PxShape, void *, void * > UserData;

		PX_PHYSX_CORE_API PxShapeGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxShape*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 13; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( GeometryType, inStartIndex + 0 );; 
			inOperator( Geometry, inStartIndex + 1 );; 
			inOperator( LocalPose, inStartIndex + 2 );; 
			inOperator( SimulationFilterData, inStartIndex + 3 );; 
			inOperator( QueryFilterData, inStartIndex + 4 );; 
			inOperator( Materials, inStartIndex + 5 );; 
			inOperator( ContactOffset, inStartIndex + 6 );; 
			inOperator( RestOffset, inStartIndex + 7 );; 
			inOperator( Flags, inStartIndex + 8 );; 
			inOperator( IsExclusive, inStartIndex + 9 );; 
			inOperator( Name, inStartIndex + 10 );; 
			inOperator( ConcreteTypeName, inStartIndex + 11 );; 
			inOperator( UserData, inStartIndex + 12 );; 
			return 13 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxShape>
	{ 
		PxShapeGeneratedInfo Info;
		const PxShapeGeneratedInfo* getInfo() { return &Info; }
	};

	class PxClothFabric;
	struct PxClothFabricGeneratedValues
	{
		PxU32 NbParticles;
		PxU32 ReferenceCount;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxClothFabricGeneratedValues( const PxClothFabric* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabric, NbParticles, PxClothFabricGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabric, ReferenceCount, PxClothFabricGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabric, ConcreteTypeName, PxClothFabricGeneratedValues)
	struct PxClothFabricGeneratedInfo

	{
		static const char* getClassName() { return "PxClothFabric"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_NbParticles, PxClothFabric, PxU32 > NbParticles;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Phases, PxClothFabric, PxClothFabricPhase > Phases;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Sets, PxClothFabric, PxU32 > Sets;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_ParticleIndices, PxClothFabric, PxU32 > ParticleIndices;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Restvalues, PxClothFabric, PxReal > Restvalues;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_ReferenceCount, PxClothFabric, PxU32 > ReferenceCount;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_ConcreteTypeName, PxClothFabric, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxClothFabricGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothFabric*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 7; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( NbParticles, inStartIndex + 0 );; 
			inOperator( Phases, inStartIndex + 1 );; 
			inOperator( Sets, inStartIndex + 2 );; 
			inOperator( ParticleIndices, inStartIndex + 3 );; 
			inOperator( Restvalues, inStartIndex + 4 );; 
			inOperator( ReferenceCount, inStartIndex + 5 );; 
			inOperator( ConcreteTypeName, inStartIndex + 6 );; 
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothFabric>
	{ 
		PxClothFabricGeneratedInfo Info;
		const PxClothFabricGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxDataAccessFlag__EnumConversion[] = {
		{ "eREADABLE", static_cast<PxU32>( physx::PxDataAccessFlag::eREADABLE ) },
		{ "eWRITABLE", static_cast<PxU32>( physx::PxDataAccessFlag::eWRITABLE ) },
		{ "eDEVICE", static_cast<PxU32>( physx::PxDataAccessFlag::eDEVICE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxDataAccessFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxDataAccessFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxClothFabricPhaseType__EnumConversion[] = {
		{ "eVERTICAL", static_cast<PxU32>( physx::PxClothFabricPhaseType::eVERTICAL ) },
		{ "eHORIZONTAL", static_cast<PxU32>( physx::PxClothFabricPhaseType::eHORIZONTAL ) },
		{ "eBENDING", static_cast<PxU32>( physx::PxClothFabricPhaseType::eBENDING ) },
		{ "eSHEARING", static_cast<PxU32>( physx::PxClothFabricPhaseType::eSHEARING ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxClothFabricPhaseType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxClothFabricPhaseType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxCloth;
	struct PxClothGeneratedValues
		: PxActorGeneratedValues	{
		PxU32 NbParticles;
		PxClothFlags ClothFlags;
		PxTransform GlobalPose;
		PxReal SolverFrequency;
		PxReal PreviousTimeStep;
		PxReal StiffnessFrequency;
		PxVec3 LinearInertiaScale;
		PxVec3 AngularInertiaScale;
		PxVec3 CentrifugalInertiaScale;
		PxVec3 DampingCoefficient;
		PxVec3 LinearDragCoefficient;
		PxVec3 AngularDragCoefficient;
		PxVec3 ExternalAcceleration;
		PxVec3 WindVelocity;
		PxReal WindDrag;
		PxReal WindLift;
		PxClothMotionConstraintConfig MotionConstraintConfig;
		PxClothStretchConfig StretchConfig[physx::PxClothFabricPhaseType::eCOUNT];
		PxClothTetherConfig TetherConfig;
		PxReal FrictionCoefficient;
		PxReal CollisionMassScale;
		PxReal SelfCollisionDistance;
		PxReal SelfCollisionStiffness;
		PxFilterData SimulationFilterData;
		PxReal ContactOffset;
		PxReal RestOffset;
		PxReal SleepLinearVelocity;
		PxReal WakeCounter;
		_Bool IsSleeping;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxClothGeneratedValues( const PxCloth* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, NbParticles, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ClothFlags, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, GlobalPose, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SolverFrequency, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, PreviousTimeStep, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, StiffnessFrequency, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, LinearInertiaScale, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, AngularInertiaScale, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, CentrifugalInertiaScale, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, DampingCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, LinearDragCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, AngularDragCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ExternalAcceleration, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, WindVelocity, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, WindDrag, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, WindLift, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, MotionConstraintConfig, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, StretchConfig, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, TetherConfig, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, FrictionCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, CollisionMassScale, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SelfCollisionDistance, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SelfCollisionStiffness, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SimulationFilterData, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ContactOffset, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, RestOffset, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SleepLinearVelocity, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, WakeCounter, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, IsSleeping, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ConcreteTypeName, PxClothGeneratedValues)
	struct PxClothGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxCloth"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_NbParticles, PxCloth, PxU32 > NbParticles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ClothFlags, PxCloth, PxClothFlags, PxClothFlags > ClothFlags;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_TargetPose, PxCloth, const PxTransform & > TargetPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_GlobalPose, PxCloth, const PxTransform &, PxTransform > GlobalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SolverFrequency, PxCloth, PxReal, PxReal > SolverFrequency;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_PreviousTimeStep, PxCloth, PxReal > PreviousTimeStep;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_StiffnessFrequency, PxCloth, PxReal, PxReal > StiffnessFrequency;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_LinearInertiaScale, PxCloth, PxVec3, PxVec3 > LinearInertiaScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_AngularInertiaScale, PxCloth, PxVec3, PxVec3 > AngularInertiaScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_CentrifugalInertiaScale, PxCloth, PxVec3, PxVec3 > CentrifugalInertiaScale;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_InertiaScale, PxCloth, PxReal > InertiaScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_DampingCoefficient, PxCloth, PxVec3, PxVec3 > DampingCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_LinearDragCoefficient, PxCloth, PxVec3, PxVec3 > LinearDragCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_AngularDragCoefficient, PxCloth, PxVec3, PxVec3 > AngularDragCoefficient;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_DragCoefficient, PxCloth, PxReal > DragCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ExternalAcceleration, PxCloth, PxVec3, PxVec3 > ExternalAcceleration;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_WindVelocity, PxCloth, PxVec3, PxVec3 > WindVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_WindDrag, PxCloth, PxReal, PxReal > WindDrag;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_WindLift, PxCloth, PxReal, PxReal > WindLift;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_MotionConstraintConfig, PxCloth, const PxClothMotionConstraintConfig &, PxClothMotionConstraintConfig > MotionConstraintConfig;
		PxIndexedPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_StretchConfig, PxCloth, PxClothFabricPhaseType::Enum, PxClothStretchConfig > StretchConfig;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_TetherConfig, PxCloth, const PxClothTetherConfig &, PxClothTetherConfig > TetherConfig;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_FrictionCoefficient, PxCloth, PxReal, PxReal > FrictionCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_CollisionMassScale, PxCloth, PxReal, PxReal > CollisionMassScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SelfCollisionDistance, PxCloth, PxReal, PxReal > SelfCollisionDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SelfCollisionStiffness, PxCloth, PxReal, PxReal > SelfCollisionStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SimulationFilterData, PxCloth, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ContactOffset, PxCloth, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_RestOffset, PxCloth, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SleepLinearVelocity, PxCloth, PxReal, PxReal > SleepLinearVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_WakeCounter, PxCloth, PxReal, PxReal > WakeCounter;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_IsSleeping, PxCloth, _Bool > IsSleeping;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ConcreteTypeName, PxCloth, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxClothGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxCloth*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 33; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( NbParticles, inStartIndex + 0 );; 
			inOperator( ClothFlags, inStartIndex + 1 );; 
			inOperator( TargetPose, inStartIndex + 2 );; 
			inOperator( GlobalPose, inStartIndex + 3 );; 
			inOperator( SolverFrequency, inStartIndex + 4 );; 
			inOperator( PreviousTimeStep, inStartIndex + 5 );; 
			inOperator( StiffnessFrequency, inStartIndex + 6 );; 
			inOperator( LinearInertiaScale, inStartIndex + 7 );; 
			inOperator( AngularInertiaScale, inStartIndex + 8 );; 
			inOperator( CentrifugalInertiaScale, inStartIndex + 9 );; 
			inOperator( InertiaScale, inStartIndex + 10 );; 
			inOperator( DampingCoefficient, inStartIndex + 11 );; 
			inOperator( LinearDragCoefficient, inStartIndex + 12 );; 
			inOperator( AngularDragCoefficient, inStartIndex + 13 );; 
			inOperator( DragCoefficient, inStartIndex + 14 );; 
			inOperator( ExternalAcceleration, inStartIndex + 15 );; 
			inOperator( WindVelocity, inStartIndex + 16 );; 
			inOperator( WindDrag, inStartIndex + 17 );; 
			inOperator( WindLift, inStartIndex + 18 );; 
			inOperator( MotionConstraintConfig, inStartIndex + 19 );; 
			inOperator( StretchConfig, inStartIndex + 20 );; 
			inOperator( TetherConfig, inStartIndex + 21 );; 
			inOperator( FrictionCoefficient, inStartIndex + 22 );; 
			inOperator( CollisionMassScale, inStartIndex + 23 );; 
			inOperator( SelfCollisionDistance, inStartIndex + 24 );; 
			inOperator( SelfCollisionStiffness, inStartIndex + 25 );; 
			inOperator( SimulationFilterData, inStartIndex + 26 );; 
			inOperator( ContactOffset, inStartIndex + 27 );; 
			inOperator( RestOffset, inStartIndex + 28 );; 
			inOperator( SleepLinearVelocity, inStartIndex + 29 );; 
			inOperator( WakeCounter, inStartIndex + 30 );; 
			inOperator( IsSleeping, inStartIndex + 31 );; 
			inOperator( ConcreteTypeName, inStartIndex + 32 );; 
			return 33 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxCloth>
	{ 
		PxClothGeneratedInfo Info;
		const PxClothGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxParticleBaseFlag__EnumConversion[] = {
		{ "eCOLLISION_TWOWAY", static_cast<PxU32>( physx::PxParticleBaseFlag::eCOLLISION_TWOWAY ) },
		{ "eCOLLISION_WITH_DYNAMIC_ACTORS", static_cast<PxU32>( physx::PxParticleBaseFlag::eCOLLISION_WITH_DYNAMIC_ACTORS ) },
		{ "eENABLED", static_cast<PxU32>( physx::PxParticleBaseFlag::eENABLED ) },
		{ "ePROJECT_TO_PLANE", static_cast<PxU32>( physx::PxParticleBaseFlag::ePROJECT_TO_PLANE ) },
		{ "ePER_PARTICLE_REST_OFFSET", static_cast<PxU32>( physx::PxParticleBaseFlag::ePER_PARTICLE_REST_OFFSET ) },
		{ "ePER_PARTICLE_COLLISION_CACHE_HINT", static_cast<PxU32>( physx::PxParticleBaseFlag::ePER_PARTICLE_COLLISION_CACHE_HINT ) },
		{ "eGPU", static_cast<PxU32>( physx::PxParticleBaseFlag::eGPU ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxParticleBaseFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxParticleBaseFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxParticleReadDataFlag__EnumConversion[] = {
		{ "ePOSITION_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::ePOSITION_BUFFER ) },
		{ "eVELOCITY_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eVELOCITY_BUFFER ) },
		{ "eREST_OFFSET_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eREST_OFFSET_BUFFER ) },
		{ "eFLAGS_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eFLAGS_BUFFER ) },
		{ "eCOLLISION_NORMAL_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eCOLLISION_NORMAL_BUFFER ) },
		{ "eCOLLISION_VELOCITY_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eCOLLISION_VELOCITY_BUFFER ) },
		{ "eDENSITY_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eDENSITY_BUFFER ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxParticleReadDataFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxParticleReadDataFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxParticleBase;
	struct PxParticleBaseGeneratedValues
		: PxActorGeneratedValues	{
		PxReal Damping;
		PxVec3 ExternalAcceleration;
		PxReal ParticleMass;
		PxReal Restitution;
		PxReal DynamicFriction;
		PxReal StaticFriction;
		PxFilterData SimulationFilterData;
		PxParticleBaseFlags ParticleBaseFlags;
		PxU32 MaxParticles;
		PxReal MaxMotionDistance;
		PxReal RestOffset;
		PxReal ContactOffset;
		PxReal GridSize;
		PxParticleReadDataFlags ParticleReadDataFlags;
		PxMetaDataPlane ProjectionPlane;
		 PX_PHYSX_CORE_API PxParticleBaseGeneratedValues( const PxParticleBase* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, Damping, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ExternalAcceleration, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleMass, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, Restitution, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, DynamicFriction, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, StaticFriction, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, SimulationFilterData, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleBaseFlags, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, MaxParticles, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, MaxMotionDistance, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, RestOffset, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ContactOffset, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, GridSize, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleReadDataFlags, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ProjectionPlane, PxParticleBaseGeneratedValues)
	struct PxParticleBaseGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleBase"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_Damping, PxParticleBase, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ExternalAcceleration, PxParticleBase, const PxVec3 &, PxVec3 > ExternalAcceleration;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleMass, PxParticleBase, PxReal, PxReal > ParticleMass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_Restitution, PxParticleBase, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_DynamicFriction, PxParticleBase, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_StaticFriction, PxParticleBase, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_SimulationFilterData, PxParticleBase, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleBaseFlags, PxParticleBase, PxParticleBaseFlags > ParticleBaseFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_MaxParticles, PxParticleBase, PxU32 > MaxParticles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_MaxMotionDistance, PxParticleBase, PxReal, PxReal > MaxMotionDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_RestOffset, PxParticleBase, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ContactOffset, PxParticleBase, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_GridSize, PxParticleBase, PxReal, PxReal > GridSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleReadDataFlags, PxParticleBase, PxParticleReadDataFlags > ParticleReadDataFlags;
		ProjectionPlaneProperty ProjectionPlane;

		PX_PHYSX_CORE_API PxParticleBaseGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxParticleBase*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 15; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Damping, inStartIndex + 0 );; 
			inOperator( ExternalAcceleration, inStartIndex + 1 );; 
			inOperator( ParticleMass, inStartIndex + 2 );; 
			inOperator( Restitution, inStartIndex + 3 );; 
			inOperator( DynamicFriction, inStartIndex + 4 );; 
			inOperator( StaticFriction, inStartIndex + 5 );; 
			inOperator( SimulationFilterData, inStartIndex + 6 );; 
			inOperator( ParticleBaseFlags, inStartIndex + 7 );; 
			inOperator( MaxParticles, inStartIndex + 8 );; 
			inOperator( MaxMotionDistance, inStartIndex + 9 );; 
			inOperator( RestOffset, inStartIndex + 10 );; 
			inOperator( ContactOffset, inStartIndex + 11 );; 
			inOperator( GridSize, inStartIndex + 12 );; 
			inOperator( ParticleReadDataFlags, inStartIndex + 13 );; 
			inOperator( ProjectionPlane, inStartIndex + 14 );; 
			return 15 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleBase>
	{ 
		PxParticleBaseGeneratedInfo Info;
		const PxParticleBaseGeneratedInfo* getInfo() { return &Info; }
	};

	class PxParticleFluid;
	struct PxParticleFluidGeneratedValues
		: PxParticleBaseGeneratedValues	{
		PxReal Stiffness;
		PxReal Viscosity;
		PxReal RestParticleDistance;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxParticleFluidGeneratedValues( const PxParticleFluid* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, Stiffness, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, Viscosity, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, RestParticleDistance, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, ConcreteTypeName, PxParticleFluidGeneratedValues)
	struct PxParticleFluidGeneratedInfo
		: PxParticleBaseGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleFluid"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_Stiffness, PxParticleFluid, PxReal, PxReal > Stiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_Viscosity, PxParticleFluid, PxReal, PxReal > Viscosity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_RestParticleDistance, PxParticleFluid, PxReal, PxReal > RestParticleDistance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_ConcreteTypeName, PxParticleFluid, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxParticleFluidGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxParticleFluid*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxParticleBaseGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxParticleBaseGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxParticleBaseGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxParticleBaseGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Stiffness, inStartIndex + 0 );; 
			inOperator( Viscosity, inStartIndex + 1 );; 
			inOperator( RestParticleDistance, inStartIndex + 2 );; 
			inOperator( ConcreteTypeName, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleFluid>
	{ 
		PxParticleFluidGeneratedInfo Info;
		const PxParticleFluidGeneratedInfo* getInfo() { return &Info; }
	};

	class PxParticleSystem;
	struct PxParticleSystemGeneratedValues
		: PxParticleBaseGeneratedValues	{
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxParticleSystemGeneratedValues( const PxParticleSystem* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleSystem, ConcreteTypeName, PxParticleSystemGeneratedValues)
	struct PxParticleSystemGeneratedInfo
		: PxParticleBaseGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleSystem"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleSystem_ConcreteTypeName, PxParticleSystem, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxParticleSystemGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxParticleSystem*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxParticleBaseGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxParticleBaseGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxParticleBaseGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxParticleBaseGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( ConcreteTypeName, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleSystem>
	{ 
		PxParticleSystemGeneratedInfo Info;
		const PxParticleSystemGeneratedInfo* getInfo() { return &Info; }
	};

	class PxPruningStructure;
	struct PxPruningStructureGeneratedValues
	{
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxPruningStructureGeneratedValues( const PxPruningStructure* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPruningStructure, ConcreteTypeName, PxPruningStructureGeneratedValues)
	struct PxPruningStructureGeneratedInfo

	{
		static const char* getClassName() { return "PxPruningStructure"; }
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPruningStructure_RigidActors, PxPruningStructure, PxRigidActor * > RigidActors;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxPruningStructure_ConcreteTypeName, PxPruningStructure, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxPruningStructureGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxPruningStructure*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( RigidActors, inStartIndex + 0 );; 
			inOperator( ConcreteTypeName, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPruningStructure>
	{ 
		PxPruningStructureGeneratedInfo Info;
		const PxPruningStructureGeneratedInfo* getInfo() { return &Info; }
	};

	class PxTolerancesScale;
	struct PxTolerancesScaleGeneratedValues
	{
		_Bool IsValid;
		PxReal Length;
		PxReal Mass;
		PxReal Speed;
		 PX_PHYSX_CORE_API PxTolerancesScaleGeneratedValues( const PxTolerancesScale* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, IsValid, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Length, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Mass, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Speed, PxTolerancesScaleGeneratedValues)
	struct PxTolerancesScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxTolerancesScale"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_IsValid, PxTolerancesScale, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Length, PxTolerancesScale, PxReal, PxReal > Length;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Mass, PxTolerancesScale, PxReal, PxReal > Mass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Speed, PxTolerancesScale, PxReal, PxReal > Speed;

		PX_PHYSX_CORE_API PxTolerancesScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxTolerancesScale*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Length, inStartIndex + 1 );; 
			inOperator( Mass, inStartIndex + 2 );; 
			inOperator( Speed, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTolerancesScale>
	{ 
		PxTolerancesScaleGeneratedInfo Info;
		const PxTolerancesScaleGeneratedInfo* getInfo() { return &Info; }
	};

	class PxGeometry;
	struct PxGeometryGeneratedValues
	{
		 PX_PHYSX_CORE_API PxGeometryGeneratedValues( const PxGeometry* inSource );
	};
	struct PxGeometryGeneratedInfo

	{
		static const char* getClassName() { return "PxGeometry"; }

		PX_PHYSX_CORE_API PxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxGeometry>
	{ 
		PxGeometryGeneratedInfo Info;
		const PxGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	class PxBoxGeometry;
	struct PxBoxGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxVec3 HalfExtents;
		 PX_PHYSX_CORE_API PxBoxGeometryGeneratedValues( const PxBoxGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxBoxGeometry, HalfExtents, PxBoxGeometryGeneratedValues)
	struct PxBoxGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxBoxGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxBoxGeometry_HalfExtents, PxBoxGeometry, PxVec3, PxVec3 > HalfExtents;

		PX_PHYSX_CORE_API PxBoxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxBoxGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( HalfExtents, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxBoxGeometry>
	{ 
		PxBoxGeometryGeneratedInfo Info;
		const PxBoxGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	class PxCapsuleGeometry;
	struct PxCapsuleGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxReal Radius;
		PxReal HalfHeight;
		 PX_PHYSX_CORE_API PxCapsuleGeometryGeneratedValues( const PxCapsuleGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, Radius, PxCapsuleGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, HalfHeight, PxCapsuleGeometryGeneratedValues)
	struct PxCapsuleGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxCapsuleGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_Radius, PxCapsuleGeometry, PxReal, PxReal > Radius;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_HalfHeight, PxCapsuleGeometry, PxReal, PxReal > HalfHeight;

		PX_PHYSX_CORE_API PxCapsuleGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxCapsuleGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Radius, inStartIndex + 0 );; 
			inOperator( HalfHeight, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxCapsuleGeometry>
	{ 
		PxCapsuleGeometryGeneratedInfo Info;
		const PxCapsuleGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	class PxMeshScale;
	struct PxMeshScaleGeneratedValues
	{
		PxVec3 Scale;
		PxQuat Rotation;
		 PX_PHYSX_CORE_API PxMeshScaleGeneratedValues( const PxMeshScale* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Scale, PxMeshScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Rotation, PxMeshScaleGeneratedValues)
	struct PxMeshScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxMeshScale"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Scale, PxMeshScale, PxVec3, PxVec3 > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Rotation, PxMeshScale, PxQuat, PxQuat > Rotation;

		PX_PHYSX_CORE_API PxMeshScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxMeshScale*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( Rotation, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMeshScale>
	{ 
		PxMeshScaleGeneratedInfo Info;
		const PxMeshScaleGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxConvexMeshGeometryFlag__EnumConversion[] = {
		{ "eTIGHT_BOUNDS", static_cast<PxU32>( physx::PxConvexMeshGeometryFlag::eTIGHT_BOUNDS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxConvexMeshGeometryFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxConvexMeshGeometryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxConvexMeshGeometry;
	struct PxConvexMeshGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxMeshScale Scale;
		PxConvexMesh * ConvexMesh;
		PxReal MaxMargin;
		PxConvexMeshGeometryFlags MeshFlags;
		 PX_PHYSX_CORE_API PxConvexMeshGeometryGeneratedValues( const PxConvexMeshGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, Scale, PxConvexMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, ConvexMesh, PxConvexMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, MaxMargin, PxConvexMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, MeshFlags, PxConvexMeshGeometryGeneratedValues)
	struct PxConvexMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxConvexMeshGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_Scale, PxConvexMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_ConvexMesh, PxConvexMeshGeometry, PxConvexMesh *, PxConvexMesh * > ConvexMesh;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_MaxMargin, PxConvexMeshGeometry, PxReal, PxReal > MaxMargin;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_MeshFlags, PxConvexMeshGeometry, PxConvexMeshGeometryFlags, PxConvexMeshGeometryFlags > MeshFlags;

		PX_PHYSX_CORE_API PxConvexMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxConvexMeshGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( ConvexMesh, inStartIndex + 1 );; 
			inOperator( MaxMargin, inStartIndex + 2 );; 
			inOperator( MeshFlags, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConvexMeshGeometry>
	{ 
		PxConvexMeshGeometryGeneratedInfo Info;
		const PxConvexMeshGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	class PxSphereGeometry;
	struct PxSphereGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxReal Radius;
		 PX_PHYSX_CORE_API PxSphereGeometryGeneratedValues( const PxSphereGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphereGeometry, Radius, PxSphereGeometryGeneratedValues)
	struct PxSphereGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxSphereGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphereGeometry_Radius, PxSphereGeometry, PxReal, PxReal > Radius;

		PX_PHYSX_CORE_API PxSphereGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxSphereGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Radius, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSphereGeometry>
	{ 
		PxSphereGeometryGeneratedInfo Info;
		const PxSphereGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	class PxPlaneGeometry;
	struct PxPlaneGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		 PX_PHYSX_CORE_API PxPlaneGeometryGeneratedValues( const PxPlaneGeometry* inSource );
	};
	struct PxPlaneGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxPlaneGeometry"; }

		PX_PHYSX_CORE_API PxPlaneGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxPlaneGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPlaneGeometry>
	{ 
		PxPlaneGeometryGeneratedInfo Info;
		const PxPlaneGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxMeshGeometryFlag__EnumConversion[] = {
		{ "eDOUBLE_SIDED", static_cast<PxU32>( physx::PxMeshGeometryFlag::eDOUBLE_SIDED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxMeshGeometryFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxMeshGeometryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxTriangleMeshGeometry;
	struct PxTriangleMeshGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxMeshScale Scale;
		PxMeshGeometryFlags MeshFlags;
		PxTriangleMesh * TriangleMesh;
		 PX_PHYSX_CORE_API PxTriangleMeshGeometryGeneratedValues( const PxTriangleMeshGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, Scale, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, MeshFlags, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, TriangleMesh, PxTriangleMeshGeometryGeneratedValues)
	struct PxTriangleMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxTriangleMeshGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_Scale, PxTriangleMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_MeshFlags, PxTriangleMeshGeometry, PxMeshGeometryFlags, PxMeshGeometryFlags > MeshFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_TriangleMesh, PxTriangleMeshGeometry, PxTriangleMesh *, PxTriangleMesh * > TriangleMesh;

		PX_PHYSX_CORE_API PxTriangleMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxTriangleMeshGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( MeshFlags, inStartIndex + 1 );; 
			inOperator( TriangleMesh, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTriangleMeshGeometry>
	{ 
		PxTriangleMeshGeometryGeneratedInfo Info;
		const PxTriangleMeshGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	class PxHeightFieldGeometry;
	struct PxHeightFieldGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxHeightField * HeightField;
		PxReal HeightScale;
		PxReal RowScale;
		PxReal ColumnScale;
		PxMeshGeometryFlags HeightFieldFlags;
		 PX_PHYSX_CORE_API PxHeightFieldGeometryGeneratedValues( const PxHeightFieldGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightField, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, RowScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, ColumnScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightFieldFlags, PxHeightFieldGeometryGeneratedValues)
	struct PxHeightFieldGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxHeightFieldGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightField, PxHeightFieldGeometry, PxHeightField *, PxHeightField * > HeightField;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightScale, PxHeightFieldGeometry, PxReal, PxReal > HeightScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_RowScale, PxHeightFieldGeometry, PxReal, PxReal > RowScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_ColumnScale, PxHeightFieldGeometry, PxReal, PxReal > ColumnScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightFieldFlags, PxHeightFieldGeometry, PxMeshGeometryFlags, PxMeshGeometryFlags > HeightFieldFlags;

		PX_PHYSX_CORE_API PxHeightFieldGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxHeightFieldGeometry*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( HeightField, inStartIndex + 0 );; 
			inOperator( HeightScale, inStartIndex + 1 );; 
			inOperator( RowScale, inStartIndex + 2 );; 
			inOperator( ColumnScale, inStartIndex + 3 );; 
			inOperator( HeightFieldFlags, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldGeometry>
	{ 
		PxHeightFieldGeometryGeneratedInfo Info;
		const PxHeightFieldGeometryGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxHeightFieldFormat__EnumConversion[] = {
		{ "eS16_TM", static_cast<PxU32>( physx::PxHeightFieldFormat::eS16_TM ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxHeightFieldFormat::Enum > { PxEnumTraits() : NameConversion( g_physx__PxHeightFieldFormat__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxHeightFieldFlag__EnumConversion[] = {
		{ "eNO_BOUNDARY_EDGES", static_cast<PxU32>( physx::PxHeightFieldFlag::eNO_BOUNDARY_EDGES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxHeightFieldFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxHeightFieldFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxHeightFieldDesc;
	struct PxHeightFieldDescGeneratedValues
	{
		PxU32 NbRows;
		PxU32 NbColumns;
		PxHeightFieldFormat::Enum Format;
		PxStridedData Samples;
		PxReal Thickness;
		PxReal ConvexEdgeThreshold;
		PxHeightFieldFlags Flags;
		 PX_PHYSX_CORE_API PxHeightFieldDescGeneratedValues( const PxHeightFieldDesc* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, NbRows, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, NbColumns, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Format, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Samples, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Thickness, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, ConvexEdgeThreshold, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Flags, PxHeightFieldDescGeneratedValues)
	struct PxHeightFieldDescGeneratedInfo

	{
		static const char* getClassName() { return "PxHeightFieldDesc"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_NbRows, PxHeightFieldDesc, PxU32, PxU32 > NbRows;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_NbColumns, PxHeightFieldDesc, PxU32, PxU32 > NbColumns;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Format, PxHeightFieldDesc, PxHeightFieldFormat::Enum, PxHeightFieldFormat::Enum > Format;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Samples, PxHeightFieldDesc, PxStridedData, PxStridedData > Samples;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Thickness, PxHeightFieldDesc, PxReal, PxReal > Thickness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_ConvexEdgeThreshold, PxHeightFieldDesc, PxReal, PxReal > ConvexEdgeThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Flags, PxHeightFieldDesc, PxHeightFieldFlags, PxHeightFieldFlags > Flags;

		PX_PHYSX_CORE_API PxHeightFieldDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxHeightFieldDesc*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 7; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( NbRows, inStartIndex + 0 );; 
			inOperator( NbColumns, inStartIndex + 1 );; 
			inOperator( Format, inStartIndex + 2 );; 
			inOperator( Samples, inStartIndex + 3 );; 
			inOperator( Thickness, inStartIndex + 4 );; 
			inOperator( ConvexEdgeThreshold, inStartIndex + 5 );; 
			inOperator( Flags, inStartIndex + 6 );; 
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldDesc>
	{ 
		PxHeightFieldDescGeneratedInfo Info;
		const PxHeightFieldDescGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxSceneFlag__EnumConversion[] = {
		{ "eENABLE_ACTIVE_ACTORS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_ACTIVE_ACTORS ) },
		{ "eENABLE_ACTIVETRANSFORMS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_ACTIVETRANSFORMS ) },
		{ "eENABLE_CCD", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_CCD ) },
		{ "eDISABLE_CCD_RESWEEP", static_cast<PxU32>( physx::PxSceneFlag::eDISABLE_CCD_RESWEEP ) },
		{ "eADAPTIVE_FORCE", static_cast<PxU32>( physx::PxSceneFlag::eADAPTIVE_FORCE ) },
		{ "eENABLE_KINEMATIC_STATIC_PAIRS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS ) },
		{ "eENABLE_KINEMATIC_PAIRS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_KINEMATIC_PAIRS ) },
		{ "eENABLE_PCM", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_PCM ) },
		{ "eDISABLE_CONTACT_REPORT_BUFFER_RESIZE", static_cast<PxU32>( physx::PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE ) },
		{ "eDISABLE_CONTACT_CACHE", static_cast<PxU32>( physx::PxSceneFlag::eDISABLE_CONTACT_CACHE ) },
		{ "eREQUIRE_RW_LOCK", static_cast<PxU32>( physx::PxSceneFlag::eREQUIRE_RW_LOCK ) },
		{ "eENABLE_STABILIZATION", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_STABILIZATION ) },
		{ "eENABLE_AVERAGE_POINT", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_AVERAGE_POINT ) },
		{ "eDEPRECATED_TRIGGER_TRIGGER_REPORTS", static_cast<PxU32>( physx::PxSceneFlag::eDEPRECATED_TRIGGER_TRIGGER_REPORTS ) },
		{ "eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS", static_cast<PxU32>( physx::PxSceneFlag::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS ) },
		{ "eSUPPRESS_EAGER_SCENE_QUERY_REFIT", static_cast<PxU32>( physx::PxSceneFlag::eSUPPRESS_EAGER_SCENE_QUERY_REFIT ) },
		{ "eENABLE_GPU_DYNAMICS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_GPU_DYNAMICS ) },
		{ "eENABLE_ENHANCED_DETERMINISM", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_ENHANCED_DETERMINISM ) },
		{ "eMUTABLE_FLAGS", static_cast<PxU32>( physx::PxSceneFlag::eMUTABLE_FLAGS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSceneFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxSceneFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxActorTypeFlag__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( physx::PxActorTypeFlag::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( physx::PxActorTypeFlag::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( physx::PxActorTypeFlag::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( physx::PxActorTypeFlag::ePARTICLE_FLUID ) },
		{ "eCLOTH", static_cast<PxU32>( physx::PxActorTypeFlag::eCLOTH ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorTypeFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorTypeFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxClientBehaviorFlag__EnumConversion[] = {
		{ "eREPORT_FOREIGN_OBJECTS_TO_TRIGGER_NOTIFY", static_cast<PxU32>( physx::PxClientBehaviorFlag::eREPORT_FOREIGN_OBJECTS_TO_TRIGGER_NOTIFY ) },
		{ "eREPORT_FOREIGN_OBJECTS_TO_CONTACT_NOTIFY", static_cast<PxU32>( physx::PxClientBehaviorFlag::eREPORT_FOREIGN_OBJECTS_TO_CONTACT_NOTIFY ) },
		{ "eREPORT_FOREIGN_OBJECTS_TO_CONSTRAINT_BREAK_NOTIFY", static_cast<PxU32>( physx::PxClientBehaviorFlag::eREPORT_FOREIGN_OBJECTS_TO_CONSTRAINT_BREAK_NOTIFY ) },
		{ "eREPORT_FOREIGN_OBJECTS_TO_SCENE_QUERY", static_cast<PxU32>( physx::PxClientBehaviorFlag::eREPORT_FOREIGN_OBJECTS_TO_SCENE_QUERY ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxClientBehaviorFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxClientBehaviorFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxFrictionType__EnumConversion[] = {
		{ "ePATCH", static_cast<PxU32>( physx::PxFrictionType::ePATCH ) },
		{ "eONE_DIRECTIONAL", static_cast<PxU32>( physx::PxFrictionType::eONE_DIRECTIONAL ) },
		{ "eTWO_DIRECTIONAL", static_cast<PxU32>( physx::PxFrictionType::eTWO_DIRECTIONAL ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxFrictionType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxFrictionType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxVisualizationParameter__EnumConversion[] = {
		{ "eSCALE", static_cast<PxU32>( physx::PxVisualizationParameter::eSCALE ) },
		{ "eWORLD_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eWORLD_AXES ) },
		{ "eBODY_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_AXES ) },
		{ "eBODY_MASS_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_MASS_AXES ) },
		{ "eBODY_LIN_VELOCITY", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_LIN_VELOCITY ) },
		{ "eBODY_ANG_VELOCITY", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_ANG_VELOCITY ) },
		{ "eDEPRECATED_BODY_JOINT_GROUPS", static_cast<PxU32>( physx::PxVisualizationParameter::eDEPRECATED_BODY_JOINT_GROUPS ) },
		{ "eCONTACT_POINT", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_POINT ) },
		{ "eCONTACT_NORMAL", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_NORMAL ) },
		{ "eCONTACT_ERROR", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_ERROR ) },
		{ "eCONTACT_FORCE", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_FORCE ) },
		{ "eACTOR_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eACTOR_AXES ) },
		{ "eCOLLISION_AABBS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_AABBS ) },
		{ "eCOLLISION_SHAPES", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_SHAPES ) },
		{ "eCOLLISION_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_AXES ) },
		{ "eCOLLISION_COMPOUNDS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_COMPOUNDS ) },
		{ "eCOLLISION_FNORMALS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_FNORMALS ) },
		{ "eCOLLISION_EDGES", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_EDGES ) },
		{ "eCOLLISION_STATIC", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_STATIC ) },
		{ "eCOLLISION_DYNAMIC", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_DYNAMIC ) },
		{ "eDEPRECATED_COLLISION_PAIRS", static_cast<PxU32>( physx::PxVisualizationParameter::eDEPRECATED_COLLISION_PAIRS ) },
		{ "eJOINT_LOCAL_FRAMES", static_cast<PxU32>( physx::PxVisualizationParameter::eJOINT_LOCAL_FRAMES ) },
		{ "eJOINT_LIMITS", static_cast<PxU32>( physx::PxVisualizationParameter::eJOINT_LIMITS ) },
		{ "ePARTICLE_SYSTEM_POSITION", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_POSITION ) },
		{ "ePARTICLE_SYSTEM_VELOCITY", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_VELOCITY ) },
		{ "ePARTICLE_SYSTEM_COLLISION_NORMAL", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_COLLISION_NORMAL ) },
		{ "ePARTICLE_SYSTEM_BOUNDS", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_BOUNDS ) },
		{ "ePARTICLE_SYSTEM_GRID", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_GRID ) },
		{ "ePARTICLE_SYSTEM_BROADPHASE_BOUNDS", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_BROADPHASE_BOUNDS ) },
		{ "ePARTICLE_SYSTEM_MAX_MOTION_DISTANCE", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_MAX_MOTION_DISTANCE ) },
		{ "eCULL_BOX", static_cast<PxU32>( physx::PxVisualizationParameter::eCULL_BOX ) },
		{ "eCLOTH_VERTICAL", static_cast<PxU32>( physx::PxVisualizationParameter::eCLOTH_VERTICAL ) },
		{ "eCLOTH_HORIZONTAL", static_cast<PxU32>( physx::PxVisualizationParameter::eCLOTH_HORIZONTAL ) },
		{ "eCLOTH_BENDING", static_cast<PxU32>( physx::PxVisualizationParameter::eCLOTH_BENDING ) },
		{ "eCLOTH_SHEARING", static_cast<PxU32>( physx::PxVisualizationParameter::eCLOTH_SHEARING ) },
		{ "eCLOTH_VIRTUAL_PARTICLES", static_cast<PxU32>( physx::PxVisualizationParameter::eCLOTH_VIRTUAL_PARTICLES ) },
		{ "eMBP_REGIONS", static_cast<PxU32>( physx::PxVisualizationParameter::eMBP_REGIONS ) },
		{ "eNUM_VALUES", static_cast<PxU32>( physx::PxVisualizationParameter::eNUM_VALUES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxVisualizationParameter::Enum > { PxEnumTraits() : NameConversion( g_physx__PxVisualizationParameter__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxPruningStructureType__EnumConversion[] = {
		{ "eNONE", static_cast<PxU32>( physx::PxPruningStructureType::eNONE ) },
		{ "eDYNAMIC_AABB_TREE", static_cast<PxU32>( physx::PxPruningStructureType::eDYNAMIC_AABB_TREE ) },
		{ "eSTATIC_AABB_TREE", static_cast<PxU32>( physx::PxPruningStructureType::eSTATIC_AABB_TREE ) },
		{ "eLAST", static_cast<PxU32>( physx::PxPruningStructureType::eLAST ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxPruningStructureType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxPruningStructureType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxSceneQueryUpdateMode__EnumConversion[] = {
		{ "eBUILD_ENABLED_COMMIT_ENABLED", static_cast<PxU32>( physx::PxSceneQueryUpdateMode::eBUILD_ENABLED_COMMIT_ENABLED ) },
		{ "eBUILD_ENABLED_COMMIT_DISABLED", static_cast<PxU32>( physx::PxSceneQueryUpdateMode::eBUILD_ENABLED_COMMIT_DISABLED ) },
		{ "eBUILD_DISABLED_COMMIT_DISABLED", static_cast<PxU32>( physx::PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSceneQueryUpdateMode::Enum > { PxEnumTraits() : NameConversion( g_physx__PxSceneQueryUpdateMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxHitFlag__EnumConversion[] = {
		{ "ePOSITION", static_cast<PxU32>( physx::PxHitFlag::ePOSITION ) },
		{ "eNORMAL", static_cast<PxU32>( physx::PxHitFlag::eNORMAL ) },
		{ "eDISTANCE", static_cast<PxU32>( physx::PxHitFlag::eDISTANCE ) },
		{ "eUV", static_cast<PxU32>( physx::PxHitFlag::eUV ) },
		{ "eASSUME_NO_INITIAL_OVERLAP", static_cast<PxU32>( physx::PxHitFlag::eASSUME_NO_INITIAL_OVERLAP ) },
		{ "eMESH_MULTIPLE", static_cast<PxU32>( physx::PxHitFlag::eMESH_MULTIPLE ) },
		{ "eMESH_ANY", static_cast<PxU32>( physx::PxHitFlag::eMESH_ANY ) },
		{ "eMESH_BOTH_SIDES", static_cast<PxU32>( physx::PxHitFlag::eMESH_BOTH_SIDES ) },
		{ "ePRECISE_SWEEP", static_cast<PxU32>( physx::PxHitFlag::ePRECISE_SWEEP ) },
		{ "eMTD", static_cast<PxU32>( physx::PxHitFlag::eMTD ) },
		{ "eFACE_INDEX", static_cast<PxU32>( physx::PxHitFlag::eFACE_INDEX ) },
		{ "eDEFAULT", static_cast<PxU32>( physx::PxHitFlag::eDEFAULT ) },
		{ "eMODIFIABLE_FLAGS", static_cast<PxU32>( physx::PxHitFlag::eMODIFIABLE_FLAGS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxHitFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxHitFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxBroadPhaseType__EnumConversion[] = {
		{ "eSAP", static_cast<PxU32>( physx::PxBroadPhaseType::eSAP ) },
		{ "eMBP", static_cast<PxU32>( physx::PxBroadPhaseType::eMBP ) },
		{ "eGPU", static_cast<PxU32>( physx::PxBroadPhaseType::eGPU ) },
		{ "eLAST", static_cast<PxU32>( physx::PxBroadPhaseType::eLAST ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxBroadPhaseType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxBroadPhaseType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxScene;
	struct PxSceneGeneratedValues
	{
		PxSceneFlags Flags;
		PxSceneLimits Limits;
		PxU32 Timestamp;
		PxCpuDispatcher * CpuDispatcher;
		PxGpuDispatcher * GpuDispatcher;
		PxF32 ClothInterCollisionDistance;
		PxF32 ClothInterCollisionStiffness;
		PxU32 ClothInterCollisionNbIterations;
		PxContactModifyCallback * ContactModifyCallback;
		PxCCDContactModifyCallback * CCDContactModifyCallback;
		PxU32 FilterShaderDataSize;
		PxSimulationFilterShader FilterShader;
		PxSimulationFilterCallback * FilterCallback;
		PxVec3 Gravity;
		PxReal BounceThresholdVelocity;
		PxU32 CCDMaxPasses;
		PxReal FrictionOffsetThreshold;
		PxFrictionType::Enum FrictionType;
		PxBounds3 VisualizationCullingBox;
		PxPruningStructureType::Enum StaticStructure;
		PxPruningStructureType::Enum DynamicStructure;
		PxU32 DynamicTreeRebuildRateHint;
		PxSceneQueryUpdateMode::Enum SceneQueryUpdateMode;
		PxU32 SceneQueryStaticTimestamp;
		PxBroadPhaseType::Enum BroadPhaseType;
		PxTaskManager * TaskManager;
		PxU32 MaxNbContactDataBlocksUsed;
		PxU32 ContactReportStreamBufferSize;
		PxU32 SolverBatchSize;
		PxReal WakeCounterResetValue;
		void * UserData;
		PxSimulationStatistics SimulationStatistics;
		 PX_PHYSX_CORE_API PxSceneGeneratedValues( const PxScene* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Flags, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Limits, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Timestamp, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, CpuDispatcher, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, GpuDispatcher, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ClothInterCollisionDistance, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ClothInterCollisionStiffness, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ClothInterCollisionNbIterations, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ContactModifyCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, CCDContactModifyCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShaderDataSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShader, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Gravity, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, BounceThresholdVelocity, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, CCDMaxPasses, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FrictionOffsetThreshold, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FrictionType, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, VisualizationCullingBox, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, StaticStructure, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, DynamicStructure, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, DynamicTreeRebuildRateHint, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SceneQueryUpdateMode, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SceneQueryStaticTimestamp, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, BroadPhaseType, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, TaskManager, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, MaxNbContactDataBlocksUsed, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ContactReportStreamBufferSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SolverBatchSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, WakeCounterResetValue, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, UserData, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SimulationStatistics, PxSceneGeneratedValues)
	struct PxSceneGeneratedInfo

	{
		static const char* getClassName() { return "PxScene"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Flags, PxScene, PxSceneFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Limits, PxScene, const PxSceneLimits &, PxSceneLimits > Limits;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Timestamp, PxScene, PxU32 > Timestamp;
		PxReadOnlyFilteredCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Actors, PxScene, PxActor *, PxActorTypeFlags > Actors;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Articulations, PxScene, PxArticulation * > Articulations;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Constraints, PxScene, PxConstraint * > Constraints;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Aggregates, PxScene, PxAggregate * > Aggregates;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_CpuDispatcher, PxScene, PxCpuDispatcher * > CpuDispatcher;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_GpuDispatcher, PxScene, PxGpuDispatcher * > GpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ClothInterCollisionDistance, PxScene, PxF32, PxF32 > ClothInterCollisionDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ClothInterCollisionStiffness, PxScene, PxF32, PxF32 > ClothInterCollisionStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ClothInterCollisionNbIterations, PxScene, PxU32, PxU32 > ClothInterCollisionNbIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ContactModifyCallback, PxScene, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_CCDContactModifyCallback, PxScene, PxCCDContactModifyCallback *, PxCCDContactModifyCallback * > CCDContactModifyCallback;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShaderDataSize, PxScene, PxU32 > FilterShaderDataSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShader, PxScene, PxSimulationFilterShader > FilterShader;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterCallback, PxScene, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Gravity, PxScene, const PxVec3 &, PxVec3 > Gravity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_BounceThresholdVelocity, PxScene, const PxReal, PxReal > BounceThresholdVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_CCDMaxPasses, PxScene, PxU32, PxU32 > CCDMaxPasses;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FrictionOffsetThreshold, PxScene, PxReal > FrictionOffsetThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FrictionType, PxScene, PxFrictionType::Enum, PxFrictionType::Enum > FrictionType;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_VisualizationCullingBox, PxScene, const PxBounds3 &, PxBounds3 > VisualizationCullingBox;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_StaticStructure, PxScene, PxPruningStructureType::Enum > StaticStructure;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_DynamicStructure, PxScene, PxPruningStructureType::Enum > DynamicStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_DynamicTreeRebuildRateHint, PxScene, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_SceneQueryUpdateMode, PxScene, PxSceneQueryUpdateMode::Enum, PxSceneQueryUpdateMode::Enum > SceneQueryUpdateMode;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_SceneQueryStaticTimestamp, PxScene, PxU32 > SceneQueryStaticTimestamp;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_BroadPhaseType, PxScene, PxBroadPhaseType::Enum > BroadPhaseType;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_BroadPhaseRegions, PxScene, PxBroadPhaseRegionInfo > BroadPhaseRegions;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_TaskManager, PxScene, PxTaskManager * > TaskManager;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_NbContactDataBlocks, PxScene, PxU32 > NbContactDataBlocks;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_MaxNbContactDataBlocksUsed, PxScene, PxU32 > MaxNbContactDataBlocksUsed;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ContactReportStreamBufferSize, PxScene, PxU32 > ContactReportStreamBufferSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_SolverBatchSize, PxScene, PxU32, PxU32 > SolverBatchSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_WakeCounterResetValue, PxScene, PxReal > WakeCounterResetValue;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_UserData, PxScene, void *, void * > UserData;
		SimulationStatisticsProperty SimulationStatistics;

		PX_PHYSX_CORE_API PxSceneGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxScene*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 38; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Flags, inStartIndex + 0 );; 
			inOperator( Limits, inStartIndex + 1 );; 
			inOperator( Timestamp, inStartIndex + 2 );; 
			inOperator( Actors, inStartIndex + 3 );; 
			inOperator( Articulations, inStartIndex + 4 );; 
			inOperator( Constraints, inStartIndex + 5 );; 
			inOperator( Aggregates, inStartIndex + 6 );; 
			inOperator( CpuDispatcher, inStartIndex + 7 );; 
			inOperator( GpuDispatcher, inStartIndex + 8 );; 
			inOperator( ClothInterCollisionDistance, inStartIndex + 9 );; 
			inOperator( ClothInterCollisionStiffness, inStartIndex + 10 );; 
			inOperator( ClothInterCollisionNbIterations, inStartIndex + 11 );; 
			inOperator( ContactModifyCallback, inStartIndex + 12 );; 
			inOperator( CCDContactModifyCallback, inStartIndex + 13 );; 
			inOperator( FilterShaderDataSize, inStartIndex + 14 );; 
			inOperator( FilterShader, inStartIndex + 15 );; 
			inOperator( FilterCallback, inStartIndex + 16 );; 
			inOperator( Gravity, inStartIndex + 17 );; 
			inOperator( BounceThresholdVelocity, inStartIndex + 18 );; 
			inOperator( CCDMaxPasses, inStartIndex + 19 );; 
			inOperator( FrictionOffsetThreshold, inStartIndex + 20 );; 
			inOperator( FrictionType, inStartIndex + 21 );; 
			inOperator( VisualizationCullingBox, inStartIndex + 22 );; 
			inOperator( StaticStructure, inStartIndex + 23 );; 
			inOperator( DynamicStructure, inStartIndex + 24 );; 
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 25 );; 
			inOperator( SceneQueryUpdateMode, inStartIndex + 26 );; 
			inOperator( SceneQueryStaticTimestamp, inStartIndex + 27 );; 
			inOperator( BroadPhaseType, inStartIndex + 28 );; 
			inOperator( BroadPhaseRegions, inStartIndex + 29 );; 
			inOperator( TaskManager, inStartIndex + 30 );; 
			inOperator( NbContactDataBlocks, inStartIndex + 31 );; 
			inOperator( MaxNbContactDataBlocksUsed, inStartIndex + 32 );; 
			inOperator( ContactReportStreamBufferSize, inStartIndex + 33 );; 
			inOperator( SolverBatchSize, inStartIndex + 34 );; 
			inOperator( WakeCounterResetValue, inStartIndex + 35 );; 
			inOperator( UserData, inStartIndex + 36 );; 
			inOperator( SimulationStatistics, inStartIndex + 37 );; 
			return 38 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxScene>
	{ 
		PxSceneGeneratedInfo Info;
		const PxSceneGeneratedInfo* getInfo() { return &Info; }
	};

	struct PxClothParticle;
	struct PxClothParticleGeneratedValues
	{
		PxVec3 Pos;
		PxReal InvWeight;
		 PX_PHYSX_CORE_API PxClothParticleGeneratedValues( const PxClothParticle* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothParticle, Pos, PxClothParticleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothParticle, InvWeight, PxClothParticleGeneratedValues)
	struct PxClothParticleGeneratedInfo

	{
		static const char* getClassName() { return "PxClothParticle"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothParticle_Pos, PxClothParticle, PxVec3, PxVec3 > Pos;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothParticle_InvWeight, PxClothParticle, PxReal, PxReal > InvWeight;

		PX_PHYSX_CORE_API PxClothParticleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothParticle*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Pos, inStartIndex + 0 );; 
			inOperator( InvWeight, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothParticle>
	{ 
		PxClothParticleGeneratedInfo Info;
		const PxClothParticleGeneratedInfo* getInfo() { return &Info; }
	};

	struct PxClothFabricPhase;
	struct PxClothFabricPhaseGeneratedValues
	{
		PxClothFabricPhaseType::Enum PhaseType;
		PxU32 SetIndex;
		 PX_PHYSX_CORE_API PxClothFabricPhaseGeneratedValues( const PxClothFabricPhase* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabricPhase, PhaseType, PxClothFabricPhaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabricPhase, SetIndex, PxClothFabricPhaseGeneratedValues)
	struct PxClothFabricPhaseGeneratedInfo

	{
		static const char* getClassName() { return "PxClothFabricPhase"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabricPhase_PhaseType, PxClothFabricPhase, PxClothFabricPhaseType::Enum, PxClothFabricPhaseType::Enum > PhaseType;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabricPhase_SetIndex, PxClothFabricPhase, PxU32, PxU32 > SetIndex;

		PX_PHYSX_CORE_API PxClothFabricPhaseGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothFabricPhase*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( PhaseType, inStartIndex + 0 );; 
			inOperator( SetIndex, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothFabricPhase>
	{ 
		PxClothFabricPhaseGeneratedInfo Info;
		const PxClothFabricPhaseGeneratedInfo* getInfo() { return &Info; }
	};

	class PxSceneLimits;
	struct PxSceneLimitsGeneratedValues
	{
		PxU32 MaxNbActors;
		PxU32 MaxNbBodies;
		PxU32 MaxNbStaticShapes;
		PxU32 MaxNbDynamicShapes;
		PxU32 MaxNbAggregates;
		PxU32 MaxNbConstraints;
		PxU32 MaxNbRegions;
		PxU32 MaxNbBroadPhaseOverlaps;
		PxU32 MaxNbObjectsPerRegion;
		 PX_PHYSX_CORE_API PxSceneLimitsGeneratedValues( const PxSceneLimits* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbActors, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbBodies, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbStaticShapes, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbDynamicShapes, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbAggregates, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbConstraints, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbRegions, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbBroadPhaseOverlaps, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbObjectsPerRegion, PxSceneLimitsGeneratedValues)
	struct PxSceneLimitsGeneratedInfo

	{
		static const char* getClassName() { return "PxSceneLimits"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbActors, PxSceneLimits, PxU32, PxU32 > MaxNbActors;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbBodies, PxSceneLimits, PxU32, PxU32 > MaxNbBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbStaticShapes, PxSceneLimits, PxU32, PxU32 > MaxNbStaticShapes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbDynamicShapes, PxSceneLimits, PxU32, PxU32 > MaxNbDynamicShapes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbAggregates, PxSceneLimits, PxU32, PxU32 > MaxNbAggregates;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbConstraints, PxSceneLimits, PxU32, PxU32 > MaxNbConstraints;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbRegions, PxSceneLimits, PxU32, PxU32 > MaxNbRegions;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbBroadPhaseOverlaps, PxSceneLimits, PxU32, PxU32 > MaxNbBroadPhaseOverlaps;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbObjectsPerRegion, PxSceneLimits, PxU32, PxU32 > MaxNbObjectsPerRegion;

		PX_PHYSX_CORE_API PxSceneLimitsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxSceneLimits*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( MaxNbActors, inStartIndex + 0 );; 
			inOperator( MaxNbBodies, inStartIndex + 1 );; 
			inOperator( MaxNbStaticShapes, inStartIndex + 2 );; 
			inOperator( MaxNbDynamicShapes, inStartIndex + 3 );; 
			inOperator( MaxNbAggregates, inStartIndex + 4 );; 
			inOperator( MaxNbConstraints, inStartIndex + 5 );; 
			inOperator( MaxNbRegions, inStartIndex + 6 );; 
			inOperator( MaxNbBroadPhaseOverlaps, inStartIndex + 7 );; 
			inOperator( MaxNbObjectsPerRegion, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSceneLimits>
	{ 
		PxSceneLimitsGeneratedInfo Info;
		const PxSceneLimitsGeneratedInfo* getInfo() { return &Info; }
	};

	struct PxgDynamicsMemoryConfig;
	struct PxgDynamicsMemoryConfigGeneratedValues
	{
		PxU32 ConstraintBufferCapacity;
		PxU32 ContactBufferCapacity;
		PxU32 TempBufferCapacity;
		PxU32 ContactStreamSize;
		PxU32 PatchStreamSize;
		PxU32 ForceStreamCapacity;
		PxU32 HeapCapacity;
		PxU32 FoundLostPairsCapacity;
		 PX_PHYSX_CORE_API PxgDynamicsMemoryConfigGeneratedValues( const PxgDynamicsMemoryConfig* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, ConstraintBufferCapacity, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, ContactBufferCapacity, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, TempBufferCapacity, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, ContactStreamSize, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, PatchStreamSize, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, ForceStreamCapacity, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, HeapCapacity, PxgDynamicsMemoryConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxgDynamicsMemoryConfig, FoundLostPairsCapacity, PxgDynamicsMemoryConfigGeneratedValues)
	struct PxgDynamicsMemoryConfigGeneratedInfo

	{
		static const char* getClassName() { return "PxgDynamicsMemoryConfig"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_ConstraintBufferCapacity, PxgDynamicsMemoryConfig, PxU32, PxU32 > ConstraintBufferCapacity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_ContactBufferCapacity, PxgDynamicsMemoryConfig, PxU32, PxU32 > ContactBufferCapacity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_TempBufferCapacity, PxgDynamicsMemoryConfig, PxU32, PxU32 > TempBufferCapacity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_ContactStreamSize, PxgDynamicsMemoryConfig, PxU32, PxU32 > ContactStreamSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_PatchStreamSize, PxgDynamicsMemoryConfig, PxU32, PxU32 > PatchStreamSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_ForceStreamCapacity, PxgDynamicsMemoryConfig, PxU32, PxU32 > ForceStreamCapacity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_HeapCapacity, PxgDynamicsMemoryConfig, PxU32, PxU32 > HeapCapacity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxgDynamicsMemoryConfig_FoundLostPairsCapacity, PxgDynamicsMemoryConfig, PxU32, PxU32 > FoundLostPairsCapacity;

		PX_PHYSX_CORE_API PxgDynamicsMemoryConfigGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxgDynamicsMemoryConfig*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( ConstraintBufferCapacity, inStartIndex + 0 );; 
			inOperator( ContactBufferCapacity, inStartIndex + 1 );; 
			inOperator( TempBufferCapacity, inStartIndex + 2 );; 
			inOperator( ContactStreamSize, inStartIndex + 3 );; 
			inOperator( PatchStreamSize, inStartIndex + 4 );; 
			inOperator( ForceStreamCapacity, inStartIndex + 5 );; 
			inOperator( HeapCapacity, inStartIndex + 6 );; 
			inOperator( FoundLostPairsCapacity, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxgDynamicsMemoryConfig>
	{ 
		PxgDynamicsMemoryConfigGeneratedInfo Info;
		const PxgDynamicsMemoryConfigGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxPairFilteringMode__EnumConversion[] = {
		{ "eKEEP", static_cast<PxU32>( physx::PxPairFilteringMode::eKEEP ) },
		{ "eSUPPRESS", static_cast<PxU32>( physx::PxPairFilteringMode::eSUPPRESS ) },
		{ "eKILL", static_cast<PxU32>( physx::PxPairFilteringMode::eKILL ) },
		{ "eDEFAULT", static_cast<PxU32>( physx::PxPairFilteringMode::eDEFAULT ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxPairFilteringMode::Enum > { PxEnumTraits() : NameConversion( g_physx__PxPairFilteringMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSceneDesc;
	struct PxSceneDescGeneratedValues
	{
		PxVec3 Gravity;
		PxSimulationEventCallback * SimulationEventCallback;
		PxContactModifyCallback * ContactModifyCallback;
		PxCCDContactModifyCallback * CcdContactModifyCallback;
		const void * FilterShaderData;
		PxU32 FilterShaderDataSize;
		PxSimulationFilterShader FilterShader;
		PxSimulationFilterCallback * FilterCallback;
		PxPairFilteringMode::Enum KineKineFilteringMode;
		PxPairFilteringMode::Enum StaticKineFilteringMode;
		PxBroadPhaseType::Enum BroadPhaseType;
		PxBroadPhaseCallback * BroadPhaseCallback;
		PxSceneLimits Limits;
		PxFrictionType::Enum FrictionType;
		PxReal BounceThresholdVelocity;
		PxReal FrictionOffsetThreshold;
		PxReal CcdMaxSeparation;
		PxReal SolverOffsetSlop;
		PxSceneFlags Flags;
		PxCpuDispatcher * CpuDispatcher;
		PxGpuDispatcher * GpuDispatcher;
		PxPruningStructureType::Enum StaticStructure;
		PxPruningStructureType::Enum DynamicStructure;
		PxU32 DynamicTreeRebuildRateHint;
		PxSceneQueryUpdateMode::Enum SceneQueryUpdateMode;
		void * UserData;
		PxU32 SolverBatchSize;
		PxU32 NbContactDataBlocks;
		PxU32 MaxNbContactDataBlocks;
		PxReal MaxBiasCoefficient;
		PxU32 ContactReportStreamBufferSize;
		PxU32 CcdMaxPasses;
		PxReal WakeCounterResetValue;
		PxBounds3 SanityBounds;
		PxgDynamicsMemoryConfig GpuDynamicsConfig;
		PxU32 GpuMaxNumPartitions;
		PxU32 GpuComputeVersion;
		 PX_PHYSX_CORE_API PxSceneDescGeneratedValues( const PxSceneDesc* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Gravity, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SimulationEventCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactModifyCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, CcdContactModifyCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShaderData, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShaderDataSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShader, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, KineKineFilteringMode, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, StaticKineFilteringMode, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, BroadPhaseType, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, BroadPhaseCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Limits, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FrictionType, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, BounceThresholdVelocity, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FrictionOffsetThreshold, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, CcdMaxSeparation, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SolverOffsetSlop, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Flags, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, CpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, GpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, StaticStructure, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, DynamicStructure, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, DynamicTreeRebuildRateHint, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SceneQueryUpdateMode, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, UserData, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SolverBatchSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, NbContactDataBlocks, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, MaxNbContactDataBlocks, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, MaxBiasCoefficient, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactReportStreamBufferSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, CcdMaxPasses, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, WakeCounterResetValue, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SanityBounds, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, GpuDynamicsConfig, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, GpuMaxNumPartitions, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, GpuComputeVersion, PxSceneDescGeneratedValues)
	struct PxSceneDescGeneratedInfo

	{
		static const char* getClassName() { return "PxSceneDesc"; }
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ToDefault, PxSceneDesc, const PxTolerancesScale & > ToDefault;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Gravity, PxSceneDesc, PxVec3, PxVec3 > Gravity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SimulationEventCallback, PxSceneDesc, PxSimulationEventCallback *, PxSimulationEventCallback * > SimulationEventCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactModifyCallback, PxSceneDesc, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_CcdContactModifyCallback, PxSceneDesc, PxCCDContactModifyCallback *, PxCCDContactModifyCallback * > CcdContactModifyCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShaderData, PxSceneDesc, const void *, const void * > FilterShaderData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShaderDataSize, PxSceneDesc, PxU32, PxU32 > FilterShaderDataSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShader, PxSceneDesc, PxSimulationFilterShader, PxSimulationFilterShader > FilterShader;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterCallback, PxSceneDesc, PxSimulationFilterCallback *, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_KineKineFilteringMode, PxSceneDesc, PxPairFilteringMode::Enum, PxPairFilteringMode::Enum > KineKineFilteringMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_StaticKineFilteringMode, PxSceneDesc, PxPairFilteringMode::Enum, PxPairFilteringMode::Enum > StaticKineFilteringMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_BroadPhaseType, PxSceneDesc, PxBroadPhaseType::Enum, PxBroadPhaseType::Enum > BroadPhaseType;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_BroadPhaseCallback, PxSceneDesc, PxBroadPhaseCallback *, PxBroadPhaseCallback * > BroadPhaseCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Limits, PxSceneDesc, PxSceneLimits, PxSceneLimits > Limits;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FrictionType, PxSceneDesc, PxFrictionType::Enum, PxFrictionType::Enum > FrictionType;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_BounceThresholdVelocity, PxSceneDesc, PxReal, PxReal > BounceThresholdVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FrictionOffsetThreshold, PxSceneDesc, PxReal, PxReal > FrictionOffsetThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_CcdMaxSeparation, PxSceneDesc, PxReal, PxReal > CcdMaxSeparation;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SolverOffsetSlop, PxSceneDesc, PxReal, PxReal > SolverOffsetSlop;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Flags, PxSceneDesc, PxSceneFlags, PxSceneFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_CpuDispatcher, PxSceneDesc, PxCpuDispatcher *, PxCpuDispatcher * > CpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_GpuDispatcher, PxSceneDesc, PxGpuDispatcher *, PxGpuDispatcher * > GpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_StaticStructure, PxSceneDesc, PxPruningStructureType::Enum, PxPruningStructureType::Enum > StaticStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_DynamicStructure, PxSceneDesc, PxPruningStructureType::Enum, PxPruningStructureType::Enum > DynamicStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_DynamicTreeRebuildRateHint, PxSceneDesc, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SceneQueryUpdateMode, PxSceneDesc, PxSceneQueryUpdateMode::Enum, PxSceneQueryUpdateMode::Enum > SceneQueryUpdateMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_UserData, PxSceneDesc, void *, void * > UserData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SolverBatchSize, PxSceneDesc, PxU32, PxU32 > SolverBatchSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_NbContactDataBlocks, PxSceneDesc, PxU32, PxU32 > NbContactDataBlocks;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_MaxNbContactDataBlocks, PxSceneDesc, PxU32, PxU32 > MaxNbContactDataBlocks;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_MaxBiasCoefficient, PxSceneDesc, PxReal, PxReal > MaxBiasCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactReportStreamBufferSize, PxSceneDesc, PxU32, PxU32 > ContactReportStreamBufferSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_CcdMaxPasses, PxSceneDesc, PxU32, PxU32 > CcdMaxPasses;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_WakeCounterResetValue, PxSceneDesc, PxReal, PxReal > WakeCounterResetValue;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SanityBounds, PxSceneDesc, PxBounds3, PxBounds3 > SanityBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_GpuDynamicsConfig, PxSceneDesc, PxgDynamicsMemoryConfig, PxgDynamicsMemoryConfig > GpuDynamicsConfig;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_GpuMaxNumPartitions, PxSceneDesc, PxU32, PxU32 > GpuMaxNumPartitions;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_GpuComputeVersion, PxSceneDesc, PxU32, PxU32 > GpuComputeVersion;

		PX_PHYSX_CORE_API PxSceneDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxSceneDesc*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 38; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( ToDefault, inStartIndex + 0 );; 
			inOperator( Gravity, inStartIndex + 1 );; 
			inOperator( SimulationEventCallback, inStartIndex + 2 );; 
			inOperator( ContactModifyCallback, inStartIndex + 3 );; 
			inOperator( CcdContactModifyCallback, inStartIndex + 4 );; 
			inOperator( FilterShaderData, inStartIndex + 5 );; 
			inOperator( FilterShaderDataSize, inStartIndex + 6 );; 
			inOperator( FilterShader, inStartIndex + 7 );; 
			inOperator( FilterCallback, inStartIndex + 8 );; 
			inOperator( KineKineFilteringMode, inStartIndex + 9 );; 
			inOperator( StaticKineFilteringMode, inStartIndex + 10 );; 
			inOperator( BroadPhaseType, inStartIndex + 11 );; 
			inOperator( BroadPhaseCallback, inStartIndex + 12 );; 
			inOperator( Limits, inStartIndex + 13 );; 
			inOperator( FrictionType, inStartIndex + 14 );; 
			inOperator( BounceThresholdVelocity, inStartIndex + 15 );; 
			inOperator( FrictionOffsetThreshold, inStartIndex + 16 );; 
			inOperator( CcdMaxSeparation, inStartIndex + 17 );; 
			inOperator( SolverOffsetSlop, inStartIndex + 18 );; 
			inOperator( Flags, inStartIndex + 19 );; 
			inOperator( CpuDispatcher, inStartIndex + 20 );; 
			inOperator( GpuDispatcher, inStartIndex + 21 );; 
			inOperator( StaticStructure, inStartIndex + 22 );; 
			inOperator( DynamicStructure, inStartIndex + 23 );; 
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 24 );; 
			inOperator( SceneQueryUpdateMode, inStartIndex + 25 );; 
			inOperator( UserData, inStartIndex + 26 );; 
			inOperator( SolverBatchSize, inStartIndex + 27 );; 
			inOperator( NbContactDataBlocks, inStartIndex + 28 );; 
			inOperator( MaxNbContactDataBlocks, inStartIndex + 29 );; 
			inOperator( MaxBiasCoefficient, inStartIndex + 30 );; 
			inOperator( ContactReportStreamBufferSize, inStartIndex + 31 );; 
			inOperator( CcdMaxPasses, inStartIndex + 32 );; 
			inOperator( WakeCounterResetValue, inStartIndex + 33 );; 
			inOperator( SanityBounds, inStartIndex + 34 );; 
			inOperator( GpuDynamicsConfig, inStartIndex + 35 );; 
			inOperator( GpuMaxNumPartitions, inStartIndex + 36 );; 
			inOperator( GpuComputeVersion, inStartIndex + 37 );; 
			return 38 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSceneDesc>
	{ 
		PxSceneDescGeneratedInfo Info;
		const PxSceneDescGeneratedInfo* getInfo() { return &Info; }
	};

	static PxU32ToName g_physx__PxSimulationStatistics__VolumeTypeConversion[] = {
		{ "eRIGID_BODY", static_cast<PxU32>( physx::PxSimulationStatistics::eRIGID_BODY ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( physx::PxSimulationStatistics::ePARTICLE_SYSTEM ) },
		{ "eCLOTH", static_cast<PxU32>( physx::PxSimulationStatistics::eCLOTH ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSimulationStatistics::VolumeType > { PxEnumTraits() : NameConversion( g_physx__PxSimulationStatistics__VolumeTypeConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxSimulationStatistics__RbPairStatsTypeConversion[] = {
		{ "eDISCRETE_CONTACT_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eDISCRETE_CONTACT_PAIRS ) },
		{ "eCCD_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eCCD_PAIRS ) },
		{ "eMODIFIED_CONTACT_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eMODIFIED_CONTACT_PAIRS ) },
		{ "eTRIGGER_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eTRIGGER_PAIRS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSimulationStatistics::RbPairStatsType > { PxEnumTraits() : NameConversion( g_physx__PxSimulationStatistics__RbPairStatsTypeConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSimulationStatistics;
	struct PxSimulationStatisticsGeneratedValues
	{
		PxU32 NbActiveConstraints;
		PxU32 NbActiveDynamicBodies;
		PxU32 NbActiveKinematicBodies;
		PxU32 NbStaticBodies;
		PxU32 NbDynamicBodies;
		PxU32 NbAggregates;
		PxU32 NbArticulations;
		PxU32 NbAxisSolverConstraints;
		PxU32 CompressedContactSize;
		PxU32 RequiredContactConstraintMemory;
		PxU32 PeakConstraintMemory;
		PxU32 NbDiscreteContactPairsTotal;
		PxU32 NbDiscreteContactPairsWithCacheHits;
		PxU32 NbDiscreteContactPairsWithContacts;
		PxU32 NbNewPairs;
		PxU32 NbLostPairs;
		PxU32 NbNewTouches;
		PxU32 NbLostTouches;
		PxU32 NbPartitions;
		PxU32 ParticlesGpuMeshCacheSize;
		PxU32 ParticlesGpuMeshCacheUsed;
		PxReal ParticlesGpuMeshCacheHitrate;
		PxU32 NbDiscreteContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NbModifiedContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NbCCDPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NbTriggerPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NbBroadPhaseAdds[PxSimulationStatistics::eVOLUME_COUNT];
		PxU32 NbBroadPhaseRemoves[PxSimulationStatistics::eVOLUME_COUNT];
		PxU32 NbShapes[PxGeometryType::eGEOMETRY_COUNT];
		 PX_PHYSX_CORE_API PxSimulationStatisticsGeneratedValues( const PxSimulationStatistics* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbActiveConstraints, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbActiveDynamicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbActiveKinematicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbStaticBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbDynamicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbAggregates, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbArticulations, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbAxisSolverConstraints, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, CompressedContactSize, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, RequiredContactConstraintMemory, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, PeakConstraintMemory, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbDiscreteContactPairsTotal, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbDiscreteContactPairsWithCacheHits, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbDiscreteContactPairsWithContacts, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbNewPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbLostPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbNewTouches, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbLostTouches, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbPartitions, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, ParticlesGpuMeshCacheSize, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, ParticlesGpuMeshCacheUsed, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, ParticlesGpuMeshCacheHitrate, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbDiscreteContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbModifiedContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbCCDPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbTriggerPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbBroadPhaseAdds, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbBroadPhaseRemoves, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NbShapes, PxSimulationStatisticsGeneratedValues)
	struct PxSimulationStatisticsGeneratedInfo

	{
		static const char* getClassName() { return "PxSimulationStatistics"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbActiveConstraints, PxSimulationStatistics, PxU32, PxU32 > NbActiveConstraints;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbActiveDynamicBodies, PxSimulationStatistics, PxU32, PxU32 > NbActiveDynamicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbActiveKinematicBodies, PxSimulationStatistics, PxU32, PxU32 > NbActiveKinematicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbStaticBodies, PxSimulationStatistics, PxU32, PxU32 > NbStaticBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbDynamicBodies, PxSimulationStatistics, PxU32, PxU32 > NbDynamicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbAggregates, PxSimulationStatistics, PxU32, PxU32 > NbAggregates;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbArticulations, PxSimulationStatistics, PxU32, PxU32 > NbArticulations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbAxisSolverConstraints, PxSimulationStatistics, PxU32, PxU32 > NbAxisSolverConstraints;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_CompressedContactSize, PxSimulationStatistics, PxU32, PxU32 > CompressedContactSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_RequiredContactConstraintMemory, PxSimulationStatistics, PxU32, PxU32 > RequiredContactConstraintMemory;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_PeakConstraintMemory, PxSimulationStatistics, PxU32, PxU32 > PeakConstraintMemory;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbDiscreteContactPairsTotal, PxSimulationStatistics, PxU32, PxU32 > NbDiscreteContactPairsTotal;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbDiscreteContactPairsWithCacheHits, PxSimulationStatistics, PxU32, PxU32 > NbDiscreteContactPairsWithCacheHits;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbDiscreteContactPairsWithContacts, PxSimulationStatistics, PxU32, PxU32 > NbDiscreteContactPairsWithContacts;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbNewPairs, PxSimulationStatistics, PxU32, PxU32 > NbNewPairs;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbLostPairs, PxSimulationStatistics, PxU32, PxU32 > NbLostPairs;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbNewTouches, PxSimulationStatistics, PxU32, PxU32 > NbNewTouches;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbLostTouches, PxSimulationStatistics, PxU32, PxU32 > NbLostTouches;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NbPartitions, PxSimulationStatistics, PxU32, PxU32 > NbPartitions;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_ParticlesGpuMeshCacheSize, PxSimulationStatistics, PxU32, PxU32 > ParticlesGpuMeshCacheSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_ParticlesGpuMeshCacheUsed, PxSimulationStatistics, PxU32, PxU32 > ParticlesGpuMeshCacheUsed;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_ParticlesGpuMeshCacheHitrate, PxSimulationStatistics, PxReal, PxReal > ParticlesGpuMeshCacheHitrate;
		NbDiscreteContactPairsProperty NbDiscreteContactPairs;
		NbModifiedContactPairsProperty NbModifiedContactPairs;
		NbCCDPairsProperty NbCCDPairs;
		NbTriggerPairsProperty NbTriggerPairs;
		NbBroadPhaseAddsProperty NbBroadPhaseAdds;
		NbBroadPhaseRemovesProperty NbBroadPhaseRemoves;
		NbShapesProperty NbShapes;

		PX_PHYSX_CORE_API PxSimulationStatisticsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxSimulationStatistics*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 29; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( NbActiveConstraints, inStartIndex + 0 );; 
			inOperator( NbActiveDynamicBodies, inStartIndex + 1 );; 
			inOperator( NbActiveKinematicBodies, inStartIndex + 2 );; 
			inOperator( NbStaticBodies, inStartIndex + 3 );; 
			inOperator( NbDynamicBodies, inStartIndex + 4 );; 
			inOperator( NbAggregates, inStartIndex + 5 );; 
			inOperator( NbArticulations, inStartIndex + 6 );; 
			inOperator( NbAxisSolverConstraints, inStartIndex + 7 );; 
			inOperator( CompressedContactSize, inStartIndex + 8 );; 
			inOperator( RequiredContactConstraintMemory, inStartIndex + 9 );; 
			inOperator( PeakConstraintMemory, inStartIndex + 10 );; 
			inOperator( NbDiscreteContactPairsTotal, inStartIndex + 11 );; 
			inOperator( NbDiscreteContactPairsWithCacheHits, inStartIndex + 12 );; 
			inOperator( NbDiscreteContactPairsWithContacts, inStartIndex + 13 );; 
			inOperator( NbNewPairs, inStartIndex + 14 );; 
			inOperator( NbLostPairs, inStartIndex + 15 );; 
			inOperator( NbNewTouches, inStartIndex + 16 );; 
			inOperator( NbLostTouches, inStartIndex + 17 );; 
			inOperator( NbPartitions, inStartIndex + 18 );; 
			inOperator( ParticlesGpuMeshCacheSize, inStartIndex + 19 );; 
			inOperator( ParticlesGpuMeshCacheUsed, inStartIndex + 20 );; 
			inOperator( ParticlesGpuMeshCacheHitrate, inStartIndex + 21 );; 
			inOperator( NbDiscreteContactPairs, inStartIndex + 22 );; 
			inOperator( NbModifiedContactPairs, inStartIndex + 23 );; 
			inOperator( NbCCDPairs, inStartIndex + 24 );; 
			inOperator( NbTriggerPairs, inStartIndex + 25 );; 
			inOperator( NbBroadPhaseAdds, inStartIndex + 26 );; 
			inOperator( NbBroadPhaseRemoves, inStartIndex + 27 );; 
			inOperator( NbShapes, inStartIndex + 28 );; 
			return 29 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSimulationStatistics>
	{ 
		PxSimulationStatisticsGeneratedInfo Info;
		const PxSimulationStatisticsGeneratedInfo* getInfo() { return &Info; }
	};

	class PxLockedData;
	struct PxLockedDataGeneratedValues
	{
		 PX_PHYSX_CORE_API PxLockedDataGeneratedValues( const PxLockedData* inSource );
	};
	struct PxLockedDataGeneratedInfo

	{
		static const char* getClassName() { return "PxLockedData"; }

		PX_PHYSX_CORE_API PxLockedDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxLockedData*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxLockedData>
	{ 
		PxLockedDataGeneratedInfo Info;
		const PxLockedDataGeneratedInfo* getInfo() { return &Info; }
	};

	class PxParticleReadData;
	struct PxParticleReadDataGeneratedValues
		: PxLockedDataGeneratedValues	{
		PxU32 NbValidParticles;
		PxU32 ValidParticleRange;
		const PxU32 * ValidParticleBitmap;
		PxStrideIterator<const PxVec3> PositionBuffer;
		PxStrideIterator<const PxVec3> VelocityBuffer;
		PxStrideIterator<const PxF32> RestOffsetBuffer;
		PxStrideIterator<const PxParticleFlags> FlagsBuffer;
		PxStrideIterator<const PxVec3> CollisionNormalBuffer;
		PxStrideIterator<const PxVec3> CollisionVelocityBuffer;
		 PX_PHYSX_CORE_API PxParticleReadDataGeneratedValues( const PxParticleReadData* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, NbValidParticles, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, ValidParticleRange, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, ValidParticleBitmap, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, PositionBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, VelocityBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, RestOffsetBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, FlagsBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, CollisionNormalBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, CollisionVelocityBuffer, PxParticleReadDataGeneratedValues)
	struct PxParticleReadDataGeneratedInfo
		: PxLockedDataGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleReadData"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_NbValidParticles, PxParticleReadData, PxU32, PxU32 > NbValidParticles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_ValidParticleRange, PxParticleReadData, PxU32, PxU32 > ValidParticleRange;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_ValidParticleBitmap, PxParticleReadData, const PxU32 *, const PxU32 * > ValidParticleBitmap;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_PositionBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > PositionBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_VelocityBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > VelocityBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_RestOffsetBuffer, PxParticleReadData, PxStrideIterator<const PxF32>, PxStrideIterator<const PxF32> > RestOffsetBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_FlagsBuffer, PxParticleReadData, PxStrideIterator<const PxParticleFlags>, PxStrideIterator<const PxParticleFlags> > FlagsBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_CollisionNormalBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > CollisionNormalBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_CollisionVelocityBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > CollisionVelocityBuffer;

		PX_PHYSX_CORE_API PxParticleReadDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxParticleReadData*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxLockedDataGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxLockedDataGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxLockedDataGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxLockedDataGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( NbValidParticles, inStartIndex + 0 );; 
			inOperator( ValidParticleRange, inStartIndex + 1 );; 
			inOperator( ValidParticleBitmap, inStartIndex + 2 );; 
			inOperator( PositionBuffer, inStartIndex + 3 );; 
			inOperator( VelocityBuffer, inStartIndex + 4 );; 
			inOperator( RestOffsetBuffer, inStartIndex + 5 );; 
			inOperator( FlagsBuffer, inStartIndex + 6 );; 
			inOperator( CollisionNormalBuffer, inStartIndex + 7 );; 
			inOperator( CollisionVelocityBuffer, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleReadData>
	{ 
		PxParticleReadDataGeneratedInfo Info;
		const PxParticleReadDataGeneratedInfo* getInfo() { return &Info; }
	};

	struct PxClothStretchConfig;
	struct PxClothStretchConfigGeneratedValues
	{
		PxReal Stiffness;
		PxReal StiffnessMultiplier;
		PxReal CompressionLimit;
		PxReal StretchLimit;
		 PX_PHYSX_CORE_API PxClothStretchConfigGeneratedValues( const PxClothStretchConfig* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothStretchConfig, Stiffness, PxClothStretchConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothStretchConfig, StiffnessMultiplier, PxClothStretchConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothStretchConfig, CompressionLimit, PxClothStretchConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothStretchConfig, StretchLimit, PxClothStretchConfigGeneratedValues)
	struct PxClothStretchConfigGeneratedInfo

	{
		static const char* getClassName() { return "PxClothStretchConfig"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothStretchConfig_Stiffness, PxClothStretchConfig, PxReal, PxReal > Stiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothStretchConfig_StiffnessMultiplier, PxClothStretchConfig, PxReal, PxReal > StiffnessMultiplier;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothStretchConfig_CompressionLimit, PxClothStretchConfig, PxReal, PxReal > CompressionLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothStretchConfig_StretchLimit, PxClothStretchConfig, PxReal, PxReal > StretchLimit;

		PX_PHYSX_CORE_API PxClothStretchConfigGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothStretchConfig*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Stiffness, inStartIndex + 0 );; 
			inOperator( StiffnessMultiplier, inStartIndex + 1 );; 
			inOperator( CompressionLimit, inStartIndex + 2 );; 
			inOperator( StretchLimit, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothStretchConfig>
	{ 
		PxClothStretchConfigGeneratedInfo Info;
		const PxClothStretchConfigGeneratedInfo* getInfo() { return &Info; }
	};

	struct PxClothTetherConfig;
	struct PxClothTetherConfigGeneratedValues
	{
		PxReal Stiffness;
		PxReal StretchLimit;
		 PX_PHYSX_CORE_API PxClothTetherConfigGeneratedValues( const PxClothTetherConfig* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothTetherConfig, Stiffness, PxClothTetherConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothTetherConfig, StretchLimit, PxClothTetherConfigGeneratedValues)
	struct PxClothTetherConfigGeneratedInfo

	{
		static const char* getClassName() { return "PxClothTetherConfig"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothTetherConfig_Stiffness, PxClothTetherConfig, PxReal, PxReal > Stiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothTetherConfig_StretchLimit, PxClothTetherConfig, PxReal, PxReal > StretchLimit;

		PX_PHYSX_CORE_API PxClothTetherConfigGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothTetherConfig*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Stiffness, inStartIndex + 0 );; 
			inOperator( StretchLimit, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothTetherConfig>
	{ 
		PxClothTetherConfigGeneratedInfo Info;
		const PxClothTetherConfigGeneratedInfo* getInfo() { return &Info; }
	};

	struct PxClothMotionConstraintConfig;
	struct PxClothMotionConstraintConfigGeneratedValues
	{
		PxReal Scale;
		PxReal Bias;
		PxReal Stiffness;
		 PX_PHYSX_CORE_API PxClothMotionConstraintConfigGeneratedValues( const PxClothMotionConstraintConfig* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothMotionConstraintConfig, Scale, PxClothMotionConstraintConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothMotionConstraintConfig, Bias, PxClothMotionConstraintConfigGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothMotionConstraintConfig, Stiffness, PxClothMotionConstraintConfigGeneratedValues)
	struct PxClothMotionConstraintConfigGeneratedInfo

	{
		static const char* getClassName() { return "PxClothMotionConstraintConfig"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothMotionConstraintConfig_Scale, PxClothMotionConstraintConfig, PxReal, PxReal > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothMotionConstraintConfig_Bias, PxClothMotionConstraintConfig, PxReal, PxReal > Bias;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothMotionConstraintConfig_Stiffness, PxClothMotionConstraintConfig, PxReal, PxReal > Stiffness;

		PX_PHYSX_CORE_API PxClothMotionConstraintConfigGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothMotionConstraintConfig*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( Bias, inStartIndex + 1 );; 
			inOperator( Stiffness, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothMotionConstraintConfig>
	{ 
		PxClothMotionConstraintConfigGeneratedInfo Info;
		const PxClothMotionConstraintConfigGeneratedInfo* getInfo() { return &Info; }
	};

	class PxClothParticleData;
	struct PxClothParticleDataGeneratedValues
		: PxLockedDataGeneratedValues	{
		PxClothParticle * Particles;
		PxClothParticle * PreviousParticles;
		 PX_PHYSX_CORE_API PxClothParticleDataGeneratedValues( const PxClothParticleData* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothParticleData, Particles, PxClothParticleDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothParticleData, PreviousParticles, PxClothParticleDataGeneratedValues)
	struct PxClothParticleDataGeneratedInfo
		: PxLockedDataGeneratedInfo
	{
		static const char* getClassName() { return "PxClothParticleData"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothParticleData_Particles, PxClothParticleData, PxClothParticle *, PxClothParticle * > Particles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothParticleData_PreviousParticles, PxClothParticleData, PxClothParticle *, PxClothParticle * > PreviousParticles;

		PX_PHYSX_CORE_API PxClothParticleDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( reinterpret_cast<PxClothParticleData*>(NULL) );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			PX_UNUSED(inOperator);
			inOperator( *static_cast<PxLockedDataGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inStartIndex = PxLockedDataGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxLockedDataGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxLockedDataGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			PX_UNUSED(inOperator);
			PX_UNUSED(inStartIndex);
			inOperator( Particles, inStartIndex + 0 );; 
			inOperator( PreviousParticles, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothParticleData>
	{ 
		PxClothParticleDataGeneratedInfo Info;
		const PxClothParticleDataGeneratedInfo* getInfo() { return &Info; }
	};



#undef THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON
#undef PX_PROPERTY_INFO_NAME
